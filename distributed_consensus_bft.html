<!DOCTYPE html>

<html lang="en">
<head><meta content="Understand distributed consensus algorithms used in distributed systems and databases" name="description"/><meta content="distributed consensus, consensus algorithm, raft, paxos, epaxos, zab, 2pc, 3pc, bft, vsr" name="keywords"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Byzantine Fault Tolerance | AlgoViz Hub</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap" rel="stylesheet"/>
<style>
            :root {
                --primary: #0f172a;
                --secondary: #1e293b;
                --accent: #6366f1;
                --accent-light: #818cf8;
                --accent-glow: rgba(99, 102, 241, 0.2);
                --text: #e2e8f0;
                --text-secondary: #94a3b8;
                --card-bg: rgba(30, 41, 59, 0.7);
                --success: #10b981;
                --warning: #f59e0b;
                --danger: #ef4444;
                --transition: all 0.3s ease;
                --radius: 12px;
                --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                --glow: 0 0 15px var(--accent-glow);
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background: linear-gradient(
                    135deg,
                    var(--primary),
                    var(--secondary)
                );
                color: var(--text);
                font-family: "Roboto", sans-serif;
                line-height: 1.6;
                min-height: 100vh;
                padding: 0;
                position: relative;
                overflow-x: hidden;
            }

            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background:
                    radial-gradient(
                        circle at 10% 20%,
                        rgba(99, 102, 241, 0.1) 0%,
                        transparent 20%
                    ),
                    radial-gradient(
                        circle at 90% 80%,
                        rgba(129, 140, 248, 0.1) 0%,
                        transparent 20%
                    );
                z-index: -1;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }

            /* Header Styles */
            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px 0;
                position: relative;
                border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            }

            .logo {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .logo-icon {
                width: 50px;
                height: 50px;
                background: var(--accent);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: var(--glow);
            }

            .logo-icon i {
                font-size: 24px;
                color: white;
            }

            .logo-text h1 {
                font-family: "Roboto Mono", monospace;
                font-weight: 700;
                font-size: 28px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }

            .logo-text p {
                font-size: 14px;
                color: var(--text-secondary);
                letter-spacing: 1.5px;
            }

            .breadcrumb {
                font-size: 14px;
                color: var(--text-secondary);
                margin-top: 10px;
            }

            .breadcrumb a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .breadcrumb a:hover {
                text-decoration: underline;
            }

            /* Algorithm Header */
            .algorithm-header {
                margin: 40px 0;
                text-align: center;
                padding: 20px;
                background: var(--card-bg);
                border-radius: var(--radius);
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .algorithm-header::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .algorithm-header h1 {
                font-size: 42px;
                margin-bottom: 15px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                font-weight: 800;
            }

            .algorithm-header .category {
                font-size: 18px;
                color: var(--accent-light);
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

            .complexity-badge {
                display: inline-block;
                background: rgba(129, 140, 248, 0.2);
                color: var(--accent-light);
                padding: 6px 15px;
                border-radius: 20px;
                font-size: 16px;
                font-weight: 600;
                font-family: "Roboto Mono", monospace;
                margin-top: 15px;
            }

            /* Main Content Layout */
            .main-content {
                display: grid;
                grid-template-columns: 1fr 350px;
                gap: 30px;
                margin-bottom: 40px;
            }

            @media (max-width: 900px) {
                .main-content {
                    grid-template-columns: 1fr;
                }
            }

            /* Algorithm Detail Sections */
            .section {
                background: var(--card-bg);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                padding: 30px;
                margin-bottom: 30px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .section::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .section h2 {
                font-size: 26px;
                margin-bottom: 20px;
                color: var(--accent-light);
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .section h2 i {
                color: var(--accent);
                width: 36px;
                height: 36px;
                background: rgba(99, 102, 241, 0.2);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .section p {
                color: var(--text-secondary);
                font-size: 17px;
                line-height: 1.8;
                margin-bottom: 20px;
            }

            .key-points {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 20px;
                margin: 25px 0;
            }

            .point-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
            }

            .point-card h3 {
                color: var(--accent-light);
                margin-bottom: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .point-card h3 i {
                color: var(--accent);
            }

            .point-card p {
                margin-bottom: 0;
                font-size: 15px;
            }

            /* Visualization Console */
            .visualization-console {
                background: rgba(15, 23, 42, 0.8);
                border-radius: var(--radius);
                padding: 25px;
                margin: 30px 0;
                border: 1px solid rgba(99, 102, 241, 0.3);
                box-shadow: var(--glow);
            }

            .console-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }

            .console-header h3 {
                color: var(--accent-light);
                font-size: 20px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .console-controls {
                display: flex;
                gap: 10px;
            }

            .console-btn {
                background: var(--accent);
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .console-btn:hover {
                background: var(--accent-light);
            }

            .console-btn.secondary {
                background: rgba(148, 163, 184, 0.2);
            }

            .visualization-area {
                height: 400px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
                overflow: hidden;
            }

            .console-input {
                display: flex;
                gap: 10px;
                margin-top: 20px;
            }

            .console-input input {
                flex: 1;
                padding: 12px 15px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(148, 163, 184, 0.2);
                border-radius: 5px;
                color: var(--text);
                font-family: "Roboto Mono", monospace;
            }

            .console-input input:focus {
                outline: none;
                border-color: var(--accent);
            }

            /* Algorithm Properties */
            .properties-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }

            .property-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                text-align: center;
            }

            .property-card h4 {
                color: var(--text-secondary);
                font-size: 14px;
                margin-bottom: 8px;
                font-weight: 400;
            }

            .property-card .value {
                font-size: 20px;
                font-weight: 700;
                color: var(--accent-light);
                font-family: "Roboto Mono", monospace;
            }

            /* Footer */
            footer {
                text-align: center;
                padding: 40px 0 30px;
                color: var(--text-secondary);
                font-size: 14px;
                border-top: 1px solid rgba(148, 163, 184, 0.1);
                margin-top: 40px;
            }

            footer p {
                margin: 10px 0;
            }

            .footer-links {
                display: flex;
                justify-content: center;
                gap: 25px;
                margin-top: 15px;
                flex-wrap: wrap;
                margin-bottom: 20px;
            }

            .footer-links a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .footer-links a:hover {
                color: var(--accent);
            }

            /* Animations */
            @keyframes float {
                0% {
                    transform: translateY(0px);
                }
                50% {
                    transform: translateY(-10px);
                }
                100% {
                    transform: translateY(0px);
                }
            }

            .floating {
                animation: float 6s ease-in-out infinite;
            }

            /* Responsive Design */
            @media (max-width: 768px) {
                header {
                    flex-direction: column;
                    gap: 25px;
                    text-align: center;
                }

                .algorithm-header h1 {
                    font-size: 32px;
                }

                .key-points {
                    grid-template-columns: 1fr;
                }
            }

            /* Code Block Styling */
            .code-block {
                background: #0d1117;
                border-radius: 8px;
                padding: 20px;
                margin: 25px 0;
                overflow-x: auto;
                font-family: "Roboto Mono", monospace;
                font-size: 15px;
                border: 1px solid rgba(99, 102, 241, 0.3);
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                color: var(--text-secondary);
            }

            .copy-btn {
                background: rgba(99, 102, 241, 0.2);
                color: var(--accent-light);
                border: none;
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .copy-btn:hover {
                background: rgba(99, 102, 241, 0.3);
            }

            .code-block pre {
                margin: 0;
            }

            .code-block code {
                color: #c9d1d9;
                line-height: 1.5;
            }

            .keyword {
                color: #ff7b72;
            }
            .function {
                color: #d2a8ff;
            }
            .comment {
                color: #8b949e;
            }
            .string {
                color: #a5d6ff;
            }
            .number {
                color: #79c0ff;
            }

            /* BFT Visualization Styles */
            #network-container {
                width: 100%;
                height: 100%;
                position: relative;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .node {
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: var(--accent);
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                position: absolute;
                box-shadow: var(--glow);
                transition: all 0.5s ease;
                z-index: 2;
            }

            .node.primary {
                width: 70px;
                height: 70px;
                background: var(--warning);
                box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
            }

            .node.faulty {
                background: var(--danger);
                box-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
            }

            .node.agreed {
                background: var(--success);
                box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
            }

            .node.disagree {
                background: var(--danger);
                animation: pulse 1.5s infinite;
            }

            @keyframes pulse {
                0% {
                    box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
                }
                70% {
                    box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
                }
                100% {
                    box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
                }
            }

            .connection {
                position: absolute;
                height: 2px;
                background: rgba(148, 163, 184, 0.3);
                z-index: 1;
                transform-origin: left center;
            }

            .message {
                position: absolute;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: var(--accent-light);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 20px;
                z-index: 3;
                animation: float 3s ease-in-out infinite;
            }

            .phase-indicator {
                position: absolute;
                top: 10px;
                left: 10px;
                background: rgba(30, 41, 59, 0.8);
                padding: 5px 10px;
                border-radius: 20px;
                font-size: 14px;
                color: var(--accent-light);
                border: 1px solid var(--accent);
            }

            .state-info {
                position: absolute;
                bottom: 10px;
                left: 0;
                right: 0;
                text-align: center;
                font-size: 16px;
                color: var(--accent-light);
            }

            .status-panel {
                display: flex;
                justify-content: center;
                gap: 15px;
                position: absolute;
                bottom: 10px;
                width: 100%;
            }

            .status-item {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .status-label {
                font-size: 12px;
                color: var(--text-secondary);
                margin-bottom: 5px;
            }

            .status-value {
                font-size: 14px;
                font-weight: bold;
            }

            .faulty-indicator {
                position: absolute;
                top: -15px;
                right: -15px;
                width: 25px;
                height: 25px;
                background: var(--danger);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
                animation: pulse 1.5s infinite;
            }

            .controls {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin-top: 15px;
            }
        </style>
<meta content="Byzantine Fault Tolerance | AlgoViz Hub" property="og:title"/><meta content="Understand distributed consensus algorithms used in distributed systems and databases" property="og:description"/><meta content="article" property="og:type"/><meta content="https://sgkandale.github.io/distributed_consensus_bft.html" property="og:url"/><meta content="AlgoViz Hub" property="og:site_name"/><meta content="summary" name="twitter:card"/><meta content="Byzantine Fault Tolerance | AlgoViz Hub" name="twitter:title"/><meta content="Understand distributed consensus algorithms used in distributed systems and databases" name="twitter:description"/><meta content="@sgkandale" name="twitter:site"/><link href="https://sgkandale.github.io/distributed_consensus_bft.html" rel="canonical"/><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Byzantine Fault Tolerance | AlgoViz Hub",
  "description": "Understand distributed consensus algorithms used in distributed systems and databases",
  "author": {
    "@type": "Person",
    "name": "Shantanu Kandale"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AlgoViz Hub",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sgkandale.github.io/favicon.ico"
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sgkandale.github.io/distributed_consensus_bft.html"
  }
}</script></head>
<body>
<div class="container">
<!-- Header -->
<header>
<div class="logo">
<div class="logo-icon floating">
<i class="fas fa-shield-alt"></i>
</div>
<div class="logo-text">
<h1>AlgoViz Hub</h1>
<p>ALGORITHM VISUALIZATION REPOSITORY</p>
<div class="breadcrumb">
<a href="#"><i class="fas fa-home"></i> Home</a> &gt;
                            <a href="#">Consensus Algorithms</a> &gt;
                            <span>Byzantine Fault Tolerance</span>
</div>
</div>
</div>
</header>
<!-- Algorithm Header -->
<div class="algorithm-header">
<h1>Byzantine Fault Tolerance</h1>
<div class="category">
<i class="fas fa-shield-alt"></i> Fault-Tolerant Consensus
                    Algorithm
                </div>
<div class="complexity-badge">Min Nodes: 3f+1 (f faulty)</div>
</div>
<!-- Main Content -->
<div class="main-content">
<!-- Left Column: Algorithm Details -->
<div class="left-column">
<!-- Description Section -->
<div class="section">
<h2>
<i class="fas fa-file-alt"></i> Algorithm Overview
                        </h2>
<p>
                            Byzantine Fault Tolerance (BFT) is a property of
                            distributed systems that allows them to reach
                            consensus even when some nodes fail or act
                            maliciously. Practical Byzantine Fault Tolerance
                            (PBFT) is a seminal algorithm that enables
                            distributed systems to function correctly despite
                            arbitrary node failures, including malicious
                            behavior.
                        </p>
<p>
                            PBFT works through a three-phase consensus process:
                            <strong>Pre-Prepare</strong>,
                            <strong>Prepare</strong>, and
                            <strong>Commit</strong>. The system requires at
                            least 3f+1 nodes to tolerate f faulty nodes. This
                            ensures that honest nodes can agree on a consistent
                            state even when up to one-third of the nodes are
                            Byzantine (malicious or faulty).
                        </p>
<div class="key-points">
<div class="point-card">
<h3>
<i class="fas fa-check-circle"></i> Key
                                    Feature
                                </h3>
<p>
                                    Tolerates arbitrary failures including
                                    malicious behavior
                                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-bolt"></i> Performance</h3>
<p>
                                    Operates efficiently in asynchronous systems
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-memory"></i> Fault
                                    Tolerance
                                </h3>
<p>
                                    Requires 3f+1 nodes to tolerate f faulty
                                    nodes
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-project-diagram"></i>
                                    Approach
                                </h3>
<p>
                                    Replication with voting and cryptographic
                                    signatures
                                </p>
</div>
</div>
</div>
<!-- Visualization Console -->
<div class="section">
<h2>
<i class="fas fa-laptop-code"></i> Interactive
                            Visualization
                        </h2>
<p>
                            Visualize how Byzantine Fault Tolerance works in a
                            network with malicious nodes. The primary node
                            (yellow) initiates a request. Honest nodes (blue)
                            follow the protocol, while Byzantine nodes (red) try
                            to disrupt consensus. Observe how the system still
                            reaches agreement despite malicious behavior.
                        </p>
<div class="visualization-console">
<div class="console-header">
<h3>
<i class="fas fa-play-circle"></i> PBFT
                                    Protocol Visualization
                                </h3>
<div class="console-controls">
<button class="console-btn secondary" id="reset-btn">
<i class="fas fa-redo"></i> Reset
                                    </button>
<button class="console-btn" id="run-btn">
<i class="fas fa-play"></i> Run
                                    </button>
<button class="console-btn secondary" id="faulty-btn">
<i class="fas fa-bug"></i> Toggle Faulty
                                    </button>
</div>
</div>
<div class="visualization-area">
<div id="network-container">
<div class="phase-indicator">
                                        Phase:
                                        <span id="phase-text">Not Started</span>
</div>
<div class="state-info" id="state-info">
                                        Consensus State: Not Started
                                    </div>
<!-- Nodes will be dynamically created here -->
</div>
</div>
<div class="console-input">
<input id="nodes-input" placeholder="Number of nodes (default: 4)" type="text"/>
<button class="console-btn" id="random-btn">
<i class="fas fa-random"></i> Randomize
                                </button>
</div>
</div>
</div>
<!-- Algorithm Steps -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
<p>
                            The PBFT protocol operates in three distinct phases
                            to achieve consensus:
                        </p>
<div class="key-points">
<div class="point-card">
<h3>
<i class="fas fa-comments"></i> Phase 1:
                                    Pre-Prepare
                                </h3>
<p>
                                    The primary node assigns a sequence number
                                    to the client request and broadcasts a
                                    pre-prepare message to all backup nodes.
                                    This message includes the request and its
                                    digest.
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-check-circle"></i> Phase 2:
                                    Prepare
                                </h3>
<p>
                                    Each node verifies the pre-prepare message
                                    and broadcasts prepare messages to all other
                                    nodes. Nodes collect prepare messages until
                                    they have 2f+1 matching messages.
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-check-double"></i> Phase 3:
                                    Commit
                                </h3>
<p>
                                    Nodes broadcast commit messages after
                                    receiving 2f+1 prepare messages. After
                                    receiving 2f+1 matching commit messages,
                                    nodes execute the request and reply to the
                                    client.
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-exclamation-triangle"></i>
                                    View Change
                                </h3>
<p>
                                    If the primary is faulty, nodes can initiate
                                    a view change to elect a new primary. This
                                    ensures liveness even when the primary is
                                    malicious.
                                </p>
</div>
</div>
</div>
<!-- Pseudocode Section -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
<div class="code-block">
<pre><code>// Primary node behavior
function primaryNode(request):
    sequence = nextSequenceNumber()
    broadcast(PRE_PREPARE, request, sequence, digest(request))

// Backup node behavior
function backupNode():
    on receive(PRE_PREPARE, request, seq, digest) from primary:
        if valid(request, seq, digest):
            broadcast(PREPARE, seq, digest)
        else:
            // Initiate view change if primary is faulty

    on receive(PREPARE, seq, digest) from 2f nodes:
        broadcast(COMMIT, seq, digest)

    on receive(COMMIT, seq, digest) from 2f+1 nodes:
        execute(request)
        sendReplyToClient()

// View change protocol
function startViewChange():
    if timeout without progress:
        broadcast(VIEW_CHANGE, newView)
        if received 2f+1 VIEW_CHANGE messages:
            becomePrimary(newView)
            broadcast(NEW_VIEW, newView)</code></pre>
</div>
</div>
<!-- Implementation Section -->
<div class="section">
<h2><i class="fas fa-code"></i> Implementation</h2>
<p>
                            Below is a simplified Python implementation of the
                            PBFT algorithm. The implementation includes the core
                            phases and basic fault tolerance mechanisms.
                        </p>
<div class="code-block">
<div class="code-header">
<span>Python Implementation</span>
<button class="copy-btn">
<i class="fas fa-copy"></i> Copy Code
                                </button>
</div>
<pre><code><span class="keyword">import</span> hashlib
<span class="keyword">import</span> random

<span class="keyword">class</span> <span class="function">PBFTNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, node_id, is_primary=False, is_faulty=False):
        self.node_id = node_id
        self.is_primary = is_primary
        self.is_faulty = is_faulty
        self.sequence_number = 0
        self.prepare_messages = {}
        self.commit_messages = {}
        self.view = 0

    <span class="keyword">def</span> <span class="function">pre_prepare</span>(self, request):
        <span class="keyword">if</span> <span class="keyword">not</span> self.is_primary:
            <span class="keyword">return</span>  <span class="comment"># Only primary can send pre-prepare</span>

        self.sequence_number += 1
        digest = self._hash(request)
        <span class="keyword">return</span> {
            'type': 'PRE_PREPARE',
            'view': self.view,
            'sequence': self.sequence_number,
            'digest': digest,
            'request': request
        }

    <span class="keyword">def</span> <span class="function">receive_pre_prepare</span>(self, message):
        <span class="keyword">if</span> self.is_faulty:
            <span class="comment"># Byzantine behavior: send conflicting messages</span>
            <span class="keyword">return</span> random.choice([self._prepare(message), self._malicious_behavior()])

        <span class="keyword">if</span> self._validate_pre_prepare(message):
            <span class="keyword">return</span> self._prepare(message)
        <span class="keyword">return</span> <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">_prepare</span>(self, message):
        <span class="keyword">return</span> {
            'type': 'PREPARE',
            'view': message['view'],
            'sequence': message['sequence'],
            'digest': message['digest'],
            'node_id': self.node_id
        }

    <span class="keyword">def</span> <span class="function">receive_prepare</span>(self, message, total_nodes):
        <span class="keyword">if</span> self.is_faulty:
            <span class="keyword">return</span> random.choice([self._commit(message, total_nodes), self._malicious_behavior()])

        key = (message['view'], message['sequence'], message['digest'])
        self.prepare_messages.setdefault(key, set()).add(message['node_id'])

        <span class="keyword">if</span> len(self.prepare_messages[key]) &gt;= 2 * (total_nodes // 3) + 1:
            <span class="keyword">return</span> self._commit(message, total_nodes)
        <span class="keyword">return</span> <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">_commit</span>(self, message, total_nodes):
        <span class="keyword">return</span> {
            'type': 'COMMIT',
            'view': message['view'],
            'sequence': message['sequence'],
            'digest': message['digest'],
            'node_id': self.node_id
        }

    <span class="keyword">def</span> <span class="function">receive_commit</span>(self, message, total_nodes):
        key = (message['view'], message['sequence'], message['digest'])
        self.commit_messages.setdefault(key, set()).add(message['node_id'])

        <span class="keyword">if</span> len(self.commit_messages[key]) &gt;= 2 * (total_nodes // 3) + 1:
            <span class="comment"># Execute the request</span>
            <span class="keyword">return</span> <span class="string">"EXECUTE"</span>
        <span class="keyword">return</span> <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">_validate_pre_prepare</span>(self, message):
        <span class="comment"># Validate digest and sequence number</span>
        computed_digest = self._hash(message['request'])
        <span class="keyword">return</span> computed_digest == message['digest'] <span class="keyword">and</span> message['sequence'] &gt; self.sequence_number

    <span class="keyword">def</span> <span class="function">_hash</span>(self, data):
        <span class="keyword">return</span> hashlib.sha256(str(data).encode()).hexdigest()

    <span class="keyword">def</span> <span class="function">_malicious_behavior</span>(self):
        <span class="comment"># Byzantine nodes send conflicting messages</span>
        <span class="keyword">return</span> {
            'type': 'PREPARE' <span class="keyword">if</span> random.random() &gt; 0.5 <span class="keyword">else</span> 'COMMIT',
            'view': self.view,
            'sequence': random.randint(1, 100),
            'digest': 'malicious_digest',
            'node_id': self.node_id
        }

<span class="comment"># Example usage</span>
nodes = [
    PBFTNode(0, is_primary=True),
    PBFTNode(1),
    PBFTNode(2),
    PBFTNode(3, is_faulty=True)  <span class="comment"># One Byzantine node</span>
]

request = "Transfer $100 from A to B"
pre_prepare = nodes[0].pre_prepare(request)

<span class="comment"># Simulate message passing</span>
<span class="keyword">for</span> node <span class="keyword">in</span> nodes[1:]:
    prepare = node.receive_pre_prepare(pre_prepare)
    <span class="comment"># Broadcast prepare to all nodes...</span></code></pre>
</div>
</div>
</div>
<!-- Right Column: Additional Info -->
<div class="right-column">
<!-- Properties Section -->
<div class="section">
<h2>
<i class="fas fa-info-circle"></i> Algorithm
                            Properties
                        </h2>
<div class="properties-grid">
<div class="property-card">
<h4>Category</h4>
<div class="value">Consensus</div>
</div>
<div class="property-card">
<h4>Type</h4>
<div class="value">State Machine</div>
</div>
<div class="property-card">
<h4>Fault Tolerance</h4>
<div class="value">Byzantine</div>
</div>
<div class="property-card">
<h4>Min Nodes</h4>
<div class="value">3f+1</div>
</div>
<div class="property-card">
<h4>Message Complexity</h4>
<div class="value">O(n²)</div>
</div>
<div class="property-card">
<h4>Safety</h4>
<div class="value">Guaranteed</div>
</div>
<div class="property-card">
<h4>Liveness</h4>
<div class="value">With View Change</div>
</div>
<div class="property-card">
<h4>Applications</h4>
<div class="value">Blockchain</div>
</div>
</div>
</div>
<!-- Applications Section -->
<div class="section">
<h2><i class="fas fa-lightbulb"></i> Applications</h2>
<p>
                            Byzantine Fault Tolerance is crucial for systems
                            operating in untrusted environments:
                        </p>
<ul style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            ">
<li style="margin-bottom: 10px">
                                Blockchain networks (e.g., Hyperledger,
                                Tendermint)
                            </li>
<li style="margin-bottom: 10px">
                                Aircraft control systems and avionics
                            </li>
<li style="margin-bottom: 10px">
                                Nuclear power plant controls
                            </li>
<li style="margin-bottom: 10px">
                                Financial transaction systems
                            </li>
<li>Military command and control systems</li>
</ul>
</div>
<!-- Comparison Section -->
<div class="section">
<h2><i class="fas fa-balance-scale"></i> BFT vs CFT</h2>
<p>
                            Key differences between Byzantine and Crash Fault
                            Tolerance:
                        </p>
<ul style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            ">
<li style="margin-bottom: 10px">
<strong>Fault Model:</strong> BFT handles
                                arbitrary failures, CFT only crash failures
                            </li>
<li style="margin-bottom: 10px">
<strong>Node Requirements:</strong> BFT requires
                                3f+1 nodes, CFT requires 2f+1
                            </li>
<li style="margin-bottom: 10px">
<strong>Security:</strong> BFT provides security
                                against malicious actors
                            </li>
<li style="margin-bottom: 10px">
<strong>Complexity:</strong> BFT is more complex
                                due to malicious behavior handling
                            </li>
<li>
<strong>Use Cases:</strong> BFT for adversarial
                                environments, CFT for trusted networks
                            </li>
</ul>
</div>
</div>
</div>
<!-- Footer -->
<footer>
<div class="footer-links">
<a href="https://www.linkedin.com/in/sgkandale/" target="_blank"><i class="fa-brands fa-linkedin"></i> LinkedIN</a>
<a href="mailto:me@sgkandale.com"><i class="fa-solid fa-at"></i> E-Mail</a>
<a href="https://buymeacoffee.com/sgkandale" target="_blank"><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a>
</div>
<p>
                    AlgoViz Hub - Interactive Algorithm Visualization Platform
                </p>
<p>© 2025 AlgoViz Hub. All rights reserved.</p>
</footer>
</div>
<script>
            // Visualization state
            let vizState = {
                phase: "not-started",
                nodes: [],
                faultyNodes: 1,
                totalNodes: 4,
                primaryNode: 0,
                requestValue: "A",
                agreedValue: null,
            };

            // DOM Elements
            const runBtn = document.getElementById("run-btn");
            const resetBtn = document.getElementById("reset-btn");
            const faultyBtn = document.getElementById("faulty-btn");
            const randomBtn = document.getElementById("random-btn");
            const nodesInput = document.getElementById("nodes-input");
            const phaseText = document.getElementById("phase-text");
            const stateInfo = document.getElementById("state-info");
            const networkContainer =
                document.getElementById("network-container");

            // Initialize visualization
            function initViz() {
                vizState = {
                    phase: "not-started",
                    nodes: [],
                    faultyNodes: 1,
                    totalNodes: 4,
                    primaryNode: 0,
                    requestValue: "A",
                    agreedValue: null,
                };

                // Reset UI
                phaseText.textContent = "Not Started";
                stateInfo.textContent = "Consensus State: Not Started";

                // Clear existing nodes
                networkContainer
                    .querySelectorAll(".node, .connection, .message")
                    .forEach((el) => el.remove());

                // Create nodes
                createNodes();
            }

            // Create network nodes in a circular arrangement
            function createNodes() {
                const centerX = networkContainer.offsetWidth / 2;
                const centerY = networkContainer.offsetHeight / 2;
                const radius = Math.min(centerX, centerY) * 0.7;

                // Create connections first
                for (let i = 0; i < vizState.totalNodes; i++) {
                    for (let j = i + 1; j < vizState.totalNodes; j++) {
                        const angleI =
                            (i * 2 * Math.PI) / vizState.totalNodes -
                            Math.PI / 2;
                        const angleJ =
                            (j * 2 * Math.PI) / vizState.totalNodes -
                            Math.PI / 2;

                        const x1 = centerX + radius * Math.cos(angleI);
                        const y1 = centerY + radius * Math.sin(angleI);
                        const x2 = centerX + radius * Math.cos(angleJ);
                        const y2 = centerY + radius * Math.sin(angleJ);

                        const length = Math.sqrt(
                            Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2),
                        );
                        const angle =
                            (Math.atan2(y2 - y1, x2 - x1) * 180) / Math.PI;

                        const connection = document.createElement("div");
                        connection.className = "connection";
                        connection.style.width = `${length}px`;
                        connection.style.transform = `rotate(${angle}deg)`;
                        connection.style.left = `${x1}px`;
                        connection.style.top = `${y1}px`;

                        networkContainer.appendChild(connection);
                    }
                }

                // Create nodes
                for (let i = 0; i < vizState.totalNodes; i++) {
                    const angle =
                        (i * 2 * Math.PI) / vizState.totalNodes - Math.PI / 2;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);

                    const node = document.createElement("div");
                    node.className = "node";
                    if (i === vizState.primaryNode) {
                        node.classList.add("primary");
                    }
                    if (i < vizState.faultyNodes) {
                        node.classList.add("faulty");

                        // Add faulty indicator
                        const indicator = document.createElement("div");
                        indicator.className = "faulty-indicator";
                        indicator.innerHTML = '<i class="fas fa-skull"></i>';
                        node.appendChild(indicator);
                    }
                    node.style.left = `${x}px`;
                    node.style.top = `${y}px`;
                    node.textContent =
                        i === vizState.primaryNode ? "P" : `N${i}`;
                    node.id = `node-${i}`;

                    networkContainer.appendChild(node);
                }
            }

            // Create message between nodes
            function createMessage(from, to, phase, value) {
                const fromNode = document.getElementById(`node-${from}`);
                const toNode = document.getElementById(`node-${to}`);

                if (!fromNode || !toNode) return;

                const fromRect = fromNode.getBoundingClientRect();
                const toRect = toNode.getBoundingClientRect();
                const containerRect = networkContainer.getBoundingClientRect();

                const offsetX = containerRect.left;
                const offsetY = containerRect.top;

                const x1 = fromRect.left + fromRect.width / 2 - offsetX;
                const y1 = fromRect.top + fromRect.height / 2 - offsetY;
                const x2 = toRect.left + toRect.width / 2 - offsetX;
                const y2 = toRect.top + toRect.height / 2 - offsetY;

                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;

                const message = document.createElement("div");
                message.className = "message";
                message.style.left = `${midX}px`;
                message.style.top = `${midY}px`;

                // Different symbols for different phases
                let symbol;
                if (phase === "pre-prepare") {
                    symbol = '<i class="fas fa-envelope"></i>';
                    message.style.backgroundColor = "var(--accent)";
                } else if (phase === "prepare") {
                    symbol = '<i class="fas fa-check-circle"></i>';
                    message.style.backgroundColor = "var(--success)";
                } else {
                    symbol = '<i class="fas fa-lock"></i>';
                    message.style.backgroundColor = "var(--warning)";
                }

                message.innerHTML = `${symbol}<div class="message-value">${value}</div>`;

                networkContainer.appendChild(message);

                // Remove message after delay
                setTimeout(() => {
                    if (message.parentNode) {
                        message.style.opacity = "0";
                        setTimeout(() => {
                            if (message.parentNode) {
                                networkContainer.removeChild(message);
                            }
                        }, 500);
                    }
                }, 2000);

                return message;
            }

            // Run the PBFT protocol
            async function runProtocol() {
                if (vizState.phase !== "not-started") return;

                // Reset state
                initViz();
                await delay(500);

                // Set phase to Pre-Prepare
                vizState.phase = "pre-prepare";
                phaseText.textContent = "Pre-Prepare";
                stateInfo.textContent = "Primary is broadcasting the request";

                // Primary sends pre-prepare to all nodes
                for (let i = 0; i < vizState.totalNodes; i++) {
                    if (i !== vizState.primaryNode) {
                        createMessage(
                            vizState.primaryNode,
                            i,
                            "pre-prepare",
                            vizState.requestValue,
                        );
                        await delay(600);
                    }
                }

                await delay(1000);

                // Set phase to Prepare
                vizState.phase = "prepare";
                phaseText.textContent = "Prepare";
                stateInfo.textContent =
                    "Nodes are preparing and broadcasting messages";

                // Each node sends prepare messages
                for (let from = 0; from < vizState.totalNodes; from++) {
                    if (from === vizState.primaryNode) continue; // Primary already sent

                    for (let to = 0; to < vizState.totalNodes; to++) {
                        if (to !== from) {
                            // Faulty nodes sometimes send wrong values
                            const isFaulty = from < vizState.faultyNodes;
                            const sendValue =
                                isFaulty && Math.random() > 0.5
                                    ? "X"
                                    : vizState.requestValue;

                            createMessage(from, to, "prepare", sendValue);
                            await delay(300);
                        }
                    }
                    await delay(400);
                }

                await delay(1500);

                // Set phase to Commit
                vizState.phase = "commit";
                phaseText.textContent = "Commit";
                stateInfo.textContent =
                    "Nodes are committing and reaching consensus";

                // Each node sends commit messages
                for (let from = 0; from < vizState.totalNodes; from++) {
                    for (let to = 0; to < vizState.totalNodes; to++) {
                        if (to !== from) {
                            // Faulty nodes sometimes send wrong commit messages
                            const isFaulty = from < vizState.faultyNodes;
                            const sendValue =
                                isFaulty && Math.random() > 0.5
                                    ? "X"
                                    : vizState.requestValue;

                            createMessage(from, to, "commit", sendValue);
                            await delay(200);
                        }
                    }
                    await delay(300);
                }

                await delay(1500);

                // Nodes reach consensus
                stateInfo.textContent =
                    "Consensus reached! All honest nodes agreed on the value";
                phaseText.textContent = "Complete";
                vizState.phase = "complete";

                // Mark nodes as agreed
                for (
                    let i = vizState.faultyNodes;
                    i < vizState.totalNodes;
                    i++
                ) {
                    const node = document.getElementById(`node-${i}`);
                    node.classList.remove("primary");
                    node.classList.add("agreed");
                    await delay(400);
                }

                // Mark primary as agreed
                const primaryNode = document.getElementById(
                    `node-${vizState.primaryNode}`,
                );
                if (vizState.primaryNode >= vizState.faultyNodes) {
                    primaryNode.classList.add("agreed");
                }

                // Show the agreed value
                const valueDisplay = document.createElement("div");
                valueDisplay.className = "message";
                valueDisplay.style.left = "50%";
                valueDisplay.style.top = "50%";
                valueDisplay.style.transform = "translate(-50%, -50%)";
                valueDisplay.style.width = "120px";
                valueDisplay.style.height = "120px";
                valueDisplay.style.fontSize = "32px";
                valueDisplay.style.zIndex = "10";
                valueDisplay.innerHTML = `<div style="font-size: 24px;">Agreed Value</div><div style="font-size: 48px; margin-top: 10px;">${vizState.requestValue}</div>`;
                networkContainer.appendChild(valueDisplay);
            }

            // Toggle faulty nodes
            function toggleFaultyNodes() {
                vizState.faultyNodes =
                    (vizState.faultyNodes + 1) %
                    (Math.floor(vizState.totalNodes / 3) + 1);
                if (vizState.faultyNodes === 0) vizState.faultyNodes = 1;
                initViz();
            }

            // Helper function for delays
            function delay(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            // Event Listeners
            runBtn.addEventListener("click", runProtocol);
            resetBtn.addEventListener("click", initViz);
            faultyBtn.addEventListener("click", toggleFaultyNodes);
            randomBtn.addEventListener("click", () => {
                const count = Math.floor(Math.random() * 3) + 4; // 4-6 nodes
                nodesInput.value = count;
                vizState.totalNodes = count;
                vizState.faultyNodes = Math.max(1, Math.floor(count / 3));
                initViz();
            });

            nodesInput.addEventListener("change", (e) => {
                const count = parseInt(e.target.value) || 4;
                if (count < 4) count = 4;
                if (count > 7) count = 7;
                vizState.totalNodes = count;
                vizState.faultyNodes = Math.max(1, Math.floor(count / 3));
                initViz();
            });

            // Initialize
            document.addEventListener("DOMContentLoaded", initViz);
        </script>
</body>
</html>
