<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Raft Consensus | AlgoViz Hub</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary: #0f172a;
        --secondary: #1e293b;
        --accent: #6366f1;
        --accent-light: #818cf8;
        --accent-glow: rgba(99, 102, 241, 0.2);
        --text: #e2e8f0;
        --text-secondary: #94a3b8;
        --card-bg: rgba(30, 41, 59, 0.7);
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --transition: all 0.3s ease;
        --radius: 12px;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        --glow: 0 0 15px var(--accent-glow);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: var(--text);
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        min-height: 100vh;
        padding: 0;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 10% 20%,
            rgba(99, 102, 241, 0.1) 0%,
            transparent 20%
          ),
          radial-gradient(
            circle at 90% 80%,
            rgba(129, 140, 248, 0.1) 0%,
            transparent 20%
          );
        z-index: -1;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      /* Header Styles */
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 0;
        position: relative;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .logo-icon {
        width: 50px;
        height: 50px;
        background: var(--accent);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--glow);
      }

      .logo-icon i {
        font-size: 24px;
        color: white;
      }

      .logo-text h1 {
        font-family: "Roboto Mono", monospace;
        font-weight: 700;
        font-size: 28px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .logo-text p {
        font-size: 14px;
        color: var(--text-secondary);
        letter-spacing: 1.5px;
      }

      .breadcrumb {
        font-size: 14px;
        color: var(--text-secondary);
        margin-top: 10px;
      }

      .breadcrumb a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .breadcrumb a:hover {
        text-decoration: underline;
      }

      /* Algorithm Header */
      .algorithm-header {
        margin: 40px 0;
        text-align: center;
        padding: 20px;
        background: var(--card-bg);
        border-radius: var(--radius);
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .algorithm-header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .algorithm-header h1 {
        font-size: 42px;
        margin-bottom: 15px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 800;
      }

      .algorithm-header .category {
        font-size: 18px;
        color: var(--accent-light);
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .complexity-badge {
        display: inline-block;
        background: rgba(129, 140, 248, 0.2);
        color: var(--accent-light);
        padding: 6px 15px;
        border-radius: 20px;
        font-size: 16px;
        font-weight: 600;
        font-family: "Roboto Mono", monospace;
        margin-top: 15px;
      }

      /* Main Content Layout */
      .main-content {
        display: grid;
        grid-template-columns: 1fr 350px;
        gap: 30px;
        margin-bottom: 40px;
      }

      @media (max-width: 900px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }

      /* Algorithm Detail Sections */
      .section {
        background: var(--card-bg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 30px;
        margin-bottom: 30px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .section::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .section h2 {
        font-size: 26px;
        margin-bottom: 20px;
        color: var(--accent-light);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .section h2 i {
        color: var(--accent);
        width: 36px;
        height: 36px;
        background: rgba(99, 102, 241, 0.2);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .section p {
        color: var(--text-secondary);
        font-size: 17px;
        line-height: 1.8;
        margin-bottom: 20px;
      }

      .key-points {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin: 25px 0;
      }

      .point-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
      }

      .point-card h3 {
        color: var(--accent-light);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .point-card h3 i {
        color: var(--accent);
      }

      .point-card p {
        margin-bottom: 0;
        font-size: 15px;
      }

      /* Visualization Console */
      .visualization-console {
        background: rgba(15, 23, 42, 0.8);
        border-radius: var(--radius);
        padding: 25px;
        margin: 30px 0;
        border: 1px solid rgba(99, 102, 241, 0.3);
        box-shadow: var(--glow);
      }

      .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .console-header h3 {
        color: var(--accent-light);
        font-size: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .console-controls {
        display: flex;
        gap: 10px;
      }

      .console-btn {
        background: var(--accent);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .console-btn:hover {
        background: var(--accent-light);
      }

      .console-btn.secondary {
        background: rgba(148, 163, 184, 0.2);
      }

      .console-btn:disabled {
        background: rgba(148, 163, 184, 0.1);
        cursor: not-allowed;
        opacity: 0.7;
      }

      .visualization-area {
        height: 400px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
        padding: 20px;
      }

      .cluster-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 40px;
        flex-wrap: wrap;
        height: 100%;
        width: 100%;
      }

      .node {
        width: 100px;
        height: 120px;
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        transition: var(--transition);
      }

      .node-circle {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: bold;
        border: 3px solid var(--accent-light);
        background: rgba(30, 41, 59, 0.7);
        box-shadow: 0 0 10px rgba(129, 140, 248, 0.3);
        position: relative;
        z-index: 2;
        transition: var(--transition);
      }

      .node.leader .node-circle {
        background: rgba(16, 185, 129, 0.2);
        border-color: var(--success);
        box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
      }

      .node.candidate .node-circle {
        background: rgba(245, 158, 11, 0.2);
        border-color: var(--warning);
        box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
      }

      .node.follower .node-circle {
        background: rgba(99, 102, 241, 0.2);
      }

      .node-label {
        margin-top: 10px;
        text-align: center;
        font-size: 14px;
        font-weight: bold;
      }

      .node-term {
        position: absolute;
        top: -20px;
        font-size: 12px;
        color: var(--accent-light);
      }

      .log-container {
        position: absolute;
        bottom: 0;
        width: 100%;
        height: 30px;
        display: flex;
        justify-content: center;
        gap: 2px;
      }

      .log-entry {
        width: 12px;
        height: 12px;
        border-radius: 2px;
        background: var(--accent-light);
      }

      .log-entry.committed {
        background: var(--success);
      }

      .communication-line {
        position: absolute;
        height: 3px;
        background: var(--accent-light);
        transform-origin: left center;
        z-index: 1;
        opacity: 0.7;
      }

      .communication-line.active {
        background: var(--warning);
        box-shadow: 0 0 8px var(--warning);
        opacity: 1;
      }

      .status-message {
        position: absolute;
        top: 20px;
        left: 0;
        width: 100%;
        text-align: center;
        font-size: 20px;
        font-weight: bold;
        color: var(--accent-light);
      }

      .controls-row {
        display: flex;
        gap: 10px;
        margin-top: 20px;
        justify-content: center;
      }

      .simulation-controls {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        justify-content: center;
      }

      .speed-control {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 15px;
      }

      .speed-control input {
        width: 100%;
      }

      .console-input {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      .console-input input {
        flex: 1;
        padding: 12px 15px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 5px;
        color: var(--text);
        font-family: "Roboto Mono", monospace;
      }

      .console-input input:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Algorithm Properties */
      .properties-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .property-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        text-align: center;
      }

      .property-card h4 {
        color: var(--text-secondary);
        font-size: 14px;
        margin-bottom: 8px;
        font-weight: 400;
      }

      .property-card .value {
        font-size: 20px;
        font-weight: 700;
        color: var(--accent-light);
        font-family: "Roboto Mono", monospace;
      }

      .property-card .value.warning {
        color: var(--warning);
      }

      .property-card .value.danger {
        color: var(--danger);
      }

      /* Footer */
      footer {
        text-align: center;
        padding: 40px 0 30px;
        color: var(--text-secondary);
        font-size: 14px;
        border-top: 1px solid rgba(148, 163, 184, 0.1);
        margin-top: 40px;
      }

      footer p {
        margin: 10px 0;
      }

      .footer-links {
        display: flex;
        justify-content: center;
        gap: 25px;
        margin-top: 15px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .footer-links a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .footer-links a:hover {
        color: var(--accent);
      }

      /* Animations */
      @keyframes float {
        0% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
        100% {
          transform: translateY(0px);
        }
      }

      .floating {
        animation: float 6s ease-in-out infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.05);
          opacity: 0.8;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .pulse {
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes highlight {
        0% {
          background: var(--accent-light);
        }
        50% {
          background: var(--warning);
          box-shadow: 0 0 15px var(--warning);
        }
        100% {
          background: var(--accent-light);
        }
      }

      .highlight-anim {
        animation: highlight 0.5s ease-in-out;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        header {
          flex-direction: column;
          gap: 25px;
          text-align: center;
        }

        .algorithm-header h1 {
          font-size: 32px;
        }

        .key-points {
          grid-template-columns: 1fr;
        }

        .cluster-container {
          gap: 20px;
        }

        .node {
          width: 80px;
          height: 100px;
        }

        .node-circle {
          width: 60px;
          height: 60px;
          font-size: 12px;
        }
      }

      @media (max-width: 480px) {
        .cluster-container {
          gap: 10px;
        }

        .node {
          width: 70px;
          height: 90px;
        }

        .node-circle {
          width: 50px;
          height: 50px;
        }
      }

      /* Code Block Styling */
      .code-block {
        background: #0d1117;
        border-radius: 8px;
        padding: 20px;
        margin: 25px 0;
        overflow-x: auto;
        font-family: "Roboto Mono", monospace;
        font-size: 15px;
        border: 1px solid rgba(99, 102, 241, 0.3);
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        color: var(--text-secondary);
      }

      .copy-btn {
        background: rgba(99, 102, 241, 0.2);
        color: var(--accent-light);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-block pre {
        margin: 0;
      }

      .code-block code {
        color: #c9d1d9;
        line-height: 1.5;
      }

      .keyword {
        color: #ff7b72;
      }
      .function {
        color: #d2a8ff;
      }
      .comment {
        color: #8b949e;
      }
      .string {
        color: #a5d6ff;
      }
      .number {
        color: #79c0ff;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <header>
        <div class="logo">
          <div class="logo-icon floating">
            <i class="fas fa-network-wired"></i>
          </div>
          <div class="logo-text">
            <h1>AlgoViz Hub</h1>
            <p>ALGORITHM VISUALIZATION REPOSITORY</p>
            <div class="breadcrumb">
              <a href="#"><i class="fas fa-home"></i> Home</a> >
              <a href="#">Distributed Algorithms</a> >
              <span>Raft Consensus</span>
            </div>
          </div>
        </div>
      </header>

      <!-- Algorithm Header -->
      <div class="algorithm-header">
        <h1>Raft Consensus</h1>
        <div class="category">
          <i class="fas fa-server"></i> Distributed Consensus Algorithm
        </div>
        <div class="complexity-badge">
          Fault-tolerant • Leader-based • Log Replication
        </div>
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <!-- Left Column: Algorithm Details -->
        <div class="left-column">
          <!-- Description Section -->
          <div class="section">
            <h2><i class="fas fa-file-alt"></i> Algorithm Overview</h2>
            <p>
              Raft is a consensus algorithm designed to manage a replicated log
              across multiple servers in a distributed system. It ensures that
              all machines agree on the same sequence of state machine commands,
              even in the presence of failures.
            </p>
            <p>
              Raft separates consensus into three key subproblems:
              <strong>Leader election</strong> (choosing a leader for each
              term), <strong>Log replication</strong> (propagating commands to
              followers), and <strong>Safety</strong> (ensuring consistency
              across the cluster).
            </p>

            <div class="key-points">
              <div class="point-card">
                <h3><i class="fas fa-crown"></i> Leader Election</h3>
                <p>
                  Nodes elect a leader who manages log replication. If no leader
                  exists, an election starts.
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-copy"></i> Log Replication</h3>
                <p>
                  Leader appends commands to its log, then replicates to
                  followers.
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-shield-alt"></i> Safety</h3>
                <p>
                  Ensures logs are consistent across nodes and only committed
                  entries are applied.
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-heartbeat"></i> Heartbeats</h3>
                <p>
                  Leader sends periodic heartbeats to maintain authority and
                  prevent new elections.
                </p>
              </div>
            </div>
          </div>

          <!-- Visualization Console -->
          <div class="section">
            <h2>
              <i class="fas fa-laptop-code"></i> Interactive Visualization
            </h2>
            <p>
              Use the interactive console below to visualize how Raft consensus
              works in a distributed system. The simulation shows a cluster of 5
              nodes with their current state (leader, follower, candidate). You
              can add commands, trigger failures, and observe how the cluster
              maintains consistency.
            </p>

            <div class="visualization-console">
              <div class="console-header">
                <h3>
                  <i class="fas fa-network-wired"></i> Raft Cluster
                  Visualization
                </h3>
                <div class="console-controls">
                  <button class="console-btn" id="reset-btn">
                    <i class="fas fa-redo"></i> Reset
                  </button>
                  <button class="console-btn" id="run-btn">
                    <i class="fas fa-play"></i> Run
                  </button>
                </div>
              </div>

              <div class="visualization-area" id="visualization-area">
                <div class="status-message" id="status-message">
                  Cluster starting up...
                </div>
                <div class="cluster-container" id="cluster-container">
                  <!-- Nodes will be dynamically added here -->
                </div>
              </div>

              <div class="controls-row">
                <button class="console-btn secondary" id="add-cmd-btn">
                  <i class="fas fa-plus"></i> Add Command
                </button>
                <button class="console-btn secondary" id="fail-node-btn">
                  <i class="fas fa-skull"></i> Fail Random Node
                </button>
                <button class="console-btn secondary" id="recover-node-btn">
                  <i class="fas fa-heartbeat"></i> Recover All Nodes
                </button>
              </div>

              <div class="simulation-controls">
                <span>Slow</span>
                <input
                  type="range"
                  id="speed-slider"
                  min="50"
                  max="500"
                  value="200"
                />
                <span>Fast</span>
              </div>
            </div>
          </div>

          <!-- Algorithm Steps -->
          <div class="section">
            <h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
            <p>
              Raft operates through a series of well-defined phases to maintain
              consensus:
            </p>

            <div class="key-points">
              <div class="point-card">
                <h3><i class="fas fa-vote-yea"></i> 1. Leader Election</h3>
                <p>
                  When a follower doesn't receive heartbeats, it becomes a
                  candidate and starts an election. If it receives votes from a
                  majority, it becomes leader.
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-heartbeat"></i> 2. Heartbeats</h3>
                <p>
                  The leader sends periodic AppendEntries RPCs (heartbeats) to
                  maintain authority and prevent new elections.
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-exchange-alt"></i> 3. Log Replication</h3>
                <p>
                  Leader receives client commands, appends to its log, and sends
                  to followers. When replicated to majority, entry is committed.
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-sync-alt"></i> 4. Commit Propagation</h3>
                <p>
                  Leader informs followers of committed entries in subsequent
                  AppendEntries RPCs. Followers apply committed entries to their
                  state machines.
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-user-shield"></i> 5. Safety Mechanisms</h3>
                <p>
                  Election safety: Only one leader per term. Leader append-only:
                  Leaders never overwrite or delete entries. Log matching: If
                  two logs contain an entry with same index/term, all preceding
                  entries are identical.
                </p>
              </div>
            </div>
          </div>

          <!-- Pseudocode Section -->
          <div class="section">
            <h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
            <div class="code-block">
              <pre><code>// Leader election
while true:
    if follower and electionTimeout elapses:
        become candidate
        currentTerm += 1
        voteFor = self
        requestVotes from others
        if votesReceived > n/2:
            become leader
            send heartbeats
            
    if candidate and receives votes from majority:
        become leader
        send heartbeats
        
    if candidate and electionTimeout elapses:
        start new election

// Log replication
on client command:
    if leader:
        append command to log
        send AppendEntries to followers
        when replicated to majority:
            commit entry
            apply to state machine
            notify followers of commit
            
// Safety
AppendEntries RPC:
    if term < currentTerm: return false
    if log doesn't contain entry at prevLogIndex with prevLogTerm: return false
    append new entries (delete conflicting entries if any)
    if leaderCommit > commitIndex:
        commitIndex = min(leaderCommit, lastLogIndex)</code></pre>
            </div>
          </div>
        </div>

        <!-- Right Column: Additional Info -->
        <div class="right-column">
          <!-- Properties Section -->
          <div class="section">
            <h2><i class="fas fa-info-circle"></i> Algorithm Properties</h2>
            <div class="properties-grid">
              <div class="property-card">
                <h4>Category</h4>
                <div class="value">Consensus</div>
              </div>
              <div class="property-card">
                <h4>Type</h4>
                <div class="value">Leader-based</div>
              </div>
              <div class="property-card">
                <h4>Fault Tolerance</h4>
                <div class="value">(N/2)-1 failures</div>
              </div>
              <div class="property-card">
                <h4>Complexity</h4>
                <div class="value">O(n) per operation</div>
              </div>
              <div class="property-card">
                <h4>Leader Election</h4>
                <div class="value">Randomized timeouts</div>
              </div>
              <div class="property-card">
                <h4>Log Replication</h4>
                <div class="value">Majority commit</div>
              </div>
              <div class="property-card">
                <h4>Safety</h4>
                <div class="value">Strong consistency</div>
              </div>
              <div class="property-card">
                <h4>Guarantees</h4>
                <div class="value">Linearizability</div>
              </div>
            </div>
          </div>

          <!-- Applications Section -->
          <div class="section">
            <h2><i class="fas fa-lightbulb"></i> Applications</h2>
            <p>
              Raft is widely used in distributed systems that require strong
              consistency:
            </p>
            <ul
              style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              "
            >
              <li style="margin-bottom: 10px">
                <strong>Distributed Databases:</strong> etcd, CockroachDB, TiDB
              </li>
              <li style="margin-bottom: 10px">
                <strong>Service Discovery:</strong> Consul
              </li>
              <li style="margin-bottom: 10px">
                <strong>Configuration Management:</strong> Kubernetes
                configuration stores
              </li>
              <li style="margin-bottom: 10px">
                <strong>Blockchain Systems:</strong> Private blockchain
                consensus
              </li>
              <li>
                <strong>Distributed File Systems:</strong> Replicated metadata
                management
              </li>
            </ul>
          </div>

          <!-- Key Concepts Section -->
          <div class="section">
            <h2><i class="fas fa-key"></i> Key Concepts</h2>
            <p>Understanding these terms is crucial for working with Raft:</p>
            <ul
              style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              "
            >
              <li style="margin-bottom: 10px">
                <strong>Term:</strong> Logical clock that increases with each
                election
              </li>
              <li style="margin-bottom: 10px">
                <strong>Log Entry:</strong> Command with term number when
                created
              </li>
              <li style="margin-bottom: 10px">
                <strong>Commit Index:</strong> Highest log entry known to be
                replicated
              </li>
              <li style="margin-bottom: 10px">
                <strong>AppendEntries RPC:</strong> How leaders replicate log
                entries
              </li>
              <li><strong>Quorum:</strong> Majority of servers (N/2 + 1)</li>
            </ul>
          </div>

          <!-- Comparison Section -->
          <div class="section">
            <h2><i class="fas fa-balance-scale"></i> Raft vs Paxos</h2>
            <p>How Raft compares to the Paxos consensus algorithm:</p>
            <ul
              style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              "
            >
              <li style="margin-bottom: 10px">
                <strong>Understandability:</strong> Raft was designed to be
                easier to understand than Paxos
              </li>
              <li style="margin-bottom: 10px">
                <strong>Leader Role:</strong> Raft has a strong leader while
                Paxos has multiple proposers
              </li>
              <li>
                <strong>Membership Changes:</strong> Raft has a defined approach
                for cluster configuration changes
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Footer -->
      <footer>
        <div class="footer-links">
          <a href="https://www.linkedin.com/in/sgkandale/" target="_blank"
            ><i class="fa-brands fa-linkedin"></i> LinkedIN</a
          >
          <a href="mailto:me@sgkandale.com"
            ><i class="fa-solid fa-at"></i> E-Mail</a
          >
          <a href="https://buymeacoffee.com/sgkandale" target="_blank"
            ><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a
          >
        </div>
        <p>AlgoViz Hub - Interactive Algorithm Visualization Platform</p>
        <p>&copy; 2025 AlgoViz Hub. All rights reserved.</p>
      </footer>
    </div>

    <script>
      // DOM Elements
      const runBtn = document.getElementById("run-btn");
      const resetBtn = document.getElementById("reset-btn");
      const addCmdBtn = document.getElementById("add-cmd-btn");
      const failNodeBtn = document.getElementById("fail-node-btn");
      const recoverNodeBtn = document.getElementById("recover-node-btn");
      const clusterContainer = document.getElementById("cluster-container");
      const statusMessage = document.getElementById("status-message");
      const speedSlider = document.getElementById("speed-slider");

      // Simulation state
      const nodes = [];
      let currentTerm = 1;
      let leaderId = null;
      let simulationInterval = null;
      let speed = 2000; // Default speed in ms
      let commands = ["SET X=5", "SET Y=10", "INC X", "DEC Y", "SET Z=20"];
      let commandIndex = 0;

      // Initialize cluster
      function initCluster() {
        clusterContainer.innerHTML = "";
        nodes.length = 0;
        currentTerm = 1;
        leaderId = null;

        // Create 5 nodes
        for (let i = 1; i <= 5; i++) {
          const node = {
            id: i,
            state: "follower",
            currentTerm: currentTerm,
            votedFor: null,
            log: [],
            commitIndex: 0,
            lastApplied: 0,
            nextIndex: 1,
            matchIndex: 0,
            online: true,
          };
          nodes.push(node);
          createNodeElement(node);
        }

        // Start leader election after a delay
        setTimeout(startElection, 1500);
        statusMessage.textContent =
          "Cluster initialized. Starting leader election...";
      }

      // Create visual node element
      function createNodeElement(node) {
        const nodeEl = document.createElement("div");
        nodeEl.className = `node ${node.state} ${node.online ? "" : "offline"}`;
        nodeEl.id = `node-${node.id}`;
        nodeEl.innerHTML = `
                <div class="node-term">Term: ${node.currentTerm}</div>
                <div class="node-circle">${node.state.toUpperCase()}</div>
                <div class="node-label">Node ${node.id}</div>
                <div class="log-container" id="log-${node.id}"></div>
            `;
        clusterContainer.appendChild(nodeEl);
        updateNodeLog(node);
      }

      // Update node log visualization
      function updateNodeLog(node) {
        const logContainer = document.getElementById(`log-${node.id}`);
        if (!logContainer) return;

        logContainer.innerHTML = "";
        for (let i = 0; i < node.log.length; i++) {
          const logEntry = document.createElement("div");
          logEntry.className = `log-entry ${
            i < node.commitIndex ? "committed" : ""
          }`;
          logEntry.title = `Term: ${node.log[i].term}, Command: ${node.log[i].command}`;
          logContainer.appendChild(logEntry);
        }
      }

      // Start leader election
      function startElection() {
        // Choose a random candidate
        const candidateIndex = Math.floor(Math.random() * nodes.length);
        const candidate = nodes[candidateIndex];

        if (!candidate.online) return;

        // Update status
        statusMessage.textContent = `Node ${
          candidate.id
        } started election for term ${currentTerm + 1}`;
        statusMessage.className = "status-message";

        // Candidate becomes candidate
        candidate.state = "candidate";
        candidate.currentTerm = currentTerm + 1;
        candidate.votedFor = candidate.id;
        updateNodeElement(candidate);

        // Request votes
        let votes = 1; // Vote for self
        nodes.forEach((node) => {
          if (node.id !== candidate.id && node.online) {
            // Simulate vote granting
            if (Math.random() > 0.3) {
              // 70% chance to grant vote
              votes++;
            }
          }
        });

        // Check if won election
        setTimeout(() => {
          if (votes > nodes.length / 2) {
            // Become leader
            currentTerm = candidate.currentTerm;
            leaderId = candidate.id;
            candidate.state = "leader";
            statusMessage.textContent = `Node ${candidate.id} elected leader for term ${currentTerm}!`;
            statusMessage.className = "status-message";

            // Update all nodes
            nodes.forEach((node) => {
              node.currentTerm = currentTerm;
              updateNodeElement(node);
            });

            // Start sending heartbeats
            startHeartbeats();
          } else {
            // Election failed
            candidate.state = "follower";
            updateNodeElement(candidate);
            statusMessage.textContent = `Election failed for term ${candidate.currentTerm}. Starting new election...`;
            setTimeout(startElection, speed);
          }
        }, 1000);
      }

      // Start sending heartbeats as leader
      function startHeartbeats() {
        if (simulationInterval) clearInterval(simulationInterval);

        simulationInterval = setInterval(() => {
          if (!leaderId) return;

          const leader = nodes.find((n) => n.id === leaderId);
          if (!leader || !leader.online) {
            // Leader failed
            clearInterval(simulationInterval);
            leaderId = null;
            statusMessage.textContent =
              "Leader failed! Starting new election...";
            setTimeout(startElection, 1000);
            return;
          }

          // Send heartbeats to all followers
          nodes.forEach((node) => {
            if (node.id !== leader.id && node.online) {
              // Simulate log replication
              if (leader.log.length > node.log.length) {
                // Append new entries
                const entries = leader.log.slice(node.log.length);
                entries.forEach((entry) => {
                  node.log.push(entry);
                });
                updateNodeLog(node);
              }

              // Update commit index
              if (node.commitIndex < leader.commitIndex) {
                node.commitIndex = leader.commitIndex;
                updateNodeLog(node);
              }
            }
          });

          // Randomly add a log entry
          if (Math.random() > 0.7 && commands[commandIndex]) {
            addLogEntry(commands[commandIndex]);
            commandIndex = (commandIndex + 1) % commands.length;
          }
        }, speed / 2);
      }

      // Add a log entry to the leader
      function addLogEntry(command) {
        if (!leaderId) return;

        const leader = nodes.find((n) => n.id === leaderId);
        if (!leader || !leader.online) return;

        leader.log.push({
          term: leader.currentTerm,
          command: command,
          committed: false,
        });

        statusMessage.textContent = `Leader added command: ${command}`;
        updateNodeLog(leader);

        // Commit when replicated to majority
        setTimeout(() => {
          let replicatedCount = 1; // Leader has it
          nodes.forEach((node) => {
            if (
              node.id !== leader.id &&
              node.log.length === leader.log.length
            ) {
              replicatedCount++;
            }
          });

          if (replicatedCount > nodes.length / 2) {
            leader.commitIndex = leader.log.length;
            nodes.forEach((node) => {
              if (node.log.length >= leader.commitIndex) {
                node.commitIndex = leader.commitIndex;
              }
              updateNodeLog(node);
            });
            statusMessage.textContent = `Command committed: ${command}`;
          }
        }, 1000);
      }

      // Update node visual representation
      function updateNodeElement(node) {
        const nodeEl = document.getElementById(`node-${node.id}`);
        if (!nodeEl) return;

        nodeEl.className = `node ${node.state} ${node.online ? "" : "offline"}`;
        const termEl = nodeEl.querySelector(".node-term");
        const circleEl = nodeEl.querySelector(".node-circle");

        if (termEl) termEl.textContent = `Term: ${node.currentTerm}`;
        if (circleEl) circleEl.textContent = node.state.toUpperCase();

        updateNodeLog(node);
      }

      // Fail a random node
      function failRandomNode() {
        const onlineNodes = nodes.filter((node) => node.online);
        if (onlineNodes.length < 2) {
          statusMessage.textContent = "Not enough online nodes to fail!";
          return;
        }

        const randomIndex = Math.floor(Math.random() * onlineNodes.length);
        const node = onlineNodes[randomIndex];
        node.online = false;

        statusMessage.textContent = `Node ${node.id} failed!`;
        updateNodeElement(node);

        // If leader failed, start election
        if (node.id === leaderId) {
          leaderId = null;
          clearInterval(simulationInterval);
          statusMessage.textContent = `Leader (Node ${node.id}) failed! Starting new election...`;
          setTimeout(startElection, 1500);
        }
      }

      // Recover all nodes
      function recoverAllNodes() {
        nodes.forEach((node) => {
          node.online = true;
          updateNodeElement(node);
        });

        statusMessage.textContent = "All nodes recovered!";

        // If no leader, start election
        if (!leaderId) {
          setTimeout(startElection, 1000);
        }
      }

      // Initialize simulation
      function initSimulation() {
        initCluster();
      }

      // Event listeners
      runBtn.addEventListener("click", () => {
        if (simulationInterval) {
          clearInterval(simulationInterval);
          simulationInterval = null;
          runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
        } else {
          if (leaderId) {
            startHeartbeats();
          } else {
            startElection();
          }
          runBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
        }
      });

      resetBtn.addEventListener("click", () => {
        clearInterval(simulationInterval);
        simulationInterval = null;
        initSimulation();
        runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
      });

      addCmdBtn.addEventListener("click", () => {
        if (commands[commandIndex]) {
          addLogEntry(commands[commandIndex]);
          commandIndex = (commandIndex + 1) % commands.length;
        }
      });

      failNodeBtn.addEventListener("click", failRandomNode);
      recoverNodeBtn.addEventListener("click", recoverAllNodes);

      speedSlider.addEventListener("input", () => {
        speed = 2050 - parseInt(speedSlider.value) * 4;
        if (simulationInterval) {
          clearInterval(simulationInterval);
          startHeartbeats();
        }
      });

      // Initialize on load
      window.addEventListener("load", initSimulation);
    </script>
  </body>
</html>
