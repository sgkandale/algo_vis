<!DOCTYPE html>

<html lang="en">
<head><meta content="Learn about garbage collection algorithms used in programming language runtimes" name="description"/><meta content="garbage collection, gc algorithm, mark and sweep, generational gc, reference counting" name="keywords"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Conservative Garbage Collector | AlgoViz Hub</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap" rel="stylesheet"/>
<style>
            :root {
                --primary: #0f172a;
                --secondary: #1e293b;
                --accent: #6366f1;
                --accent-light: #818cf8;
                --accent-glow: rgba(99, 102, 241, 0.2);
                --text: #e2e8f0;
                --text-secondary: #94a3b8;
                --card-bg: rgba(30, 41, 59, 0.7);
                --success: #10b981;
                --warning: #f59e0b;
                --danger: #ef4444;
                --transition: all 0.3s ease;
                --radius: 12px;
                --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                --glow: 0 0 15px var(--accent-glow);
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background: linear-gradient(
                    135deg,
                    var(--primary),
                    var(--secondary)
                );
                color: var(--text);
                font-family: "Roboto", sans-serif;
                line-height: 1.6;
                min-height: 100vh;
                padding: 0;
                position: relative;
                overflow-x: hidden;
            }

            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background:
                    radial-gradient(
                        circle at 10% 20%,
                        rgba(99, 102, 241, 0.1) 0%,
                        transparent 20%
                    ),
                    radial-gradient(
                        circle at 90% 80%,
                        rgba(129, 140, 248, 0.1) 0%,
                        transparent 20%
                    );
                z-index: -1;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }

            /* Header Styles */
            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px 0;
                position: relative;
                border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            }

            .logo {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .logo-icon {
                width: 50px;
                height: 50px;
                background: var(--accent);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: var(--glow);
            }

            .logo-icon i {
                font-size: 24px;
                color: white;
            }

            .logo-text h1 {
                font-family: "Roboto Mono", monospace;
                font-weight: 700;
                font-size: 28px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }

            .logo-text p {
                font-size: 14px;
                color: var(--text-secondary);
                letter-spacing: 1.5px;
            }

            .breadcrumb {
                font-size: 14px;
                color: var(--text-secondary);
                margin-top: 10px;
            }

            .breadcrumb a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .breadcrumb a:hover {
                text-decoration: underline;
            }

            /* Algorithm Header */
            .algorithm-header {
                margin: 40px 0;
                text-align: center;
                padding: 20px;
                background: var(--card-bg);
                border-radius: var(--radius);
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .algorithm-header::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .algorithm-header h1 {
                font-size: 42px;
                margin-bottom: 15px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                font-weight: 800;
            }

            .algorithm-header .category {
                font-size: 18px;
                color: var(--accent-light);
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

            .complexity-badge {
                display: inline-block;
                background: rgba(129, 140, 248, 0.2);
                color: var(--accent-light);
                padding: 6px 15px;
                border-radius: 20px;
                font-size: 16px;
                font-weight: 600;
                font-family: "Roboto Mono", monospace;
                margin-top: 15px;
            }

            /* Main Content Layout */
            .main-content {
                display: grid;
                grid-template-columns: 1fr 350px;
                gap: 30px;
                margin-bottom: 40px;
            }

            @media (max-width: 900px) {
                .main-content {
                    grid-template-columns: 1fr;
                }
            }

            /* Algorithm Detail Sections */
            .section {
                background: var(--card-bg);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                padding: 30px;
                margin-bottom: 30px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .section::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .section h2 {
                font-size: 26px;
                margin-bottom: 20px;
                color: var(--accent-light);
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .section h2 i {
                color: var(--accent);
                width: 36px;
                height: 36px;
                background: rgba(99, 102, 241, 0.2);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .section p {
                color: var(--text-secondary);
                font-size: 17px;
                line-height: 1.8;
                margin-bottom: 20px;
            }

            .key-points {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 20px;
                margin: 25px 0;
            }

            .point-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
            }

            .point-card h3 {
                color: var(--accent-light);
                margin-bottom: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .point-card h3 i {
                color: var(--accent);
            }

            .point-card p {
                margin-bottom: 0;
                font-size: 15px;
            }

            /* Visualization Console */
            .visualization-console {
                background: rgba(15, 23, 42, 0.8);
                border-radius: var(--radius);
                padding: 25px;
                margin: 30px 0;
                border: 1px solid rgba(99, 102, 241, 0.3);
                box-shadow: var(--glow);
            }

            .console-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }

            .console-header h3 {
                color: var(--accent-light);
                font-size: 20px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .console-controls {
                display: flex;
                gap: 10px;
            }

            .console-btn {
                background: var(--accent);
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .console-btn:hover {
                background: var(--accent-light);
            }

            .console-btn.secondary {
                background: rgba(148, 163, 184, 0.2);
            }

            .visualization-area {
                height: 400px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                position: relative;
                overflow: hidden;
            }

            .console-input {
                display: flex;
                gap: 10px;
                margin-top: 20px;
            }

            .console-input input {
                flex: 1;
                padding: 12px 15px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(148, 163, 184, 0.2);
                border-radius: 5px;
                color: var(--text);
                font-family: "Roboto Mono", monospace;
            }

            .console-input input:focus {
                outline: none;
                border-color: var(--accent);
            }

            /* Algorithm Properties */
            .properties-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }

            .property-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                text-align: center;
            }

            .property-card h4 {
                color: var(--text-secondary);
                font-size: 14px;
                margin-bottom: 8px;
                font-weight: 400;
            }

            .property-card .value {
                font-size: 20px;
                font-weight: 700;
                color: var(--accent-light);
                font-family: "Roboto Mono", monospace;
            }

            /* Footer */
            footer {
                text-align: center;
                padding: 40px 0 30px;
                color: var(--text-secondary);
                font-size: 14px;
                border-top: 1px solid rgba(148, 163, 184, 0.1);
                margin-top: 40px;
            }

            footer p {
                margin: 10px 0;
            }

            .footer-links {
                display: flex;
                justify-content: center;
                gap: 25px;
                margin-top: 15px;
                flex-wrap: wrap;
                margin-bottom: 20px;
            }

            .footer-links a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .footer-links a:hover {
                color: var(--accent);
            }

            /* Animations */
            @keyframes float {
                0% {
                    transform: translateY(0px);
                }
                50% {
                    transform: translateY(-10px);
                }
                100% {
                    transform: translateY(0px);
                }
            }

            .floating {
                animation: float 6s ease-in-out infinite;
            }

            /* Responsive Design */
            @media (max-width: 768px) {
                header {
                    flex-direction: column;
                    gap: 25px;
                    text-align: center;
                }

                .algorithm-header h1 {
                    font-size: 32px;
                }

                .key-points {
                    grid-template-columns: 1fr;
                }
            }

            /* Code Block Styling */
            .code-block {
                background: #0d1117;
                border-radius: 8px;
                padding: 20px;
                margin: 25px 0;
                overflow-x: auto;
                font-family: "Roboto Mono", monospace;
                font-size: 15px;
                border: 1px solid rgba(99, 102, 241, 0.3);
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                color: var(--text-secondary);
            }

            .copy-btn {
                background: rgba(99, 102, 241, 0.2);
                color: var(--accent-light);
                border: none;
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .copy-btn:hover {
                background: rgba(99, 102, 241, 0.3);
            }

            .code-block pre {
                margin: 0;
            }

            .code-block code {
                color: #c9d1d9;
                line-height: 1.5;
            }

            .keyword {
                color: #ff7b72;
            }
            .function {
                color: #d2a8ff;
            }
            .comment {
                color: #8b949e;
            }
            .string {
                color: #a5d6ff;
            }
            .number {
                color: #79c0ff;
            }

            /* Conservative GC Visualization Styles */
            .memory-layout {
                display: flex;
                flex-direction: column;
                height: 100%;
                padding: 15px;
            }

            .stack-section,
            .heap-section {
                border: 2px solid var(--accent);
                border-radius: 8px;
                margin: 10px 0;
                padding: 10px;
            }

            .section-title {
                text-align: center;
                margin-bottom: 10px;
                font-weight: bold;
                color: var(--accent-light);
            }

            .stack-content,
            .heap-content {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }

            .stack-item,
            .heap-block {
                padding: 8px;
                border-radius: 4px;
                font-size: 12px;
                font-family: "Roboto Mono", monospace;
                min-width: 60px;
                text-align: center;
                transition: all 0.5s ease;
            }

            .stack-item {
                background-color: rgba(99, 102, 241, 0.3);
                border: 1px solid var(--accent);
            }

            .heap-block {
                background-color: rgba(148, 163, 184, 0.3);
                border: 1px solid var(--text-secondary);
            }

            .heap-block.allocated {
                background-color: rgba(99, 102, 241, 0.3);
                border: 1px solid var(--accent);
            }

            .heap-block.marked {
                background-color: rgba(16, 185, 129, 0.3);
                border: 1px solid var(--success);
            }

            .heap-block.swept {
                background-color: rgba(239, 68, 68, 0.3);
                border: 1px solid var(--danger);
                opacity: 0.7;
            }

            .stack-item.pointer {
                background-color: rgba(245, 158, 11, 0.3);
                border: 1px solid var(--warning);
            }

            .stack-item.ambiguous {
                background-color: rgba(245, 158, 11, 0.6);
                border: 2px dashed var(--warning);
            }

            .info-panel {
                position: absolute;
                bottom: 10px;
                left: 10px;
                right: 10px;
                background: rgba(0, 0, 0, 0.5);
                padding: 8px;
                border-radius: 4px;
                font-size: 12px;
                text-align: center;
            }

            .phase-indicator {
                display: flex;
                justify-content: center;
                margin-bottom: 15px;
                gap: 20px;
            }

            .phase {
                padding: 5px 15px;
                border-radius: 20px;
                background-color: rgba(148, 163, 184, 0.2);
                font-size: 14px;
            }

            .phase.active {
                background-color: var(--accent);
                color: white;
            }

            .sliding-window {
                position: absolute;
                border: 2px dashed var(--warning);
                background-color: rgba(245, 158, 11, 0.1);
                pointer-events: none;
            }
        </style>
<meta content="Conservative Garbage Collector | AlgoViz Hub" property="og:title"/><meta content="Learn about garbage collection algorithms used in programming language runtimes" property="og:description"/><meta content="article" property="og:type"/><meta content="https://sgkandale.github.io/garbage_collection_cgc.html" property="og:url"/><meta content="AlgoViz Hub" property="og:site_name"/><meta content="summary" name="twitter:card"/><meta content="Conservative Garbage Collector | AlgoViz Hub" name="twitter:title"/><meta content="Learn about garbage collection algorithms used in programming language runtimes" name="twitter:description"/><meta content="@sgkandale" name="twitter:site"/><link href="https://sgkandale.github.io/garbage_collection_cgc.html" rel="canonical"/><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Conservative Garbage Collector | AlgoViz Hub",
  "description": "Learn about garbage collection algorithms used in programming language runtimes",
  "author": {
    "@type": "Person",
    "name": "Shantanu Kandale"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AlgoViz Hub",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sgkandale.github.io/favicon.ico"
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sgkandale.github.io/garbage_collection_cgc.html"
  }
}</script></head>
<body>
<div class="container">
<!-- Header -->
<header>
<div class="logo">
<div class="logo-icon floating">
<i class="fas fa-project-diagram"></i>
</div>
<div class="logo-text">
<h1>AlgoViz Hub</h1>
<p>ALGORITHM VISUALIZATION REPOSITORY</p>
<div class="breadcrumb">
<a href="#"><i class="fas fa-home"></i> Home</a> &gt;
                            <a href="#">Memory Management</a> &gt;
                            <span>Conservative Garbage Collector</span>
</div>
</div>
</div>
</header>
<!-- Algorithm Header -->
<div class="algorithm-header">
<h1>Conservative Garbage Collector</h1>
<div class="category">
<i class="fas fa-memory"></i> Memory Management Algorithm
                </div>
<div class="complexity-badge">
                    Time Complexity: O(Heap Size + Root Set)
                </div>
</div>
<!-- Main Content -->
<div class="main-content">
<!-- Left Column: Algorithm Details -->
<div class="left-column">
<!-- Description Section -->
<div class="section">
<h2>
<i class="fas fa-file-alt"></i> Algorithm Overview
                        </h2>
<p>
                            The Conservative Garbage Collector is a memory
                            management algorithm designed for environments where
                            precise type information is not available (like C
                            and C++). It works by conservatively treating any
                            word-sized data that could be a pointer as if it
                            were an actual pointer to a live object.
                        </p>
<p>
                            This approach is called "conservative" because it
                            may retain some objects that are not actually
                            reachable (false positives), but it will never free
                            objects that are still in use. The
                            Boehm-Demers-Weiser garbage collector is the most
                            well-known implementation of this approach and is
                            widely used in languages and systems that weren't
                            originally designed with garbage collection in mind.
                        </p>
<div class="key-points">
<div class="point-card">
<h3>
<i class="fas fa-check-circle"></i> Key
                                    Feature
                                </h3>
<p>
                                    Works without precise type information by
                                    treating any word that looks like a pointer
                                    as a pointer
                                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-bolt"></i> Performance</h3>
<p>
                                    Time proportional to heap size plus root set
                                    size, with occasional false positives
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-memory"></i> Compatibility
                                </h3>
<p>
                                    Can be added to existing systems without
                                    language support for precise GC
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-project-diagram"></i>
                                    Safety
                                </h3>
<p>
                                    Never deallocates live objects (safe but may
                                    be less efficient due to false positives)
                                </p>
</div>
</div>
</div>
<!-- Visualization Console -->
<div class="section">
<h2>
<i class="fas fa-laptop-code"></i> Interactive
                            Visualization
                        </h2>
<p>
                            Use the interactive console below to visualize how
                            the Conservative Garbage Collector works. The
                            visualization shows both stack and heap memory,
                            demonstrating how the collector identifies potential
                            pointers and marks reachable objects.
                        </p>
<div class="visualization-console">
<div class="console-header">
<h3>
<i class="fas fa-play-circle"></i>
                                    Conservative GC Visualization
                                </h3>
<div class="console-controls">
<button class="console-btn" id="step-btn">
<i class="fas fa-step-forward"></i> Step
                                    </button>
<button class="console-btn" id="run-btn">
<i class="fas fa-play"></i> Run
                                    </button>
<button class="console-btn secondary" id="reset-btn">
<i class="fas fa-redo"></i> Reset
                                    </button>
</div>
</div>
<div class="visualization-area" id="gc-visualization">
<!-- GC Visualization will be rendered here -->
<div class="phase-indicator">
<div class="phase" id="phase-root">
                                        Root Scan
                                    </div>
<div class="phase" id="phase-mark">
                                        Mark
                                    </div>
<div class="phase" id="phase-sweep">
                                        Sweep
                                    </div>
</div>
<div class="memory-layout">
<div class="stack-section">
<div class="section-title">
                                            Stack Memory
                                        </div>
<div class="stack-content" id="stack-content"></div>
</div>
<div class="heap-section">
<div class="section-title">
                                            Heap Memory
                                        </div>
<div class="heap-content" id="heap-content"></div>
</div>
</div>
<div class="info-panel" id="info-panel">
                                    Ready to start garbage collection
                                </div>
<div class="sliding-window" id="sliding-window" style="display: none"></div>
</div>
<div class="console-input">
<input id="object-input" placeholder="Enter object structure (e.g., A:100, B:200, C:300)" type="text" value="A:100, B:200, C:300, D:400, E:500"/>
<button class="console-btn" id="random-btn">
<i class="fas fa-random"></i> Random
                                </button>
</div>
</div>
</div>
<!-- Algorithm Steps -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
<p>
                            The Conservative Garbage Collector operates in the
                            following steps:
                        </p>
<div class="key-points">
<div class="point-card">
<h3>
<i class="fas fa-search"></i> 1. Root
                                    Identification
                                </h3>
<p>
                                    The collector scans the stack, registers,
                                    and global variables for potential pointers.
                                    Any word that could be interpreted as a
                                    pointer (falls within heap address range) is
                                    treated as a root.
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-pen"></i> 2. Mark Phase
                                </h3>
<p>
                                    Starting from the identified roots, the
                                    collector marks all reachable objects. Since
                                    pointer identification is conservative, some
                                    non-pointers may be treated as pointers
                                    (false positives).
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-broom"></i> 3. Sweep Phase
                                </h3>
<p>
                                    The collector scans through the entire heap,
                                    reclaiming memory from objects that were not
                                    marked as reachable during the mark phase.
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-compress-arrows-alt"></i>
                                    4. Compaction (Optional)
                                </h3>
<p>
                                    Some conservative collectors include a
                                    sliding compaction phase to reduce
                                    fragmentation, carefully updating potential
                                    pointers to moved objects.
                                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-redo"></i> 5. Repeat</h3>
<p>
                                    The process repeats when memory allocation
                                    requests cannot be satisfied, or based on
                                    heuristics like memory pressure.
                                </p>
</div>
</div>
</div>
<!-- Pseudocode Section -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
<div class="code-block">
<pre><code>// Conservative Mark-and-Sweep Garbage Collection
function collectGarbage():
    // Stop-the-world pause (in most implementations)
    pauseProgramExecution()

    // Conservative root scanning
    roots = findConservativeRoots()

    // Mark phase
    markPhase(roots)

    // Sweep phase
    sweepPhase()

    // Optional: sliding compaction
    if shouldCompact():
        compactHeap()

    resumeProgramExecution()

function findConservativeRoots():
    roots = []
    // Scan stack frames
    for each word in stack frames:
        if looksLikePointer(word):
            roots.append(word)

    // Scan registers
    for each word in registers:
        if looksLikePointer(word):
            roots.append(word)

    // Scan global variables
    for each word in global data:
        if looksLikePointer(word):
            roots.append(word)

    return roots

function looksLikePointer(word):
    // Check if word is aligned properly
    if word % alignment != 0:
        return false

    // Check if word falls within heap address range
    if word &lt; heapStart or word &gt;= heapEnd:
        return false

    // Check if word points to a valid object header
    if !isValidObjectHeader(word):
        return false

    return true

function markPhase(roots):
    // Standard mark phase using conservative roots
    for each root in roots:
        mark(root)

    while markedObjectsNotProcessed():
        current = nextMarkedObject()
        for each word in current:
            if looksLikePointer(word):
                mark(word)

function sweepPhase():
    // Standard sweep phase
    for each object in heap:
        if object.marked:
            object.marked = false
        else:
            free(object)

function compactHeap():
    // Sliding compaction: move objects to eliminate fragmentation
    free = heapStart
    for each object in heap:
        if object.marked:
            moveObject(object, free)
            free += object.size
            // Update any potential pointers to the object
            updateReferencesTo(object)</code></pre>
</div>
</div>
<!-- Implementation Section -->
<div class="section">
<h2><i class="fas fa-code"></i> Implementation</h2>
<p>
                            Below is a simplified Python implementation
                            demonstrating the concepts of a conservative garbage
                            collector. Note that a real implementation would be
                            in C/C++ and involve low-level memory operations.
                        </p>
<div class="code-block">
<div class="code-header">
<span>Python Implementation (Conceptual)</span>
<button class="copy-btn">
<i class="fas fa-copy"></i> Copy Code
                                </button>
</div>
<pre><code><span class="keyword">class</span> <span class="function">ConservativeGC</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, heap_size):
        self.heap = [None] * heap_size
        self.heap_start = 0
        self.heap_end = heap_size - 1
        self.allocated_objects = {}
        self.marked = set()

    <span class="keyword">def</span> <span class="function">allocate</span>(self, size):
        <span class="comment"># Simple allocation strategy: first fit</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.heap_start, self.heap_end - size + 1):
            <span class="keyword">if</span> self.heap[i] <span class="keyword">is</span> None:
                <span class="comment"># Check if we have enough contiguous space</span>
                free = True
                <span class="keyword">for</span> j <span class="keyword">in</span> range(i, i + size):
                    <span class="keyword">if</span> self.heap[j] <span class="keyword">is not</span> None:
                        free = False
                        <span class="keyword">break</span>

                <span class="keyword">if</span> free:
                    <span class="comment"># Create object</span>
                    obj_id = f"obj_{i}"
                    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, i + size):
                        self.heap[j] = obj_id
                    self.allocated_objects[obj_id] = {
                        'address': i,
                        'size': size,
                        'data': [None] * size
                    }
                    <span class="keyword">return</span> i

        <span class="comment"># If we get here, we need to garbage collect</span>
        self.collect()

        <span class="comment"># Try allocation again after GC</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.heap_start, self.heap_end - size + 1):
            <span class="keyword">if</span> self.heap[i] <span class="keyword">is</span> None:
                <span class="comment"># Similar allocation logic as above</span>
                <span class="keyword">pass</span>

        <span class="keyword">raise</span> MemoryError(<span class="string">"Out of memory"</span>)

    <span class="keyword">def</span> <span class="function">collect</span>(self):
        <span class="comment"># Mark phase</span>
        self.marked.clear()
        roots = self.find_conservative_roots()
        <span class="keyword">for</span> root <span class="keyword">in</span> roots:
            self.mark(root)

        <span class="comment"># Sweep phase</span>
        self.sweep()

    <span class="keyword">def</span> <span class="function">find_conservative_roots</span>(self):
        <span class="comment"># In a real implementation, this would scan the stack and registers</span>
        <span class="comment"># For simulation, we'll return some known roots</span>
        roots = []

        <span class="comment"># Simulate scanning the stack for values that look like pointers</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.heap_start, self.heap_end + 1):
            <span class="comment"># Check if value looks like a pointer</span>
            <span class="keyword">if</span> self.looks_like_pointer(i):
                roots.append(i)

        <span class="keyword">return</span> roots

    <span class="keyword">def</span> <span class="function">looks_like_pointer</span>(self, value):
        <span class="comment"># Check if value is within heap bounds</span>
        <span class="keyword">if</span> value &lt; self.heap_start <span class="keyword">or</span> value &gt; self.heap_end:
            <span class="keyword">return</span> False

        <span class="comment"># Check if value points to an allocated object</span>
        <span class="keyword">if</span> self.heap[value] <span class="keyword">is</span> None:
            <span class="keyword">return</span> False

        <span class="comment"># Additional checks would be done in a real implementation</span>
        <span class="keyword">return</span> True

    <span class="keyword">def</span> <span class="function">mark</span>(self, address):
        <span class="comment"># Get object ID at this address</span>
        obj_id = self.heap[address]
        <span class="keyword">if</span> obj_id <span class="keyword">is</span> None <span class="keyword">or</span> obj_id <span class="keyword">in</span> self.marked:
            <span class="keyword">return</span>

        self.marked.add(obj_id)

        <span class="comment"># Recursively mark references within the object</span>
        obj = self.allocated_objects[obj_id]
        <span class="keyword">for</span> value <span class="keyword">in</span> obj['data']:
            <span class="keyword">if</span> isinstance(value, int) <span class="keyword">and</span> self.looks_like_pointer(value):
                self.mark(value)

    <span class="keyword">def</span> <span class="function">sweep</span>(self):
        <span class="comment"># Free unmarked objects</span>
        <span class="keyword">for</span> obj_id, obj <span class="keyword">in</span> list(self.allocated_objects.items()):
            <span class="keyword">if</span> obj_id <span class="keyword">not</span> <span class="keyword">in</span> self.marked:
                <span class="comment"># Free the object</span>
                <span class="keyword">for</span> i <span class="keyword">in</span> range(obj['address'], obj['address'] + obj['size']):
                    self.heap[i] = None
                <span class="keyword">del</span> self.allocated_objects[obj_id]</code></pre>
</div>
</div>
</div>
<!-- Right Column: Additional Info -->
<div class="right-column">
<!-- Properties Section -->
<div class="section">
<h2>
<i class="fas fa-info-circle"></i> Algorithm
                            Properties
                        </h2>
<div class="properties-grid">
<div class="property-card">
<h4>Category</h4>
<div class="value">Conservative</div>
</div>
<div class="property-card">
<h4>Type</h4>
<div class="value">Tracing</div>
</div>
<div class="property-card">
<h4>Precision</h4>
<div class="value">Imprecise</div>
</div>
<div class="property-card">
<h4>Compaction</h4>
<div class="value">Optional</div>
</div>
<div class="property-card">
<h4>Fragmentation</h4>
<div class="value">Possible</div>
</div>
<div class="property-card">
<h4>Time Complexity</h4>
<div class="value">O(H + R)</div>
</div>
<div class="property-card">
<h4>Compatibility</h4>
<div class="value">High</div>
</div>
<div class="property-card">
<h4>Safety</h4>
<div class="value">No false negatives</div>
</div>
</div>
</div>
<!-- Applications Section -->
<div class="section">
<h2><i class="fas fa-lightbulb"></i> Applications</h2>
<p>
                            Conservative Garbage Collection is widely used in
                            various systems and languages:
                        </p>
<ul style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            ">
<li style="margin-bottom: 10px">
<strong>Boehm-Demers-Weiser GC:</strong> The
                                most famous conservative collector, used in many
                                C/C++ projects
                            </li>
<li style="margin-bottom: 10px">
<strong>Ruby:</strong> Used conservative GC in
                                earlier versions
                            </li>
<li style="margin-bottom: 10px">
<strong>Embedded systems:</strong> Where precise
                                type information may not be available
                            </li>
<li style="margin-bottom: 10px">
<strong>Legacy systems:</strong> Adding garbage
                                collection to systems not designed for it
                            </li>
<li>
<strong>Scripting languages:</strong> Some
                                implementations use conservative GC for
                                simplicity
                            </li>
</ul>
</div>
<!-- Advantages & Disadvantages -->
<div class="section">
<h2>
<i class="fas fa-balance-scale"></i> Pros &amp; Cons
                        </h2>
<div class="key-points">
<div class="point-card">
<h3>
<i class="fas fa-plus-circle"></i>
                                    Advantages
                                </h3>
<p>
                                    Works with unmodified code, no need for
                                    language support, safe (no false negatives),
                                    can be added to existing systems, handles
                                    ambiguous roots well
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-minus-circle"></i>
                                    Disadvantages
                                </h3>
<p>
                                    May retain some garbage (false positives),
                                    can be less efficient than precise
                                    collectors, potential issues with pointer
                                    misidentification, more difficult to
                                    implement compaction
                                </p>
</div>
</div>
</div>
<!-- Variants Section -->
<div class="section">
<h2>
<i class="fas fa-code-branch"></i> Algorithm
                            Variants
                        </h2>
<p>
                            Several approaches exist within conservative garbage
                            collection:
                        </p>
<ul style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            ">
<li style="margin-bottom: 10px">
<strong>Boehm-Demers-Weiser GC:</strong> The
                                classic conservative collector with mark-sweep
                                algorithm
                            </li>
<li style="margin-bottom: 10px">
<strong>Mostly-copying collectors:</strong> Use
                                copying for most objects but conservative
                                handling for ambiguous roots
                            </li>
<li style="margin-bottom: 10px">
<strong>Hybrid collectors:</strong> Combine
                                conservative and precise approaches for
                                different parts of the system
                            </li>
<li>
<strong>Incremental conservative GC:</strong>
                                Perform garbage collection incrementally to
                                reduce pause times
                            </li>
</ul>
</div>
</div>
</div>
<!-- Footer -->
<footer>
<div class="footer-links">
<a href="https://www.linkedin.com/in/sgkandale/" target="_blank"><i class="fa-brands fa-linkedin"></i> LinkedIN</a>
<a href="mailto:me@sgkandale.com"><i class="fa-solid fa-at"></i> E-Mail</a>
<a href="https://buymeacoffee.com/sgkandale" target="_blank"><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a>
</div>
<p>
                    AlgoViz Hub - Interactive Algorithm Visualization Platform
                </p>
<p>Â© 2025 AlgoViz Hub. All rights reserved.</p>
</footer>
</div>
<script>
            // Conservative Garbage Collector Visualization
            class ConservativeGCVisualization {
                constructor() {
                    this.stackContent =
                        document.getElementById("stack-content");
                    this.heapContent = document.getElementById("heap-content");
                    this.infoPanel = document.getElementById("info-panel");
                    this.phaseRoot = document.getElementById("phase-root");
                    this.phaseMark = document.getElementById("phase-mark");
                    this.phaseSweep = document.getElementById("phase-sweep");
                    this.slidingWindow =
                        document.getElementById("sliding-window");
                    this.stepBtn = document.getElementById("step-btn");
                    this.runBtn = document.getElementById("run-btn");
                    this.resetBtn = document.getElementById("reset-btn");
                    this.objectInput = document.getElementById("object-input");
                    this.randomBtn = document.getElementById("random-btn");

                    this.heapStart = 100;
                    this.heapEnd = 500;
                    this.objects = [];
                    this.stackValues = [];
                    this.markedObjects = new Set();
                    this.step = 0;
                    this.intervalId = null;

                    this.init();
                    this.setupEventListeners();
                }

                init() {
                    this.parseObjectInput();
                    this.generateStackValues();
                    this.render();
                }

                parseObjectInput() {
                    const input = this.objectInput.value;
                    this.objects = [];
                    this.markedObjects.clear();
                    this.step = 0;

                    // Parse object definitions (format: ID:address)
                    const definitions = input.split(",").map((d) => d.trim());

                    definitions.forEach((def) => {
                        if (def.includes(":")) {
                            const [id, address] = def
                                .split(":")
                                .map((s) => s.trim());
                            this.objects.push({
                                id: id,
                                address: parseInt(address),
                                size: 20 + Math.floor(Math.random() * 30), // Random size
                                marked: false,
                                swept: false,
                            });
                        }
                    });

                    // Reset phase indicators
                    this.phaseRoot.classList.remove("active");
                    this.phaseMark.classList.remove("active");
                    this.phaseSweep.classList.remove("active");
                    this.slidingWindow.style.display = "none";
                }

                generateStackValues() {
                    this.stackValues = [];

                    // Add some real pointers
                    this.objects.forEach((obj) => {
                        this.stackValues.push({
                            value: obj.address,
                            isPointer: true,
                            ambiguous: false,
                        });
                    });

                    // Add some non-pointers that look like pointers (within heap range)
                    for (let i = 0; i < 3; i++) {
                        const value =
                            this.heapStart +
                            Math.floor(
                                Math.random() * (this.heapEnd - this.heapStart),
                            );
                        this.stackValues.push({
                            value: value,
                            isPointer: false,
                            ambiguous: true,
                        });
                    }

                    // Add some obvious non-pointers
                    for (let i = 0; i < 4; i++) {
                        this.stackValues.push({
                            value: Math.floor(Math.random() * this.heapStart),
                            isPointer: false,
                            ambiguous: false,
                        });
                    }

                    // Shuffle the stack values
                    this.stackValues.sort(() => Math.random() - 0.5);
                }

                render() {
                    // Clear previous visualization
                    this.stackContent.innerHTML = "";
                    this.heapContent.innerHTML = "";

                    // Render stack values
                    this.stackValues.forEach((item) => {
                        const stackItem = document.createElement("div");
                        stackItem.className = "stack-item";

                        if (item.isPointer) {
                            stackItem.classList.add("pointer");
                        } else if (item.ambiguous) {
                            stackItem.classList.add("ambiguous");
                        }

                        stackItem.textContent = `0x${item.value.toString(16)}`;
                        stackItem.dataset.value = item.value;
                        this.stackContent.appendChild(stackItem);
                    });

                    // Render heap blocks
                    for (
                        let addr = this.heapStart;
                        addr <= this.heapEnd;
                        addr += 20
                    ) {
                        const block = document.createElement("div");
                        block.className = "heap-block";

                        // Check if this address is part of an object
                        const obj = this.objects.find(
                            (o) =>
                                addr >= o.address && addr < o.address + o.size,
                        );

                        if (obj) {
                            block.classList.add("allocated");
                            if (obj.marked) block.classList.add("marked");
                            if (obj.swept) block.classList.add("swept");

                            if (addr === obj.address) {
                                block.textContent = `${obj.id}`;
                            } else {
                                block.textContent = `...`;
                            }
                        } else {
                            block.textContent = `0x${addr.toString(16)}`;
                        }

                        block.dataset.address = addr;
                        this.heapContent.appendChild(block);
                    }

                    // Update info panel
                    this.updateInfoPanel();
                }

                updateInfoPanel() {
                    const steps = [
                        "Ready to start garbage collection",
                        "Scanning stack for potential pointers",
                        "Identifying ambiguous values (look like pointers but may not be)",
                        "Marking objects referenced by potential pointers",
                        "Sweeping unmarked objects",
                        "Garbage collection completed",
                    ];

                    this.infoPanel.textContent = steps[this.step];
                }

                nextStep() {
                    if (this.step >= 5) {
                        this.stopAutoRun();
                        return;
                    }

                    this.step++;

                    switch (this.step) {
                        case 1:
                            // Start root scanning phase
                            this.phaseRoot.classList.add("active");
                            break;
                        case 2:
                            // Show ambiguous values
                            this.showAmbiguousValues();
                            break;
                        case 3:
                            // Mark objects referenced by potential pointers
                            this.phaseRoot.classList.remove("active");
                            this.phaseMark.classList.add("active");
                            this.markObjects();
                            break;
                        case 4:
                            // Sweep unmarked objects
                            this.phaseMark.classList.remove("active");
                            this.phaseSweep.classList.add("active");
                            this.sweepObjects();
                            break;
                        case 5:
                            // Complete
                            break;
                    }

                    this.render();
                }

                showAmbiguousValues() {
                    // Highlight ambiguous values in the stack
                    this.stackValues.forEach((item) => {
                        if (item.ambiguous) {
                            // In a real implementation, we would show the sliding window
                            this.showSlidingWindow(item.value);
                        }
                    });
                }

                showSlidingWindow(address) {
                    // Show a sliding window around the ambiguous value
                    this.slidingWindow.style.display = "block";
                    this.slidingWindow.style.left = `${((address - this.heapStart) / (this.heapEnd - this.heapStart)) * 80 + 10}%`;
                    this.slidingWindow.style.width = "5%";
                    this.slidingWindow.style.top = "45%";
                    this.slidingWindow.style.height = "30%";
                }

                markObjects() {
                    // Mark all objects that might be pointed to by stack values
                    this.stackValues.forEach((item) => {
                        if (item.isPointer || item.ambiguous) {
                            const obj = this.objects.find(
                                (o) => o.address === item.value,
                            );
                            if (obj) {
                                obj.marked = true;
                                this.markedObjects.add(obj.id);
                            }
                        }
                    });
                }

                sweepObjects() {
                    // Mark unmarked objects as swept
                    this.objects.forEach((obj) => {
                        if (!obj.marked) {
                            obj.swept = true;
                        }
                    });
                }

                reset() {
                    this.stopAutoRun();
                    this.parseObjectInput();
                    this.generateStackValues();
                    this.render();
                }

                startAutoRun() {
                    this.stopAutoRun();
                    this.intervalId = setInterval(() => {
                        this.nextStep();
                        if (this.step >= 5) {
                            this.stopAutoRun();
                        }
                    }, 1500);
                }

                stopAutoRun() {
                    if (this.intervalId) {
                        clearInterval(this.intervalId);
                        this.intervalId = null;
                    }
                }

                generateRandomObjects() {
                    let definitions = [];
                    const objects = ["A", "B", "C", "D", "E", "F", "G", "H"];

                    // Generate random object definitions
                    for (let i = 0; i < 5; i++) {
                        const address =
                            this.heapStart +
                            Math.floor(
                                Math.random() *
                                    (this.heapEnd - this.heapStart - 50),
                            );
                        definitions.push(`${objects[i]}:${address}`);
                    }

                    this.objectInput.value = definitions.join(", ");
                    this.reset();
                }

                setupEventListeners() {
                    this.stepBtn.addEventListener("click", () => {
                        this.nextStep();
                    });

                    this.runBtn.addEventListener("click", () => {
                        if (this.step >= 5) {
                            this.reset();
                        }
                        this.startAutoRun();
                    });

                    this.resetBtn.addEventListener("click", () => {
                        this.reset();
                    });

                    this.randomBtn.addEventListener("click", () => {
                        this.generateRandomObjects();
                    });

                    this.objectInput.addEventListener("change", () => {
                        this.reset();
                    });
                }
            }

            // Initialize the visualization when the page loads
            document.addEventListener("DOMContentLoaded", () => {
                const gcViz = new ConservativeGCVisualization();

                // Copy button functionality
                document
                    .querySelector(".copy-btn")
                    .addEventListener("click", function () {
                        const code =
                            document.querySelector(
                                ".code-block code",
                            ).innerText;
                        navigator.clipboard.writeText(code);

                        // Show feedback
                        const originalText = this.innerHTML;
                        this.innerHTML = '<i class="fas fa-check"></i> Copied!';

                        setTimeout(() => {
                            this.innerHTML = originalText;
                        }, 2000);
                    });
            });
        </script>
</body>
</html>
