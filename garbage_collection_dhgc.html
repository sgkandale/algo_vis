<!DOCTYPE html>

<html lang="en">
<head><meta content="Learn about garbage collection algorithms used in programming language runtimes" name="description"/><meta content="garbage collection, gc algorithm, mark and sweep, generational gc, reference counting" name="keywords"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Dual-Heap Garbage Collector | AlgoViz Hub</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap" rel="stylesheet"/>
<style>
      :root {
        --primary: #0f172a;
        --secondary: #1e293b;
        --accent: #6366f1;
        --accent-light: #818cf8;
        --accent-glow: rgba(99, 102, 241, 0.2);
        --text: #e2e8f0;
        --text-secondary: #94a3b8;
        --card-bg: rgba(30, 41, 59, 0.7);
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --transition: all 0.3s ease;
        --radius: 12px;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        --glow: 0 0 15px var(--accent-glow);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: var(--text);
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        min-height: 100vh;
        padding: 0;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 10% 20%,
            rgba(99, 102, 241, 0.1) 0%,
            transparent 20%
          ),
          radial-gradient(
            circle at 90% 80%,
            rgba(129, 140, 248, 0.1) 0%,
            transparent 20%
          );
        z-index: -1;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      /* Header Styles */
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 0;
        position: relative;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .logo-icon {
        width: 50px;
        height: 50px;
        background: var(--accent);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--glow);
      }

      .logo-icon i {
        font-size: 24px;
        color: white;
      }

      .logo-text h1 {
        font-family: "Roboto Mono", monospace;
        font-weight: 700;
        font-size: 28px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .logo-text p {
        font-size: 14px;
        color: var(--text-secondary);
        letter-spacing: 1.5px;
      }

      .breadcrumb {
        font-size: 14px;
        color: var(--text-secondary);
        margin-top: 10px;
      }

      .breadcrumb a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .breadcrumb a:hover {
        text-decoration: underline;
      }

      /* Algorithm Header */
      .algorithm-header {
        margin: 40px 0;
        text-align: center;
        padding: 20px;
        background: var(--card-bg);
        border-radius: var(--radius);
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .algorithm-header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .algorithm-header h1 {
        font-size: 42px;
        margin-bottom: 15px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 800;
      }

      .algorithm-header .category {
        font-size: 18px;
        color: var(--accent-light);
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .complexity-badge {
        display: inline-block;
        background: rgba(129, 140, 248, 0.2);
        color: var(--accent-light);
        padding: 6px 15px;
        border-radius: 20px;
        font-size: 16px;
        font-weight: 600;
        font-family: "Roboto Mono", monospace;
        margin-top: 15px;
      }

      /* Main Content Layout */
      .main-content {
        display: grid;
        grid-template-columns: 1fr 350px;
        gap: 30px;
        margin-bottom: 40px;
      }

      @media (max-width: 900px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }

      /* Algorithm Detail Sections */
      .section {
        background: var(--card-bg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 30px;
        margin-bottom: 30px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .section::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .section h2 {
        font-size: 26px;
        margin-bottom: 20px;
        color: var(--accent-light);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .section h2 i {
        color: var(--accent);
        width: 36px;
        height: 36px;
        background: rgba(99, 102, 241, 0.2);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .section p {
        color: var(--text-secondary);
        font-size: 17px;
        line-height: 1.8;
        margin-bottom: 20px;
      }

      .key-points {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin: 25px 0;
      }

      .point-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
      }

      .point-card h3 {
        color: var(--accent-light);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .point-card h3 i {
        color: var(--accent);
      }

      .point-card p {
        margin-bottom: 0;
        font-size: 15px;
      }

      /* Visualization Console */
      .visualization-console {
        background: rgba(15, 23, 42, 0.8);
        border-radius: var(--radius);
        padding: 25px;
        margin: 30px 0;
        border: 1px solid rgba(99, 102, 241, 0.3);
        box-shadow: var(--glow);
      }

      .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .console-header h3 {
        color: var(--accent-light);
        font-size: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .console-controls {
        display: flex;
        gap: 10px;
      }

      .console-btn {
        background: var(--accent);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .console-btn:hover {
        background: var(--accent-light);
      }

      .console-btn.secondary {
        background: rgba(148, 163, 184, 0.2);
      }

      .visualization-area {
        height: 400px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        position: relative;
        overflow: hidden;
      }

      .console-input {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      .console-input input {
        flex: 1;
        padding: 12px 15px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 5px;
        color: var(--text);
        font-family: "Roboto Mono", monospace;
      }

      .console-input input:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Algorithm Properties */
      .properties-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .property-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        text-align: center;
      }

      .property-card h4 {
        color: var(--text-secondary);
        font-size: 14px;
        margin-bottom: 8px;
        font-weight: 400;
      }

      .property-card .value {
        font-size: 20px;
        font-weight: 700;
        color: var(--accent-light);
        font-family: "Roboto Mono", monospace;
      }

      /* Footer */
      footer {
        text-align: center;
        padding: 40px 0 30px;
        color: var(--text-secondary);
        font-size: 14px;
        border-top: 1px solid rgba(148, 163, 184, 0.1);
        margin-top: 40px;
      }

      footer p {
        margin: 10px 0;
      }

      .footer-links {
        display: flex;
        justify-content: center;
        gap: 25px;
        margin-top: 15px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .footer-links a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .footer-links a:hover {
        color: var(--accent);
      }

      /* Animations */
      @keyframes float {
        0% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
        100% {
          transform: translateY(0px);
        }
      }

      .floating {
        animation: float 6s ease-in-out infinite;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        header {
          flex-direction: column;
          gap: 25px;
          text-align: center;
        }

        .algorithm-header h1 {
          font-size: 32px;
        }

        .key-points {
          grid-template-columns: 1fr;
        }
      }

      /* Code Block Styling */
      .code-block {
        background: #0d1117;
        border-radius: 8px;
        padding: 20px;
        margin: 25px 0;
        overflow-x: auto;
        font-family: "Roboto Mono", monospace;
        font-size: 15px;
        border: 1px solid rgba(99, 102, 241, 0.3);
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        color: var(--text-secondary);
      }

      .copy-btn {
        background: rgba(99, 102, 241, 0.2);
        color: var(--accent-light);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-block pre {
        margin: 0;
      }

      .code-block code {
        color: #c9d1d9;
        line-height: 1.5;
      }

      .keyword {
        color: #ff7b72;
      }
      .function {
        color: #d2a8ff;
      }
      .comment {
        color: #8b949e;
      }
      .string {
        color: #a5d6ff;
      }
      .number {
        color: #79c0ff;
      }

      /* Dual-Heap GC Visualization Styles */
      .dual-heap-container {
        display: flex;
        height: 100%;
        padding: 15px;
        gap: 20px;
      }

      .heap {
        flex: 1;
        border: 2px solid var(--accent);
        border-radius: 8px;
        padding: 10px;
        display: flex;
        flex-direction: column;
      }

      .heap-title {
        text-align: center;
        margin-bottom: 10px;
        font-weight: bold;
        color: var(--accent-light);
      }

      .memory-blocks {
        display: flex;
        flex-direction: column;
        flex: 1;
        gap: 5px;
      }

      .memory-block {
        padding: 8px;
        border-radius: 4px;
        font-size: 12px;
        font-family: 'Roboto Mono', monospace;
        transition: all 0.5s ease;
      }

      .young-heap .memory-block.free {
        background-color: rgba(148, 163, 184, 0.2);
        border: 1px solid var(--text-secondary);
      }

      .young-heap .memory-block.allocated {
        background-color: rgba(99, 102, 241, 0.3);
        border: 1px solid var(--accent);
      }

      .young-heap .memory-block.marked {
        background-color: rgba(16, 185, 129, 0.3);
        border: 1px solid var(--success);
      }

      .young-heap .memory-block.promoted {
        background-color: rgba(245, 158, 11, 0.3);
        border: 1px solid var(--warning);
      }

      .old-heap .memory-block.free {
        background-color: rgba(148, 163, 184, 0.2);
        border: 1px solid var(--text-secondary);
      }

      .old-heap .memory-block.allocated {
        background-color: rgba(245, 158, 11, 0.3);
        border: 1px solid var(--warning);
      }

      .old-heap .memory-block.marked {
        background-color: rgba(16, 185, 129, 0.3);
        border: 1px solid var(--success);
      }

      .info-panel {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.5);
        padding: 8px;
        border-radius: 4px;
        font-size: 12px;
        text-align: center;
      }

      .phase-indicator {
        display: flex;
        justify-content: center;
        margin-bottom: 15px;
        gap: 20px;
      }

      .phase {
        padding: 5px 15px;
        border-radius: 20px;
        background-color: rgba(148, 163, 184, 0.2);
        font-size: 14px;
      }

      .phase.active {
        background-color: var(--accent);
        color: white;
      }

      .age-counter {
        position: absolute;
        top: 5px;
        right: 5px;
        font-size: 10px;
        color: var(--text-secondary);
      }

      .promotion-arrow {
        position: absolute;
        color: var(--warning);
        font-size: 20px;
        z-index: 10;
        animation: moveArrow 2s ease-in-out;
      }

      @keyframes moveArrow {
        0% { opacity: 0; transform: translateY(0); }
        50% { opacity: 1; }
        100% { opacity: 0; transform: translateY(100px); }
      }
    </style>
<meta content="Dual-Heap Garbage Collector | AlgoViz Hub" property="og:title"/><meta content="Learn about garbage collection algorithms used in programming language runtimes" property="og:description"/><meta content="article" property="og:type"/><meta content="https://sgkandale.github.io/garbage_collection_dhgc.html" property="og:url"/><meta content="AlgoViz Hub" property="og:site_name"/><meta content="summary" name="twitter:card"/><meta content="Dual-Heap Garbage Collector | AlgoViz Hub" name="twitter:title"/><meta content="Learn about garbage collection algorithms used in programming language runtimes" name="twitter:description"/><meta content="@sgkandale" name="twitter:site"/><link href="https://sgkandale.github.io/garbage_collection_dhgc.html" rel="canonical"/><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Dual-Heap Garbage Collector | AlgoViz Hub",
  "description": "Learn about garbage collection algorithms used in programming language runtimes",
  "author": {
    "@type": "Person",
    "name": "Shantanu Kandale"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AlgoViz Hub",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sgkandale.github.io/favicon.ico"
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sgkandale.github.io/garbage_collection_dhgc.html"
  }
}</script></head>
<body>
<div class="container">
<!-- Header -->
<header>
<div class="logo">
<div class="logo-icon floating">
<i class="fas fa-project-diagram"></i>
</div>
<div class="logo-text">
<h1>AlgoViz Hub</h1>
<p>ALGORITHM VISUALIZATION REPOSITORY</p>
<div class="breadcrumb">
<a href="#"><i class="fas fa-home"></i> Home</a> &gt;
              <a href="#">Memory Management</a> &gt;
              <span>Dual-Heap Garbage Collector</span>
</div>
</div>
</div>
</header>
<!-- Algorithm Header -->
<div class="algorithm-header">
<h1>Dual-Heap Garbage Collector</h1>
<div class="category">
<i class="fas fa-memory"></i> Generational Memory Management Algorithm
        </div>
<div class="complexity-badge">Time Complexity: O(Live Data)</div>
</div>
<!-- Main Content -->
<div class="main-content">
<!-- Left Column: Algorithm Details -->
<div class="left-column">
<!-- Description Section -->
<div class="section">
<h2><i class="fas fa-file-alt"></i> Algorithm Overview</h2>
<p>
              The Dual-Heap Garbage Collector is a generational memory management algorithm that divides
              the heap into two spaces: a young generation (nursery) and an old generation (tenured space).
              This approach is based on the weak generational hypothesis, which states that most objects
              die young, while a small percentage of objects survive for longer periods.
            </p>
<p>
              New objects are allocated in the young generation, which is collected frequently using a
              fast, copying garbage collector. Objects that survive multiple collections in the young
              generation are promoted to the old generation, which is collected less frequently using
              a more thorough but slower algorithm (typically mark-sweep or mark-compact).
            </p>
<div class="key-points">
<div class="point-card">
<h3><i class="fas fa-check-circle"></i> Key Feature</h3>
<p>
                  Uses two separate heaps with different collection strategies optimized for object lifetimes
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-bolt"></i> Performance</h3>
<p>
                  Fast collection of young generation with pause times proportional to live young objects
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-memory"></i> Efficiency</h3>
<p>
                  Reduces overall collection time by focusing on the area where most garbage is created
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-project-diagram"></i> Approach</h3>
<p>
                  Combines copying collection for young generation with mark-sweep/compact for old generation
                </p>
</div>
</div>
</div>
<!-- Visualization Console -->
<div class="section">
<h2>
<i class="fas fa-laptop-code"></i> Interactive Visualization
            </h2>
<p>
              Use the interactive console below to visualize how the Dual-Heap Garbage Collector works.
              The visualization shows both young and old generation heaps and demonstrates how objects
              are promoted from young to old generation after surviving multiple collections.
            </p>
<div class="visualization-console">
<div class="console-header">
<h3>
<i class="fas fa-play-circle"></i> Dual-Heap GC Visualization
                </h3>
<div class="console-controls">
<button class="console-btn" id="step-btn">
<i class="fas fa-step-forward"></i> Step
                  </button>
<button class="console-btn" id="run-btn">
<i class="fas fa-play"></i> Run
                  </button>
<button class="console-btn secondary" id="reset-btn">
<i class="fas fa-redo"></i> Reset
                  </button>
</div>
</div>
<div class="visualization-area" id="gc-visualization">
<!-- GC Visualization will be rendered here -->
<div class="phase-indicator">
<div class="phase" id="phase-young">Young GC</div>
<div class="phase" id="phase-promote">Promotion</div>
<div class="phase" id="phase-old">Old GC</div>
</div>
<div class="dual-heap-container">
<div class="heap young-heap">
<div class="heap-title">Young Generation</div>
<div class="memory-blocks" id="young-heap"></div>
</div>
<div class="heap old-heap">
<div class="heap-title">Old Generation</div>
<div class="memory-blocks" id="old-heap"></div>
</div>
</div>
<div class="info-panel" id="info-panel">Ready to start garbage collection</div>
</div>
<div class="console-input">
<input id="object-input" placeholder="Enter object structure (e.g., A:0, B:1, C:2)" type="text" value="A:0, B:1, C:2, D:0, E:1"/>
<button class="console-btn" id="random-btn">
<i class="fas fa-random"></i> Random
                </button>
</div>
</div>
</div>
<!-- Algorithm Steps -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
<p>
              The Dual-Heap Garbage Collector operates in the following steps:
            </p>
<div class="key-points">
<div class="point-card">
<h3><i class="fas fa-baby"></i> 1. Object Allocation</h3>
<p>
                  New objects are allocated in the young generation heap. Each object has an age counter
                  that tracks how many collections it has survived.
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-sync"></i> 2. Young Generation Collection</h3>
<p>
                  When the young generation fills up, a minor collection is triggered. This uses a
                  copying collector to quickly identify and retain live objects.
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-arrow-up"></i> 3. Object Promotion</h3>
<p>
                  Objects that survive a certain number of young generation collections (age threshold)
                  are promoted to the old generation.
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-database"></i> 4. Old Generation Collection</h3>
<p>
                  When the old generation fills up or based on heuristics, a major collection is triggered.
                  This uses a mark-sweep or mark-compact algorithm to reclaim memory.
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-redo"></i> 5. Cycle Repeat</h3>
<p>
                  The process repeats, with new allocations happening in the young generation and long-lived
                  objects accumulating in the old generation.
                </p>
</div>
</div>
</div>
<!-- Pseudocode Section -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
<div class="code-block">
<pre><code>// Dual-Heap Generational Garbage Collection
function collectGarbage():
    if youngGenerationIsFull():
        collectYoungGeneration()
    else if oldGenerationIsFull() or shouldCollectOldGen():
        collectOldGeneration()

function collectYoungGeneration():
    // Stop-the-world pause for young collection
    pauseProgramExecution()

    // Copy live objects to survivor space
    liveObjects = []
    for each object in youngGeneration:
        if isLive(object):
            object.age += 1
            if object.age &gt;= PROMOTION_AGE:
                promoteToOldGeneration(object)
            else:
                liveObjects.append(object)

    // Reclaim young generation
    youngGeneration = liveObjects
    resumeProgramExecution()

function collectOldGeneration():
    // Stop-the-world pause for old collection
    pauseProgramExecution()

    // Mark phase for old generation
    markPhaseOldGeneration()

    // Sweep phase for old generation
    sweepPhaseOldGeneration()

    // Optional: compact old generation
    if shouldCompact():
        compactOldGeneration()

    resumeProgramExecution()

function promoteToOldGeneration(object):
    // Move object from young to old generation
    removeFromYoungGeneration(object)
    addToOldGeneration(object)

    // Update remembered set for old generation
    addToRememberedSet(object)

function markPhaseOldGeneration():
    // Mark roots directly pointing to old generation
    for each root in roots:
        if root in oldGeneration:
            mark(root)

    // Mark from remembered set (young→old references)
    for each reference in rememberedSet:
        mark(reference)

    // Transitively mark all reachable objects
    while markedObjectsNotProcessed():
        current = nextMarkedObject()
        for each reference in current:
            if reference in oldGeneration:
                mark(reference)

function sweepPhaseOldGeneration():
    // Reclaim unmarked objects
    for each object in oldGeneration:
        if not object.marked:
            free(object)
        else:
            object.marked = false  // Reset for next GC</code></pre>
</div>
</div>
<!-- Implementation Section -->
<div class="section">
<h2><i class="fas fa-code"></i> Implementation</h2>
<p>
              Below is a simplified Python implementation of a Dual-Heap Garbage Collector.
              This implementation demonstrates the core concepts of generational collection
              with object promotion between generations.
            </p>
<div class="code-block">
<div class="code-header">
<span>Python Implementation</span>
<button class="copy-btn">
<i class="fas fa-copy"></i> Copy Code
                </button>
</div>
<pre><code><span class="keyword">class</span> <span class="function">DualHeapGC</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, young_size, old_size, promotion_age=2):
        self.young_gen = [None] * young_size
        self.old_gen = [None] * old_size
        self.young_free = 0
        self.old_free = 0
        self.promotion_age = promotion_age
        self.remembered_set = set()  <span class="comment"># Tracks young-&gt;old references</span>
        self.object_ages = {}  <span class="comment"># Tracks how many collections objects have survived</span>

    <span class="keyword">def</span> <span class="function">allocate</span>(self, obj_id, size):
        <span class="comment"># Try to allocate in young generation first</span>
        <span class="keyword">if</span> self.young_free + size &lt;= len(self.young_gen):
            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.young_free, self.young_free + size):
                self.young_gen[i] = obj_id
            self.young_free += size
            self.object_ages[obj_id] = 0  <span class="comment"># New object, age 0</span>
            <span class="keyword">return</span> True

        <span class="comment"># Young generation is full, trigger collection</span>
        self.collect_young()

        <span class="comment"># Try again after collection</span>
        <span class="keyword">if</span> self.young_free + size &lt;= len(self.young_gen):
            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.young_free, self.young_free + size):
                self.young_gen[i] = obj_id
            self.young_free += size
            self.object_ages[obj_id] = 0
            <span class="keyword">return</span> True

        <span class="comment"># If still no space, try old generation</span>
        <span class="keyword">if</span> self.old_free + size &lt;= len(self.old_gen):
            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.old_free, self.old_free + size):
                self.old_gen[i] = obj_id
            self.old_free += size
            self.object_ages[obj_id] = self.promotion_age  <span class="comment"># Directly in old gen</span>
            <span class="keyword">return</span> True

        <span class="comment"># If old generation is also full, trigger full collection</span>
        self.collect_old()

        <span class="comment"># Try allocation in old generation after collection</span>
        <span class="keyword">if</span> self.old_free + size &lt;= len(self.old_gen):
            <span class="keyword">for</span> i <span class="keyword">in</span> range(self.old_free, self.old_free + size):
                self.old_gen[i] = obj_id
            self.old_free += size
            self.object_ages[obj_id] = self.promotion_age
            <span class="keyword">return</span> True

        <span class="keyword">raise</span> MemoryError(<span class="string">"Out of memory"</span>)

    <span class="keyword">def</span> <span class="function">collect_young</span>(self):
        <span class="comment"># Copying collection for young generation</span>
        new_young = [None] * len(self.young_gen)
        new_free = 0
        promoted = 0

        <span class="comment"># Process young generation</span>
        i = 0
        <span class="keyword">while</span> i &lt; self.young_free:
            obj_id = self.young_gen[i]
            <span class="keyword">if</span> obj_id <span class="keyword">is</span> <span class="keyword">not</span> None:
                size = self.get_object_size(obj_id, self.young_gen, i)

                <span class="comment"># Check if object is live (simplified)</span>
                <span class="keyword">if</span> self.is_live(obj_id):
                    <span class="comment"># Increase age and check for promotion</span>
                    self.object_ages[obj_id] += 1

                    <span class="keyword">if</span> self.object_ages[obj_id] &gt;= self.promotion_age:
                        <span class="comment"># Promote to old generation</span>
                        self.promote_to_old(obj_id, i, size)
                        promoted += 1
                    <span class="keyword">else</span>:
                        <span class="comment"># Keep in young generation</span>
                        <span class="keyword">for</span> j <span class="keyword">in</span> range(size):
                            new_young[new_free + j] = obj_id
                        new_free += size

                i += size
            <span class="keyword">else</span>:
                i += 1

        <span class="comment"># Update young generation</span>
        self.young_gen = new_young
        self.young_free = new_free

        <span class="keyword">return</span> promoted

    <span class="keyword">def</span> <span class="function">promote_to_old</span>(self, obj_id, young_index, size):
        <span class="comment"># Move object from young to old generation</span>
        <span class="keyword">if</span> self.old_free + size &gt; len(self.old_gen):
            <span class="comment"># Need to collect old generation first</span>
            self.collect_old()

        <span class="keyword">if</span> self.old_free + size &lt;= len(self.old_gen):
            <span class="comment"># Copy object to old generation</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> range(size):
                self.old_gen[self.old_free + i] = obj_id
            self.old_free += size

            <span class="comment"># Clear from young generation</span>
            <span class="keyword">for</span> i <span class="keyword">in</span> range(young_index, young_index + size):
                self.young_gen[i] = None

    <span class="keyword">def</span> <span class="function">collect_old</span>(self):
        <span class="comment"># Mark-sweep collection for old generation</span>
        marked = set()

        <span class="comment"># Mark phase (simplified)</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.old_free):
            obj_id = self.old_gen[i]
            <span class="keyword">if</span> obj_id <span class="keyword">is</span> <span class="keyword">not</span> None <span class="keyword">and</span> self.is_live(obj_id):
                marked.add(obj_id)

        <span class="comment"># Sweep phase</span>
        new_old = [None] * len(self.old_gen)
        new_free = 0
        i = 0

        <span class="keyword">while</span> i &lt; self.old_free:
            obj_id = self.old_gen[i]
            <span class="keyword">if</span> obj_id <span class="keyword">is</span> <span class="keyword">not</span> None:
                size = self.get_object_size(obj_id, self.old_gen, i)

                <span class="keyword">if</span> obj_id <span class="keyword">in</span> marked:
                    <span class="comment"># Keep live object</span>
                    <span class="keyword">for</span> j <span class="keyword">in</span> range(size):
                        new_old[new_free + j] = obj_id
                    new_free += size

                i += size
            <span class="keyword">else</span>:
                i += 1

        <span class="comment"># Update old generation</span>
        self.old_gen = new_old
        self.old_free = new_free

    <span class="keyword">def</span> <span class="function">is_live</span>(self, obj_id):
        <span class="comment"># Simplified liveness check</span>
        <span class="keyword">return</span> obj_id <span class="keyword">in</span> self.object_ages  <span class="comment"># In real implementation, would check references</span>

    <span class="keyword">def</span> <span class="function">get_object_size</span>(self, obj_id, heap, start_index):
        <span class="comment"># Calculate object size by counting contiguous references</span>
        size = 0
        <span class="keyword">for</span> i <span class="keyword">in</span> range(startIndex, len(heap)):
            <span class="keyword">if</span> heap[i] == obj_id:
                size += 1
            <span class="keyword">else</span>:
                <span class="keyword">break</span>
        <span class="keyword">return</span> size</code></pre>
</div>
</div>
</div>
<!-- Right Column: Additional Info -->
<div class="right-column">
<!-- Properties Section -->
<div class="section">
<h2><i class="fas fa-info-circle"></i> Algorithm Properties</h2>
<div class="properties-grid">
<div class="property-card">
<h4>Category</h4>
<div class="value">Generational</div>
</div>
<div class="property-card">
<h4>Young GC</h4>
<div class="value">Copying</div>
</div>
<div class="property-card">
<h4>Old GC</h4>
<div class="value">Mark-Sweep</div>
</div>
<div class="property-card">
<h4>Compacting</h4>
<div class="value">Optional</div>
</div>
<div class="property-card">
<h4>Promotion</h4>
<div class="value">Age-based</div>
</div>
<div class="property-card">
<h4>Time Complexity</h4>
<div class="value">O(L<sub>y</sub> + L<sub>o</sub>)</div>
</div>
<div class="property-card">
<h4>Space Overhead</h4>
<div class="value">Remembered Sets</div>
</div>
<div class="property-card">
<h4>Throughput</h4>
<div class="value">High</div>
</div>
</div>
</div>
<!-- Applications Section -->
<div class="section">
<h2><i class="fas fa-lightbulb"></i> Applications</h2>
<p>
              Dual-Heap Garbage Collection is widely used in modern programming languages and systems:
            </p>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
<strong>Java Virtual Machine (JVM):</strong> Uses generational collection with young and old generations
              </li>
<li style="margin-bottom: 10px">
<strong>.NET CLR:</strong> Implements generational garbage collection with ephemeal (young) and full (old) generations
              </li>
<li style="margin-bottom: 10px">
<strong>JavaScript engines:</strong> V8 and others use generational collection for efficient memory management
              </li>
<li style="margin-bottom: 10px">
<strong>Python:</strong> Some implementations use generational GC (e.g., PyPy)
              </li>
<li>
<strong>High-performance systems:</strong> Where predictable pause times are important
              </li>
</ul>
</div>
<!-- Advantages & Disadvantages -->
<div class="section">
<h2><i class="fas fa-balance-scale"></i> Pros &amp; Cons</h2>
<div class="key-points">
<div class="point-card">
<h3><i class="fas fa-plus-circle"></i> Advantages</h3>
<p>
                  High throughput, short pause times for young collections, efficient for object-oriented workloads,
                  reduces overall collection time by focusing on young generation
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-minus-circle"></i> Disadvantages
<p>
                  Complexity of maintaining remembered sets, overhead of object promotion,
                  longer pause times for old generation collections, requires tuning of generation sizes
                </p>
</h3></div>
</div>
</div>
<!-- Variants Section -->
<div class="section">
<h2><i class="fas fa-code-branch"></i> Algorithm Variants</h2>
<p>
              Several approaches exist within generational garbage collection:
            </p>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
<strong>Ephemeral GC:</strong> .NET's implementation with gen0, gen1, and gen2
              </li>
<li style="margin-bottom: 10px">
<strong>Train GC:</strong> Uses multiple older generations for incremental collection of large heaps
              </li>
<li style="margin-bottom: 10px">
<strong>Concurrent generational GC:</strong> Performs old generation collection concurrently with program execution
              </li>
<li>
<strong>Incremental generational GC:</strong> Breaks down collection into smaller increments to reduce pause times
              </li>
</ul>
</div>
</div>
</div>
<!-- Footer -->
<footer>
<div class="footer-links">
<a href="https://www.linkedin.com/in/sgkandale/" target="_blank"><i class="fa-brands fa-linkedin"></i> LinkedIN</a>
<a href="mailto:me@sgkandale.com"><i class="fa-solid fa-at"></i> E-Mail</a>
<a href="https://buymeacoffee.com/sgkandale" target="_blank"><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a>
</div>
<p>AlgoViz Hub - Interactive Algorithm Visualization Platform</p>
<p>© 2025 AlgoViz Hub. All rights reserved.</p>
</footer>
</div>
<script>
      // Dual-Heap Garbage Collector Visualization
      class DualHeapGCVisualization {
        constructor() {
          this.youngHeap = document.getElementById('young-heap');
          this.oldHeap = document.getElementById('old-heap');
          this.infoPanel = document.getElementById('info-panel');
          this.phaseYoung = document.getElementById('phase-young');
          this.phasePromote = document.getElementById('phase-promote');
          this.phaseOld = document.getElementById('phase-old');
          this.stepBtn = document.getElementById('step-btn');
          this.runBtn = document.getElementById('run-btn');
          this.resetBtn = document.getElementById('reset-btn');
          this.objectInput = document.getElementById('object-input');
          this.randomBtn = document.getElementById('random-btn');

          this.youngObjects = [];
          this.oldObjects = [];
          this.objectAges = new Map();
          this.step = 0;
          this.intervalId = null;
          this.promotionAge = 2;

          this.init();
          this.setupEventListeners();
        }

        init() {
          this.parseObjectInput();
          this.render();
        }

        parseObjectInput() {
          const input = this.objectInput.value;
          this.youngObjects = [];
          this.oldObjects = [];
          this.objectAges.clear();
          this.step = 0;

          // Parse object definitions (format: ID:age)
          const definitions = input.split(',').map(d => d.trim());

          definitions.forEach(def => {
            if (def.includes(':')) {
              const [id, age] = def.split(':').map(s => s.trim());
              const ageValue = parseInt(age);
              const obj = {
                id: id,
                age: ageValue,
                size: 15 + Math.floor(Math.random() * 25) // Random size
              };

              if (ageValue < this.promotionAge) {
                this.youngObjects.push(obj);
              } else {
                this.oldObjects.push(obj);
              }

              this.objectAges.set(id, ageValue);
            }
          });

          // Reset phase indicators
          this.phaseYoung.classList.remove('active');
          this.phasePromote.classList.remove('active');
          this.phaseOld.classList.remove('active');
        }

        render() {
          // Clear previous visualization
          this.youngHeap.innerHTML = '';
          this.oldHeap.innerHTML = '';

          // Render young generation
          this.youngObjects.forEach(obj => {
            for (let i = 0; i < obj.size; i++) {
              const block = document.createElement('div');
              block.className = 'memory-block';

              if (i === 0) {
                block.textContent = `${obj.id} (age:${obj.age})`;
                block.classList.add('allocated');
              } else {
                block.textContent = '...';
                block.classList.add('allocated');
              }

              if (obj.age >= this.promotionAge - 1) {
                block.classList.add('marked');
              }

              this.youngHeap.appendChild(block);
            }
          });

          // Add free space to young generation
          const youngFreeBlocks = 10;
          for (let i = 0; i < youngFreeBlocks; i++) {
            const block = document.createElement('div');
            block.className = 'memory-block free';
            block.textContent = 'Free';
            this.youngHeap.appendChild(block);
          }

          // Render old generation
          this.oldObjects.forEach(obj => {
            for (let i = 0; i < obj.size; i++) {
              const block = document.createElement('div');
              block.className = 'memory-block';

              if (i === 0) {
                block.textContent = `${obj.id} (age:${obj.age})`;
                block.classList.add('allocated');
              } else {
                block.textContent = '...';
                block.classList.add('allocated');
              }

              this.oldHeap.appendChild(block);
            }
          });

          // Add free space to old generation
          const oldFreeBlocks = 10;
          for (let i = 0; i < oldFreeBlocks; i++) {
            const block = document.createElement('div');
            block.className = 'memory-block free';
            block.textContent = 'Free';
            this.oldHeap.appendChild(block);
          }

          // Update info panel
          this.updateInfoPanel();
        }

        updateInfoPanel() {
          const steps = [
            'Ready to start garbage collection',
            'Young generation collection: Identifying live objects',
            'Young generation collection: Promoting aged objects',
            'Young generation collection: Completing',
            'Old generation collection: Marking reachable objects',
            'Old generation collection: Sweeping unreachable objects',
            'Garbage collection completed'
          ];

          this.infoPanel.textContent = steps[this.step];
        }

        nextStep() {
          if (this.step >= 6) {
            this.stopAutoRun();
            return;
          }

          this.step++;

          switch(this.step) {
            case 1:
              // Start young generation collection
              this.phaseYoung.classList.add('active');
              break;
            case 2:
              // Mark objects for promotion
              this.markObjectsForPromotion();
              break;
            case 3:
              // Promote objects to old generation
              this.phaseYoung.classList.remove('active');
              this.phasePromote.classList.add('active');
              this.promoteObjects();
              break;
            case 4:
              // Complete young collection
              this.phasePromote.classList.remove('active');
              this.phaseOld.classList.add('active');
              break;
            case 5:
              // Mark objects in old generation
              this.markOldGeneration();
              break;
            case 6:
              // Sweep old generation
              this.sweepOldGeneration();
              break;
          }

          this.render();
        }

        markObjectsForPromotion() {
          // Increase age of all young objects
          this.youngObjects.forEach(obj => {
            obj.age += 1;
          });
        }

        promoteObjects() {
          // Move objects that have reached promotion age to old generation
          const toPromote = this.youngObjects.filter(obj => obj.age >= this.promotionAge);

          toPromote.forEach(obj => {
            this.oldObjects.push(obj);
          });

          // Remove promoted objects from young generation
          this.youngObjects = this.youngObjects.filter(obj => obj.age < this.promotionAge);

          // Visualize promotion with animation
          this.animatePromotion(toPromote);
        }

        animatePromotion(objects) {
          objects.forEach(obj => {
            const arrow = document.createElement('div');
            arrow.className = 'promotion-arrow';
            arrow.innerHTML = '<i class="fas fa-arrow-up"></i>';
            arrow.style.left = '40%';
            arrow.style.top = '30%';
            this.youngHeap.appendChild(arrow);

            setTimeout(() => {
              arrow.remove();
            }, 2000);
          });
        }

        markOldGeneration() {
          // In a real implementation, this would mark reachable objects
          // For visualization, we'll just mark some objects arbitrarily
          this.oldObjects.forEach(obj => {
            if (Math.random() > 0.3) { // 70% of objects are "reachable"
              obj.marked = true;
            }
          });
        }

        sweepOldGeneration() {
          // Remove unmarked objects from old generation
          this.oldObjects = this.oldObjects.filter(obj => obj.marked);
        }

        reset() {
          this.stopAutoRun();
          this.parseObjectInput();
          this.render();
        }

        startAutoRun() {
          this.stopAutoRun();
          this.intervalId = setInterval(() => {
            this.nextStep();
            if (this.step >= 6) {
              this.stopAutoRun();
            }
          }, 1500);
        }

        stopAutoRun() {
          if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
          }
        }

        generateRandomObjects() {
          let definitions = [];
          const objects = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];

          // Generate random object definitions with random ages
          for (let i = 0; i < 5; i++) {
            const age = Math.floor(Math.random() * 3);
            definitions.push(`${objects[i]}:${age}`);
          }

          this.objectInput.value = definitions.join(', ');
          this.reset();
        }

        setupEventListeners() {
          this.stepBtn.addEventListener('click', () => {
            this.nextStep();
          });

          this.runBtn.addEventListener('click', () => {
            if (this.step >= 6) {
              this.reset();
            }
            this.startAutoRun();
          });

          this.resetBtn.addEventListener('click', () => {
            this.reset();
          });

          this.randomBtn.addEventListener('click', () => {
            this.generateRandomObjects();
          });

          this.objectInput.addEventListener('change', () => {
            this.reset();
          });
        }
      }

      // Initialize the visualization when the page loads
      document.addEventListener('DOMContentLoaded', () => {
        const gcViz = new DualHeapGCVisualization();

        // Copy button functionality
        document.querySelector('.copy-btn').addEventListener('click', function() {
          const code = document.querySelector('.code-block code').innerText;
          navigator.clipboard.writeText(code);

          // Show feedback
          const originalText = this.innerHTML;
          this.innerHTML = '<i class="fas fa-check"></i> Copied!';

          setTimeout(() => {
            this.innerHTML = originalText;
          }, 2000);
        });
      });
    </script>
</body>
</html>
