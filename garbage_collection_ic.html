<!DOCTYPE html>

<html lang="en">
<head><meta content="Learn about garbage collection algorithms used in programming language runtimes" name="description"/><meta content="garbage collection, gc algorithm, mark and sweep, generational gc, reference counting" name="keywords"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Incremental/Concurrent GC | AlgoViz Hub</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap" rel="stylesheet"/>
<style>
            :root {
                --primary: #0f172a;
                --secondary: #1e293b;
                --accent: #6366f1;
                --accent-light: #818cf8;
                --accent-glow: rgba(99, 102, 241, 0.2);
                --text: #e2e8f0;
                --text-secondary: #94a3b8;
                --card-bg: rgba(30, 41, 59, 0.7);
                --success: #10b981;
                --warning: #f59e0b;
                --danger: #ef4444;
                --transition: all 0.3s ease;
                --radius: 12px;
                --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                --glow: 0 0 15px var(--accent-glow);
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background: linear-gradient(
                    135deg,
                    var(--primary),
                    var(--secondary)
                );
                color: var(--text);
                font-family: "Roboto", sans-serif;
                line-height: 1.6;
                min-height: 100vh;
                padding: 0;
                position: relative;
                overflow-x: hidden;
            }

            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background:
                    radial-gradient(
                        circle at 10% 20%,
                        rgba(99, 102, 241, 0.1) 0%,
                        transparent 20%
                    ),
                    radial-gradient(
                        circle at 90% 80%,
                        rgba(129, 140, 248, 0.1) 0%,
                        transparent 20%
                    );
                z-index: -1;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }

            /* Header Styles */
            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px 0;
                position: relative;
                border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            }

            .logo {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .logo-icon {
                width: 50px;
                height: 50px;
                background: var(--accent);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: var(--glow);
            }

            .logo-icon i {
                font-size: 24px;
                color: white;
            }

            .logo-text h1 {
                font-family: "Roboto Mono", monospace;
                font-weight: 700;
                font-size: 28px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }

            .logo-text p {
                font-size: 14px;
                color: var(--text-secondary);
                letter-spacing: 1.5px;
            }

            .breadcrumb {
                font-size: 14px;
                color: var(--text-secondary);
                margin-top: 10px;
            }

            .breadcrumb a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .breadcrumb a:hover {
                text-decoration: underline;
            }

            /* Algorithm Header */
            .algorithm-header {
                margin: 40px 0;
                text-align: center;
                padding: 20px;
                background: var(--card-bg);
                border-radius: var(--radius);
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .algorithm-header::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .algorithm-header h1 {
                font-size: 42px;
                margin-bottom: 15px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                font-weight: 800;
            }

            .algorithm-header .category {
                font-size: 18px;
                color: var(--accent-light);
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

            .complexity-badge {
                display: inline-block;
                background: rgba(129, 140, 248, 0.2);
                color: var(--accent-light);
                padding: 6px 15px;
                border-radius: 20px;
                font-size: 16px;
                font-weight: 600;
                font-family: "Roboto Mono", monospace;
                margin-top: 15px;
            }

            /* Main Content Layout */
            .main-content {
                display: grid;
                grid-template-columns: 1fr 350px;
                gap: 30px;
                margin-bottom: 40px;
            }

            @media (max-width: 900px) {
                .main-content {
                    grid-template-columns: 1fr;
                }
            }

            /* Algorithm Detail Sections */
            .section {
                background: var(--card-bg);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                padding: 30px;
                margin-bottom: 30px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .section::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .section h2 {
                font-size: 26px;
                margin-bottom: 20px;
                color: var(--accent-light);
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .section h2 i {
                color: var(--accent);
                width: 36px;
                height: 36px;
                background: rgba(99, 102, 241, 0.2);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .section p {
                color: var(--text-secondary);
                font-size: 17px;
                line-height: 1.8;
                margin-bottom: 20px;
            }

            .key-points {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 20px;
                margin: 25px 0;
            }

            .point-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
            }

            .point-card h3 {
                color: var(--accent-light);
                margin-bottom: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .point-card h3 i {
                color: var(--accent);
            }

            .point-card p {
                margin-bottom: 0;
                font-size: 15px;
            }

            /* Visualization Console */
            .visualization-console {
                background: rgba(15, 23, 42, 0.8);
                border-radius: var(--radius);
                padding: 25px;
                margin: 30px 0;
                border: 1px solid rgba(99, 102, 241, 0.3);
                box-shadow: var(--glow);
            }

            .console-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }

            .console-header h3 {
                color: var(--accent-light);
                font-size: 20px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .console-controls {
                display: flex;
                gap: 10px;
            }

            .console-btn {
                background: var(--accent);
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .console-btn:hover {
                background: var(--accent-light);
            }

            .console-btn.secondary {
                background: rgba(148, 163, 184, 0.2);
            }

            .visualization-area {
                height: 400px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                display: flex;
                position: relative;
                overflow: hidden;
            }

            .visualization-area::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.1);
                z-index: 0;
            }

            .console-input {
                display: flex;
                gap: 10px;
                margin-top: 20px;
                flex-wrap: wrap;
            }

            .console-input button {
                flex: 1;
                min-width: 120px;
            }

            /* Algorithm Properties */
            .properties-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }

            .property-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                text-align: center;
            }

            .property-card h4 {
                color: var(--text-secondary);
                font-size: 14px;
                margin-bottom: 8px;
                font-weight: 400;
            }

            .property-card .value {
                font-size: 20px;
                font-weight: 700;
                color: var(--accent-light);
                font-family: "Roboto Mono", monospace;
            }

            /* Footer */
            footer {
                text-align: center;
                padding: 40px 0 30px;
                color: var(--text-secondary);
                font-size: 14px;
                border-top: 1px solid rgba(148, 163, 184, 0.1);
                margin-top: 40px;
            }

            footer p {
                margin: 10px 0;
            }

            .footer-links {
                display: flex;
                justify-content: center;
                gap: 25px;
                margin-top: 15px;
                flex-wrap: wrap;
                margin-bottom: 20px;
            }

            .footer-links a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .footer-links a:hover {
                color: var(--accent);
            }

            /* Animations */
            @keyframes float {
                0% {
                    transform: translateY(0px);
                }
                50% {
                    transform: translateY(-10px);
                }
                100% {
                    transform: translateY(0px);
                }
            }

            .floating {
                animation: float 6s ease-in-out infinite;
            }

            /* Responsive Design */
            @media (max-width: 768px) {
                header {
                    flex-direction: column;
                    gap: 25px;
                    text-align: center;
                }

                .algorithm-header h1 {
                    font-size: 32px;
                }

                .key-points {
                    grid-template-columns: 1fr;
                }

                .console-input button {
                    min-width: 100px;
                    font-size: 12px;
                    padding: 8px 10px;
                }
            }

            /* Code Block Styling */
            .code-block {
                background: #0d1117;
                border-radius: 8px;
                padding: 20px;
                margin: 25px 0;
                overflow-x: auto;
                font-family: "Roboto Mono", monospace;
                font-size: 15px;
                border: 1px solid rgba(99, 102, 241, 0.3);
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                color: var(--text-secondary);
            }

            .copy-btn {
                background: rgba(99, 102, 241, 0.2);
                color: var(--accent-light);
                border: none;
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .copy-btn:hover {
                background: rgba(99, 102, 241, 0.3);
            }

            .code-block pre {
                margin: 0;
            }

            .code-block code {
                color: #c9d1d9;
                line-height: 1.5;
            }

            .keyword {
                color: #ff7b72;
            }
            .function {
                color: #d2a8ff;
            }
            .comment {
                color: #8b949e;
            }
            .string {
                color: #a5d6ff;
            }
            .number {
                color: #79c0ff;
            }

            /* Incremental/Concurrent GC Visualization Styles */
            .heap-container {
                display: flex;
                width: 100%;
                height: 100%;
                flex-direction: column;
                padding: 15px;
            }

            .heap-memory {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                padding: 15px;
                background: rgba(30, 41, 59, 0.5);
                border-radius: 8px;
                border: 1px solid rgba(99, 102, 241, 0.3);
                min-height: 250px;
                align-content: flex-start;
                position: relative;
            }

            .memory-block {
                width: 70px;
                height: 80px;
                border-radius: 8px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                font-family: "Roboto Mono", monospace;
                font-size: 14px;
                text-align: center;
                transition: all 0.5s ease;
                position: relative;
                overflow: hidden;
                cursor: pointer;
            }

            .block-free {
                background: rgba(148, 163, 184, 0.2);
                border: 1px dashed var(--text-secondary);
            }

            .block-allocated {
                background: var(--accent);
                border: 1px solid var(--accent-light);
                box-shadow: var(--glow);
            }

            .block-marked {
                background: var(--success);
                border: 1px solid #34d399;
            }

            .block-grey {
                background: var(--warning);
                border: 1px solid #fbbf24;
                animation: pulse 1.5s infinite;
            }

            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(0.95);
                }
                100% {
                    transform: scale(1);
                }
            }

            .block-black {
                background: #4b5563;
                border: 1px solid #6b7280;
            }

            .block-barrier {
                background: var(--danger);
                border: 2px solid #f87171;
            }

            .reference-count {
                position: absolute;
                top: 5px;
                right: 5px;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                font-weight: bold;
            }

            .reference-arrow {
                position: absolute;
                z-index: -1;
                stroke: var(--accent-light);
                stroke-width: 2;
                fill: none;
            }

            .roots-container {
                position: absolute;
                top: 20px;
                left: 20px;
                background: rgba(30, 41, 59, 0.8);
                border-radius: 8px;
                padding: 10px;
                border: 1px solid var(--accent);
            }

            .root-pointer {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: var(--warning);
                margin-bottom: 10px;
                font-size: 12px;
            }

            .status-panel {
                position: absolute;
                bottom: 10px;
                left: 10px;
                right: 10px;
                background: rgba(15, 23, 42, 0.7);
                border-radius: 8px;
                padding: 10px;
                font-size: 14px;
                font-family: "Roboto Mono", monospace;
                text-align: center;
                color: var(--accent-light);
                border: 1px solid rgba(99, 102, 241, 0.3);
            }

            .phase-indicator {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin-top: 10px;
            }

            .phase {
                padding: 5px 10px;
                border-radius: 5px;
                background: rgba(99, 102, 241, 0.2);
                color: var(--text-secondary);
            }

            .phase.active {
                background: var(--accent);
                color: white;
            }

            .log-entry {
                margin: 5px 0;
                padding: 5px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
                font-size: 12px;
            }

            .log-container {
                position: absolute;
                top: 10px;
                right: 10px;
                width: 220px;
                max-height: 150px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 8px;
                padding: 10px;
                font-size: 12px;
                font-family: "Roboto Mono", monospace;
            }

            .algorithm-stats {
                display: flex;
                justify-content: space-between;
                padding: 10px;
                background: rgba(30, 41, 59, 0.5);
                border-radius: 8px;
                margin-top: 10px;
                font-size: 14px;
            }

            .stat-item {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .stat-value {
                font-weight: bold;
                color: var(--accent-light);
            }

            .stat-label {
                font-size: 12px;
                color: var(--text-secondary);
            }

            .memory-address {
                font-size: 10px;
                position: absolute;
                bottom: 5px;
                color: rgba(255, 255, 255, 0.7);
            }

            .thread-indicator {
                position: absolute;
                top: 20px;
                right: 240px;
                background: rgba(30, 41, 59, 0.8);
                border-radius: 8px;
                padding: 10px;
                border: 1px solid var(--accent);
                font-size: 12px;
            }

            .thread {
                padding: 5px 10px;
                border-radius: 5px;
                margin-bottom: 5px;
                display: flex;
                align-items: center;
                gap: 5px;
            }

            .mutator-thread {
                background: rgba(16, 185, 129, 0.2);
                border: 1px solid var(--success);
            }

            .collector-thread {
                background: rgba(99, 102, 241, 0.2);
                border: 1px solid var(--accent);
            }

            .thread-active {
                animation: threadPulse 2s infinite;
            }

            @keyframes threadPulse {
                0% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.7;
                }
                100% {
                    opacity: 1;
                }
            }

            .write-barrier-indicator {
                position: absolute;
                bottom: 60px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--danger);
                color: white;
                padding: 8px 15px;
                border-radius: 20px;
                font-size: 14px;
                display: none;
            }
        </style>
<meta content="Incremental/Concurrent GC | AlgoViz Hub" property="og:title"/><meta content="Learn about garbage collection algorithms used in programming language runtimes" property="og:description"/><meta content="article" property="og:type"/><meta content="https://sgkandale.github.io/garbage_collection_ic.html" property="og:url"/><meta content="AlgoViz Hub" property="og:site_name"/><meta content="summary" name="twitter:card"/><meta content="Incremental/Concurrent GC | AlgoViz Hub" name="twitter:title"/><meta content="Learn about garbage collection algorithms used in programming language runtimes" name="twitter:description"/><meta content="@sgkandale" name="twitter:site"/><link href="https://sgkandale.github.io/garbage_collection_ic.html" rel="canonical"/><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Incremental/Concurrent GC | AlgoViz Hub",
  "description": "Learn about garbage collection algorithms used in programming language runtimes",
  "author": {
    "@type": "Person",
    "name": "Shantanu Kandale"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AlgoViz Hub",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sgkandale.github.io/favicon.ico"
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sgkandale.github.io/garbage_collection_ic.html"
  }
}</script></head>
<body>
<div class="container">
<!-- Header -->
<header>
<div class="logo">
<div class="logo-icon floating">
<i class="fas fa-tachometer-alt"></i>
</div>
<div class="logo-text">
<h1>AlgoViz Hub</h1>
<p>ALGORITHM VISUALIZATION REPOSITORY</p>
<div class="breadcrumb">
<a href="#"><i class="fas fa-home"></i> Home</a> &gt;
                            <a href="#">Memory Management</a> &gt;
                            <span>Incremental/Concurrent GC</span>
</div>
</div>
</div>
</header>
<!-- Algorithm Header -->
<div class="algorithm-header">
<h1>Incremental &amp; Concurrent GC</h1>
<div class="category">
<i class="fas fa-clock"></i> Low-Pause Garbage Collection
                </div>
<div class="complexity-badge">
                    Pause Times: Minimal | Throughput: High
                </div>
</div>
<!-- Main Content -->
<div class="main-content">
<!-- Left Column: Algorithm Details -->
<div class="left-column">
<!-- Description Section -->
<div class="section">
<h2>
<i class="fas fa-file-alt"></i> Algorithm Overview
                        </h2>
<p>
                            Incremental and Concurrent Garbage Collection
                            algorithms are designed to minimize pause times by
                            breaking up garbage collection work into small
                            increments that can be interleaved with application
                            execution (mutator). This approach provides
                            consistent responsiveness at the cost of slightly
                            reduced throughput.
                        </p>
<p>
                            Incremental GC performs collection in small steps
                            between mutator operations, while Concurrent GC runs
                            collection simultaneously with the mutator on
                            multiple threads. Both approaches require write
                            barriers to maintain consistency while the mutator
                            continues to run.
                        </p>
<div class="key-points">
<div class="point-card">
<h3>
<i class="fas fa-check-circle"></i> Key
                                    Feature
                                </h3>
<p>
                                    Minimal pause times by interleaving GC work
                                    with mutator execution
                                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-bolt"></i> Performance</h3>
<p>
                                    Excellent responsiveness with slightly
                                    reduced throughput
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-memory"></i> Memory Usage
                                </h3>
<p>
                                    Requires additional metadata for write
                                    barriers and consistency
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-project-diagram"></i>
                                    Approach
                                </h3>
<p>
                                    Breaks collection into small units and uses
                                    barriers for consistency
                                </p>
</div>
</div>
</div>
<!-- Visualization Console -->
<div class="section">
<h2>
<i class="fas fa-laptop-code"></i> Interactive
                            Visualization
                        </h2>
<p>
                            The visualization below demonstrates Incremental and
                            Concurrent garbage collection algorithms. You can
                            see how the collector works in small increments
                            alongside the mutator, and how write barriers
                            maintain consistency. Use the controls to simulate
                            different scenarios.
                        </p>
<div class="visualization-console">
<div class="console-header">
<h3>
<i class="fas fa-memory"></i> Heap
                                    Visualization
                                </h3>
<div class="console-controls">
<button class="console-btn secondary" id="step-btn">
<i class="fas fa-step-forward"></i> Step
                                    </button>
<button class="console-btn" id="run-incr-btn">
<i class="fas fa-play"></i> Run
                                        Incremental
                                    </button>
<button class="console-btn secondary" id="run-conc-btn">
<i class="fas fa-play-circle"></i> Run
                                        Concurrent
                                    </button>
</div>
</div>
<div class="visualization-area" id="gc-visualization">
<!-- Visualization will be rendered here by JavaScript -->
<div class="heap-container" id="heap-container">
<div class="heap-memory" id="heap-memory"></div>
<div class="write-barrier-indicator" id="write-barrier-indicator">
<i class="fas fa-shield-alt"></i> Write
                                        Barrier Active
                                    </div>
<div class="algorithm-stats">
<div class="stat-item">
<span class="stat-value" id="total-objects">0</span>
<span class="stat-label">Total Objects</span>
</div>
<div class="stat-item">
<span class="stat-value" id="marked-objects">0</span>
<span class="stat-label">Marked</span>
</div>
<div class="stat-item">
<span class="stat-value" id="barrier-count">0</span>
<span class="stat-label">Barrier Hits</span>
</div>
<div class="stat-item">
<span class="stat-value" id="pause-time">0ms</span>
<span class="stat-label">Pause Time</span>
</div>
</div>
</div>
</div>
<div class="console-input">
<button class="console-btn" id="allocate-btn">
<i class="fas fa-plus-circle"></i> Allocate
                                    Object
                                </button>
<button class="console-btn" id="create-ref-btn">
<i class="fas fa-link"></i> Create Reference
                                </button>
<button class="console-btn secondary" id="mutator-btn">
<i class="fas fa-code"></i> Run Mutator
                                </button>
<button class="console-btn secondary" id="reset-btn">
<i class="fas fa-redo"></i> Reset
                                </button>
</div>
</div>
</div>
<!-- Algorithm Steps -->
<div class="section">
<h2>
<i class="fas fa-list-ol"></i> Algorithm Approaches
                        </h2>
<p>
                            Incremental and Concurrent GC use various techniques
                            to minimize pause times:
                        </p>
<div class="key-points">
<div class="point-card">
<h3>
<i class="fas fa-pause-circle"></i> 1.
                                    Incremental Mark-Sweep
                                </h3>
<p>
                                    Breaks the mark phase into small increments,
                                    interleaving with mutator execution. Uses a
                                    write barrier to track references from black
                                    to white objects.
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-users"></i> 2. Concurrent
                                    Mark-Sweep
                                </h3>
<p>
                                    Runs the mark phase concurrently with
                                    mutator execution in separate threads.
                                    Requires more sophisticated synchronization
                                    and barriers.
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-shield-alt"></i> 3. Write
                                    Barriers
                                </h3>
<p>
                                    Special code that executes on pointer stores
                                    to maintain invariants. Tracks references
                                    from black to white objects during
                                    concurrent marking.
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-tachometer-alt"></i> 4.
                                    Tricolor Abstraction
                                </h3>
<p>
                                    Models object states as white (unprocessed),
                                    grey (being processed), and black
                                    (processed). Write barriers maintain the
                                    invariant that black objects never point to
                                    white objects.
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-sync-alt"></i> 5.
                                    Snapshot-at-the-Beginning
                                </h3>
<p>
                                    Records all objects live at the start of
                                    collection. Any object allocated after this
                                    point is considered live for the current
                                    cycle.
                                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-wave-square"></i> 6.
                                    Incremental Update
                                </h3>
<p>
                                    Tracks changes to the object graph during
                                    collection. When a reference is updated,
                                    both old and new targets may need special
                                    handling.
                                </p>
</div>
</div>
</div>
<!-- Pseudocode Section -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
<div class="code-block">
<div class="code-header">
<span>Incremental Mark-Sweep Algorithm</span>
<button class="copy-btn">
<i class="fas fa-copy"></i> Copy Code
                                </button>
</div>
<pre><code>// Incremental Mark-Sweep Garbage Collection
function incrementalGC():
  // Initialization phase (short pause)
  stopTheWorld()
  initializeMarking()
  resumeExecution()

  // Incremental marking phase
  while hasGreyObjects():
    // Short pause to process some grey objects
    stopTheWorld()
    processSomeGreyObjects()
    resumeExecution()

    // Mutator runs here, possibly creating new references
    // Write barrier tracks references from black to white objects

  // Final marking phase (short pause)
  stopTheWorld()
  drainMarkStack()
  resumeExecution()

  // Concurrent sweeping phase
  sweepConcurrently()

// Write barrier for incremental collection
function writeBarrier(src, field, newValue):
  if isBlack(src) and isWhite(newValue):
    // Remember this reference for later processing
    remember(src, field, newValue)
    newValue = grey  // Mark target as grey
  updateField(src, field, newValue)

// Concurrent marking thread
function concurrentMarker():
  while hasGreyObjects():
    processSomeGreyObjects()
    sleep(smallTimeSlice)  // Yield to mutator

// Concurrent sweeping thread
function concurrentSweeper():
  for each object in heap:
    if object is white:
      free(object)
    else:
      object.color = white  // For next GC cycle</code></pre>
</div>
</div>
<!-- Implementation Section -->
<div class="section">
<h2><i class="fas fa-code"></i> Implementation</h2>
<p>
                            Below is a simplified Python implementation of an
                            Incremental Garbage Collector.
                        </p>
<div class="code-block">
<div class="code-header">
<span>Python Implementation</span>
<button class="copy-btn">
<i class="fas fa-copy"></i> Copy Code
                                </button>
</div>
<pre><code><span class="keyword">class</span> <span class="function">IncrementalGC</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.heap = []
        <span class="keyword">self</span>.roots = []
        <span class="keyword">self</span>.grey_list = []
        <span class="keyword">self</span>.black_set = set()
        <span class="keyword">self</span>.white_set = set()
        <span class="keyword">self</span>.write_barrier_log = []

    <span class="keyword">def</span> <span class="function">allocate</span>(<span class="keyword">self</span>, obj):
        <span class="keyword">self</span>.heap.append(obj)
        <span class="keyword">self</span>.white_set.add(obj)
        <span class="keyword">return</span> obj

    <span class="keyword">def</span> <span class="function">add_root</span>(<span class="keyword">self</span>, obj):
        <span class="keyword">self</span>.roots.append(obj)
        <span class="keyword">self</span>.write_barrier(None, None, obj)  <span class="comment"># Treat as new reference</span>

    <span class="keyword">def</span> <span class="function">write_barrier</span>(<span class="keyword">self</span>, src, field, new_val):
        <span class="comment"># If source is black and new value is white, we need to remember this</span>
        <span class="keyword">if</span> src <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> src <span class="keyword">in</span> <span class="keyword">self</span>.black_set <span class="keyword">and</span> new_val <span class="keyword">in</span> <span class="keyword">self</span>.white_set:
            <span class="keyword">self</span>.write_barrier_log.append((src, field, new_val))
            <span class="keyword">self</span>.grey_list.append(new_val)  <span class="comment"># Make the target grey</span>
            <span class="keyword">self</span>.white_set.remove(new_val)
        <span class="comment"># Actually update the reference</span>
        <span class="keyword">if</span> src <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
            setattr(src, field, new_val)

    <span class="keyword">def</span> <span class="function">start_gc_cycle</span>(<span class="keyword">self</span>):
        <span class="comment"># Initial pause: mark roots as grey</span>
        <span class="keyword">self</span>.grey_list.extend(<span class="keyword">self</span>.roots)
        <span class="keyword">for</span> root <span class="keyword">in</span> <span class="keyword">self</span>.roots:
            <span class="keyword">if</span> root <span class="keyword">in</span> <span class="keyword">self</span>.white_set:
                <span class="keyword">self</span>.white_set.remove(root)

    <span class="keyword">def</span> <span class="function">incremental_mark_step</span>(<span class="keyword">self</span>, steps=5):
        <span class="comment"># Process a few grey objects</span>
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(min(steps, len(<span class="keyword">self</span>.grey_list))):
            <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.grey_list:
                <span class="keyword">break</span>
            obj = <span class="keyword">self</span>.grey_list.pop()
            <span class="keyword">self</span>.black_set.add(obj)
            <span class="comment"># Mark all children as grey</span>
            <span class="keyword">for</span> ref <span class="keyword">in</span> get_references(obj):
                <span class="keyword">if</span> ref <span class="keyword">in</span> <span class="keyword">self</span>.white_set:
                    <span class="keyword">self</span>.white_set.remove(ref)
                    <span class="keyword">self</span>.grey_list.append(ref)

        <span class="comment"># Also process any write barrier entries</span>
        <span class="keyword">while</span> <span class="keyword">self</span>.write_barrier_log:
            src, field, new_val = <span class="keyword">self</span>.write_barrier_log.pop()
            <span class="keyword">if</span> new_val <span class="keyword">in</span> <span class="keyword">self</span>.white_set:
                <span class="keyword">self</span>.white_set.remove(new_val)
                <span class="keyword">self</span>.grey_list.append(new_val)

    <span class="keyword">def</span> <span class="function">sweep</span>(<span class="keyword">self</span>):
        <span class="comment"># Sweep phase: free white objects</span>
        new_heap = []
        <span class="keyword">for</span> obj <span class="keyword">in</span> <span class="keyword">self</span>.heap:
            <span class="keyword">if</span> obj <span class="keyword">in</span> <span class="keyword">self</span>.white_set:
                <span class="comment"># Free the object</span>
                <span class="keyword">pass</span>
            <span class="keyword">else</span>:
                new_heap.append(obj)
                <span class="comment"># Reset for next GC cycle</span>
                <span class="keyword">self</span>.white_set.add(obj)

        <span class="keyword">self</span>.heap = new_heap
        <span class="keyword">self</span>.black_set.clear()
        <span class="keyword">self</span>.grey_list.clear()
        <span class="keyword">self</span>.write_barrier_log.clear()

<span class="comment"># Example usage</span>
gc = IncrementalGC()

<span class="comment"># Create and allocate objects</span>
obj1 = gc.allocate(MyObject())
obj2 = gc.allocate(MyObject())

<span class="comment"># Add roots</span>
gc.add_root(obj1)

<span class="comment"># Start GC cycle</span>
gc.start_gc_cycle()

<span class="comment"># Incremental marking steps</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(10):
    gc.incremental_mark_step(steps=2)
    <span class="comment"># Mutator runs here...</span>

<span class="comment"># Final sweep</span>
gc.sweep()</code></pre>
</div>
</div>
</div>
<!-- Right Column: Additional Info -->
<div class="right-column">
<!-- Properties Section -->
<div class="section">
<h2>
<i class="fas fa-info-circle"></i> Algorithm
                            Properties
                        </h2>
<div class="properties-grid">
<div class="property-card">
<h4>Category</h4>
<div class="value">Low-Pause GC</div>
</div>
<div class="property-card">
<h4>Type</h4>
<div class="value">Incremental/Concurrent</div>
</div>
<div class="property-card">
<h4>Pause Times</h4>
<div class="value">Minimal</div>
</div>
<div class="property-card">
<h4>Throughput</h4>
<div class="value">Medium-High</div>
</div>
<div class="property-card">
<h4>Memory Overhead</h4>
<div class="value">Medium</div>
</div>
<div class="property-card">
<h4>Complexity</h4>
<div class="value">High</div>
</div>
<div class="property-card">
<h4>Synchronization</h4>
<div class="value">Required</div>
</div>
<div class="property-card">
<h4>Barriers</h4>
<div class="value">Write Barrier</div>
</div>
</div>
</div>
<!-- Applications Section -->
<div class="section">
<h2><i class="fas fa-lightbulb"></i> Applications</h2>
<p>
                            Incremental and Concurrent GC are used in systems
                            requiring low latency:
                        </p>
<ul style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            ">
<li style="margin-bottom: 10px">
                                Real-time systems and games
                            </li>
<li style="margin-bottom: 10px">
                                Interactive applications and UI frameworks
                            </li>
<li style="margin-bottom: 10px">
                                Web browsers (JavaScript engines)
                            </li>
<li style="margin-bottom: 10px">
                                High-performance servers and databases
                            </li>
<li>Financial trading systems</li>
<li>Telecommunications systems</li>
</ul>
</div>
<!-- Advantages Section -->
<div class="section">
<h2><i class="fas fa-star"></i> Key Advantages</h2>
<ul style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            ">
<li style="margin-bottom: 10px">
<strong>Low Pause Times:</strong> Minimal
                                disruption to application
                            </li>
<li style="margin-bottom: 10px">
<strong>Responsive:</strong> Better user
                                experience for interactive apps
                            </li>
<li style="margin-bottom: 10px">
<strong>Predictable:</strong> More consistent
                                performance
                            </li>
<li style="margin-bottom: 10px">
<strong>Scalable:</strong> Works well on
                                multi-core systems
                            </li>
<li>
<strong>Flexible:</strong> Can be tuned for
                                latency or throughput
                            </li>
</ul>
</div>
<!-- Disadvantages Section -->
<div class="section">
<h2>
<i class="fas fa-exclamation-triangle"></i>
                            Challenges
                        </h2>
<ul style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            ">
<li style="margin-bottom: 10px">
                                More complex implementation than stop-the-world
                                GC
                            </li>
<li style="margin-bottom: 10px">
                                Write barrier overhead affects mutator
                                performance
                            </li>
<li style="margin-bottom: 10px">
                                Requires careful synchronization in concurrent
                                collectors
                            </li>
<li>
                                May require more total CPU cycles for collection
                            </li>
</ul>
</div>
</div>
</div>
<!-- Footer -->
<footer>
<div class="footer-links">
<a href="https://www.linkedin.com/in/sgkandale/" target="_blank"><i class="fa-brands fa-linkedin"></i> LinkedIN</a>
<a href="mailto:me@sgkandale.com"><i class="fa-solid fa-at"></i> E-Mail</a>
<a href="https://buymeacoffee.com/sgkandale" target="_blank"><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a>
</div>
<p>
                    AlgoViz Hub - Interactive Algorithm Visualization Platform
                </p>
<p>Â© 2025 AlgoViz Hub. All rights reserved.</p>
</footer>
</div>
<script>
            // Visualization for Incremental/Concurrent Garbage Collection
            document.addEventListener("DOMContentLoaded", function () {
                class IncrementalGCVisualization {
            constructor() {
                this.heapContainer = document.getElementById("heap-container");
                this.allocateBtn = document.getElementById("allocate-btn");
                this.minorGcBtn = document.getElementById("minor-gc-btn");
                this.majorGcBtn = document.getElementById("major-gc-btn");
                this.createRefBtn = document.getElementById("create-ref-btn");
                this.nullRefBtn = document.getElementById("null-ref-btn");
                this.logContainer = document.createElement('div');
                this.statusPanel = document.createElement('div');
                
                this.promotionAge = 3;
                this.init();
                this.setupEventListeners();
            }

            init() {
                this.objects = new Map();
                this.roots = new Set();
                this.nextId = 0;
                this.selectedObject = null;
                
                this.render();
                this.logEvent("Initialized heap.");
                this.updateStatus("Ready.");
                
                // Initial objects
                this.allocateObject();
                this.allocateObject();
                this.roots.add(this.objects.get(0));
                this.roots.add(this.objects.get(1));
                this.render();
            }

            render() {
                this.heapContainer.innerHTML = `
                    <div class="generation young-generation">
                        <div class="generation-title">Young Generation</div>
                        <div class="sub-space eden-space" id="eden"></div>
                        <div class="sub-space survivor-space" id="s0">S0</div>
                        <div class="sub-space survivor-space" id="s1">S1</div>
                    </div>
                    <div class="generation old-generation">
                        <div class="generation-title">Old Generation</div>
                        <div class="sub-space old-space" id="old"></div>
                    </div>
                `;
                
                this.objects.forEach(obj => {
                    const space = document.getElementById(obj.space);
                    if(space) space.appendChild(this.createObjectElement(obj));
                });
                
                this.drawReferences();
            }
            
            createObjectElement(obj) {
                const el = document.createElement('div');
                el.className = 'memory-block';
                el.dataset.id = obj.id;
                el.innerHTML = `Obj ${obj.id}<div class="block-age">Age: ${obj.age}</div>`;
                el.classList.add(obj.age >= this.promotionAge ? 'block-old' : (obj.age > 0 ? 'block-young' : 'block-new'));
                if(this.roots.has(obj)) el.style.border = '2px solid var(--warning)';
                el.addEventListener('click', () => this.selectObject(obj));
                return el;
            }
            
            drawReferences() {
                // Simplified: no arrows for now to reduce complexity
            }

            allocateObject() {
                const id = this.nextId++;
                const obj = { id, age: 0, space: 'eden', refs: new Set() };
                this.objects.set(id, obj);
                this.logEvent(`Allocated Object ${id} in Eden.`);
                this.render();
            }
            
            createReference() {
                if(this.objects.size < 2) return;
                let from, to;
                do {
                    from = Array.from(this.objects.values())[Math.floor(Math.random() * this.objects.size)];
                    to = Array.from(this.objects.values())[Math.floor(Math.random() * this.objects.size)];
                } while (from === to);
                
                from.refs.add(to);
                this.logEvent(`Created reference from ${from.id} to ${to.id}.`);
                this.render();
            }
            
            nullifyReference() {
                 const withRefs = Array.from(this.objects.values()).filter(o => o.refs.size > 0);
                 if(withRefs.length === 0) return;
                 const from = withRefs[Math.floor(Math.random() * withRefs.length)];
                 const to = Array.from(from.refs)[0];
                 from.refs.delete(to);
                 this.logEvent(`Nullified reference from ${from.id} to ${to.id}.`);
                 this.render();
            }

            selectObject(obj) {
                if (this.selectedObject) {
                    this.selectedObject.element.style.border = '';
                    if (this.selectedObject !== obj) {
                        this.selectedObject.refs.add(obj);
                        this.logEvent(`Created reference from ${this.selectedObject.id} to ${obj.id}.`);
                        this.render();
                    }
                    this.selectedObject = null;
                } else {
                    this.selectedObject = obj;
                    obj.element.style.border = '2px solid white';
                }
            }

            minorGC() {
                this.logEvent("--- Minor GC Started ---");
                
                // Mark
                const live = new Set();
                const worklist = [...this.roots];
                while(worklist.length > 0) {
                    const obj = worklist.pop();
                    if(!live.has(obj)) {
                        live.add(obj);
                        obj.refs.forEach(ref => worklist.push(ref));
                    }
                }
                
                // Evacuate
                this.objects.forEach(obj => {
                    if(obj.space === 'eden' || obj.space === 's0' || obj.space === 's1') {
                        if(live.has(obj)) {
                            obj.age++;
                            if(obj.age >= this.promotionAge) {
                                obj.space = 'old';
                                this.logEvent(`Promoted ${obj.id} to Old Gen.`);
                            } else {
                                obj.space = 's1'; // Simplified: always move to s1
                                this.logEvent(`Moved ${obj.id} to Survivor Space.`);
                            }
                        } else {
                            this.objects.delete(obj.id);
                            this.logEvent(`Collected garbage object ${obj.id}.`);
                        }
                    }
                });
                
                this.logEvent("--- Minor GC Finished ---");
                this.render();
            }
            
            majorGC() {
                this.logEvent("--- Major GC Started ---");
                // Mark
                const live = new Set();
                const worklist = [...this.roots];
                while(worklist.length > 0) {
                    const obj = worklist.pop();
                    if(!live.has(obj)) {
                        live.add(obj);
                        obj.refs.forEach(ref => worklist.push(ref));
                    }
                }
                
                // Sweep
                this.objects.forEach(obj => {
                    if(!live.has(obj)) {
                        this.objects.delete(obj.id);
                        this.logEvent(`Collected garbage object ${obj.id}.`);
                    }
                });
                
                this.logEvent("--- Major GC Finished ---");
                this.render();
            }

            logEvent(message) {
                console.log(message);
            }
            
            updateStatus(message) {
                console.log(message);
            }

            setupEventListeners() {
                this.allocateBtn.addEventListener("click", () => this.allocateObject());
                this.minorGcBtn.addEventListener("click", () => this.minorGC());
                this.majorGcBtn.addEventListener("click", () => this.majorGC());
                this.createRefBtn.addEventListener("click", () => this.createReference());
                this.nullRefBtn.addEventListener("click", () => this.nullifyReference());
            }
        }

        new GenerationalGCVisualization();
    });
</script>
</body>
</html>
