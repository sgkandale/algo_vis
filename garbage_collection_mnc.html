<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Mark-and-Compact GC | AlgoViz Hub</title>
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&family=Roboto:wght@300;400;500;700&display=swap"
            rel="stylesheet"
        />
        <style>
            :root {
                --primary: #0f172a;
                --secondary: #1e293b;
                --accent: #6366f1;
                --accent-light: #818cf8;
                --accent-glow: rgba(99, 102, 241, 0.2);
                --text: #e2e8f0;
                --text-secondary: #94a3b8;
                --card-bg: rgba(30, 41, 59, 0.7);
                --success: #10b981;
                --warning: #f59e0b;
                --danger: #ef4444;
                --transition: all 0.3s ease;
                --radius: 12px;
                --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                --glow: 0 0 15px var(--accent-glow);
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background: linear-gradient(
                    135deg,
                    var(--primary),
                    var(--secondary)
                );
                color: var(--text);
                font-family: "Roboto", sans-serif;
                line-height: 1.6;
                min-height: 100vh;
                padding: 0;
                position: relative;
                overflow-x: hidden;
            }

            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background:
                    radial-gradient(
                        circle at 10% 20%,
                        rgba(99, 102, 241, 0.1) 0%,
                        transparent 20%
                    ),
                    radial-gradient(
                        circle at 90% 80%,
                        rgba(129, 140, 248, 0.1) 0%,
                        transparent 20%
                    );
                z-index: -1;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }

            /* Header Styles */
            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px 0;
                position: relative;
                border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            }

            .logo {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .logo-icon {
                width: 50px;
                height: 50px;
                background: var(--accent);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: var(--glow);
            }

            .logo-icon i {
                font-size: 24px;
                color: white;
            }

            .logo-text h1 {
                font-family: "Roboto Mono", monospace;
                font-weight: 700;
                font-size: 28px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }

            .logo-text p {
                font-size: 14px;
                color: var(--text-secondary);
                letter-spacing: 1.5px;
            }

            .breadcrumb {
                font-size: 14px;
                color: var(--text-secondary);
                margin-top: 10px;
            }

            .breadcrumb a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .breadcrumb a:hover {
                text-decoration: underline;
            }

            /* Algorithm Header */
            .algorithm-header {
                margin: 40px 0;
                text-align: center;
                padding: 20px;
                background: var(--card-bg);
                border-radius: var(--radius);
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .algorithm-header::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .algorithm-header h1 {
                font-size: 42px;
                margin-bottom: 15px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                font-weight: 800;
            }

            .algorithm-header .category {
                font-size: 18px;
                color: var(--accent-light);
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

            .complexity-badge {
                display: inline-block;
                background: rgba(129, 140, 248, 0.2);
                color: var(--accent-light);
                padding: 6px 15px;
                border-radius: 20px;
                font-size: 16px;
                font-weight: 600;
                font-family: "Roboto Mono", monospace;
                margin-top: 15px;
            }

            /* Main Content Layout */
            .main-content {
                display: grid;
                grid-template-columns: 1fr 350px;
                gap: 30px;
                margin-bottom: 40px;
            }

            @media (max-width: 900px) {
                .main-content {
                    grid-template-columns: 1fr;
                }
            }

            /* Algorithm Detail Sections */
            .section {
                background: var(--card-bg);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                padding: 30px;
                margin-bottom: 30px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .section::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .section h2 {
                font-size: 26px;
                margin-bottom: 20px;
                color: var(--accent-light);
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .section h2 i {
                color: var(--accent);
                width: 36px;
                height: 36px;
                background: rgba(99, 102, 241, 0.2);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .section p {
                color: var(--text-secondary);
                font-size: 17px;
                line-height: 1.8;
                margin-bottom: 20px;
                text-align: justify;
            }

            .key-points {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 20px;
                margin: 25px 0;
            }

            .point-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
            }

            .point-card h3 {
                color: var(--accent-light);
                margin-bottom: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .point-card h3 i {
                color: var(--accent);
            }

            .point-card p {
                margin-bottom: 0;
                font-size: 15px;
                text-align: left;
            }

            /* Visualization Console */
            .visualization-console {
                background: rgba(15, 23, 42, 0.8);
                border-radius: var(--radius);
                padding: 25px;
                margin: 30px 0;
                border: 1px solid rgba(99, 102, 241, 0.3);
                box-shadow: var(--glow);
            }

            .console-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }

            .console-header h3 {
                color: var(--accent-light);
                font-size: 20px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .console-controls {
                display: flex;
                gap: 10px;
            }

            .console-btn {
                background: var(--accent);
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .console-btn:hover {
                background: var(--accent-light);
            }

            .console-btn.secondary {
                background: rgba(148, 163, 184, 0.2);
            }

            .visualization-area {
                height: 400px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                display: flex;
                position: relative;
                overflow: hidden;
            }

            .visualization-area::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.1);
                z-index: 0;
            }

            .console-input {
                display: flex;
                gap: 10px;
                margin-top: 20px;
                flex-wrap: wrap;
            }

            .console-input button {
                flex: 1;
                min-width: 120px;
            }

            /* Algorithm Properties */
            .properties-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }

            .property-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                text-align: center;
            }

            .property-card h4 {
                color: var(--text-secondary);
                font-size: 14px;
                margin-bottom: 8px;
                font-weight: 400;
            }

            .property-card .value {
                font-size: 20px;
                font-weight: 700;
                color: var(--accent-light);
                font-family: "Roboto Mono", monospace;
            }

            /* Footer */
            footer {
                text-align: center;
                padding: 40px 0 30px;
                color: var(--text-secondary);
                font-size: 14px;
                border-top: 1px solid rgba(148, 163, 184, 0.1);
                margin-top: 40px;
            }

            footer p {
                margin: 10px 0;
            }

            .footer-links {
                display: flex;
                justify-content: center;
                gap: 25px;
                margin-top: 15px;
                flex-wrap: wrap;
                margin-bottom: 20px;
            }

            .footer-links a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .footer-links a:hover {
                color: var(--accent);
            }

            /* Animations */
            @keyframes float {
                0% {
                    transform: translateY(0px);
                }
                50% {
                    transform: translateY(-10px);
                }
                100% {
                    transform: translateY(0px);
                }
            }

            .floating {
                animation: float 6s ease-in-out infinite;
            }

            /* Responsive Design */
            @media (max-width: 768px) {
                header {
                    flex-direction: column;
                    gap: 25px;
                    text-align: center;
                }

                .algorithm-header h1 {
                    font-size: 32px;
                }

                .key-points {
                    grid-template-columns: 1fr;
                }

                .console-input button {
                    min-width: 100px;
                    font-size: 12px;
                    padding: 8px 10px;
                }
            }

            /* Code Block Styling */
            .code-block {
                background: #0d1117;
                border-radius: 8px;
                padding: 20px;
                margin: 25px 0;
                overflow-x: auto;
                font-family: "Roboto Mono", monospace;
                font-size: 15px;
                border: 1px solid rgba(99, 102, 241, 0.3);
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                color: var(--text-secondary);
                font-size: 16px;
            }

            .copy-btn {
                background: rgba(99, 102, 241, 0.2);
                color: var(--accent-light);
                border: none;
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
                font-size: 14px;
            }

            .copy-btn:hover {
                background: rgba(99, 102, 241, 0.3);
            }

            .code-block pre {
                margin: 0;
                overflow-x: auto;
            }

            .code-block code {
                color: #c9d1d9;
                line-height: 1.5;
                font-size: 14px;
            }

            .keyword {
                color: #ff7b72;
            }
            .function {
                color: #d2a8ff;
            }
            .comment {
                color: #8b949e;
                font-style: italic;
            }
            .string {
                color: #a5d6ff;
            }
            .number {
                color: #79c0ff;
            }

            /* Mark-and-Compact Visualization Styles */
            .heap-container {
                display: flex;
                width: 100%;
                height: 100%;
                flex-direction: column;
                padding: 15px;
            }

            .heap-memory {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                padding: 15px;
                background: rgba(30, 41, 59, 0.5);
                border-radius: 8px;
                border: 1px solid rgba(99, 102, 241, 0.3);
                min-height: 250px;
                align-content: flex-start;
                position: relative;
            }

            .memory-block {
                width: 60px;
                height: 60px;
                border-radius: 8px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                font-family: "Roboto Mono", monospace;
                font-size: 14px;
                text-align: center;
                transition: all 0.5s ease;
                position: relative;
                overflow: hidden;
                cursor: pointer;
            }

            .block-free {
                background: rgba(148, 163, 184, 0.2);
                border: 1px dashed var(--text-secondary);
            }

            .block-allocated {
                background: var(--accent);
                border: 1px solid var(--accent-light);
                box-shadow: var(--glow);
            }

            .block-reachable {
                background: var(--success);
                border: 1px solid #34d399;
            }

            .block-marked {
                background: var(--warning);
                border: 1px solid #fbbf24;
                animation: pulse 1.5s infinite;
            }

            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.05);
                }
                100% {
                    transform: scale(1);
                }
            }

            .block-compacted {
                background: var(--accent-light);
                border: 2px solid white;
            }

            .block-moving {
                transition: all 1s ease;
                z-index: 10;
            }

            .reference-arrow {
                position: absolute;
                z-index: -1;
                stroke: var(--accent-light);
                stroke-width: 2;
                fill: none;
            }

            .roots-container {
                position: absolute;
                top: 20px;
                left: 20px;
                background: rgba(30, 41, 59, 0.8);
                border-radius: 8px;
                padding: 10px;
                border: 1px solid var(--accent);
            }

            .root-pointer {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: var(--warning);
                margin-bottom: 10px;
                font-size: 12px;
            }

            .status-panel {
                position: absolute;
                bottom: 10px;
                left: 10px;
                right: 10px;
                background: rgba(15, 23, 42, 0.7);
                border-radius: 8px;
                padding: 10px;
                font-size: 14px;
                font-family: "Roboto Mono", monospace;
                text-align: center;
                color: var(--accent-light);
                border: 1px solid rgba(99, 102, 241, 0.3);
            }

            .phase-indicator {
                display: flex;
                justify-content: center;
                gap: 10px;
                margin-top: 10px;
            }

            .phase {
                padding: 5px 10px;
                border-radius: 5px;
                background: rgba(99, 102, 241, 0.2);
                color: var(--text-secondary);
                font-size: 12px;
            }

            .phase.active {
                background: var(--accent);
                color: white;
            }

            .log-entry {
                margin: 5px 0;
                padding: 5px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
                font-size: 12px;
                line-height: 1.4;
            }

            .log-container {
                position: absolute;
                top: 10px;
                right: 10px;
                width: 220px;
                max-height: 150px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 8px;
                padding: 10px;
                font-size: 12px;
                font-family: "Roboto Mono", monospace;
            }

            .compaction-pointer {
                position: absolute;
                width: 20px;
                height: 20px;
                background: var(--warning);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 10px;
                color: white;
                z-index: 5;
            }

            .memory-address {
                font-size: 10px;
                position: absolute;
                bottom: 2px;
                color: rgba(255, 255, 255, 0.7);
            }

            .algorithm-stats {
                display: flex;
                justify-content: space-between;
                padding: 10px;
                background: rgba(30, 41, 59, 0.5);
                border-radius: 8px;
                margin-top: 10px;
                font-size: 14px;
            }

            .stat-item {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .stat-value {
                font-weight: bold;
                color: var(--accent-light);
            }

            .stat-label {
                font-size: 12px;
                color: var(--text-secondary);
            }
        </style>
    </head>
    <body>
        <div class="container">
            <!-- Header -->
            <header>
                <div class="logo">
                    <div class="logo-icon floating">
                        <i class="fas fa-compress-arrows-alt"></i>
                    </div>
                    <div class="logo-text">
                        <h1>AlgoViz Hub</h1>
                        <p>ALGORITHM VISUALIZATION REPOSITORY</p>
                        <div class="breadcrumb">
                            <a href="#"><i class="fas fa-home"></i> Home</a> >
                            <a href="#">Memory Management</a> >
                            <span>Mark-and-Compact GC</span>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Algorithm Header -->
            <div class="algorithm-header">
                <h1>Mark-and-Compact Garbage Collection</h1>
                <div class="category">
                    <i class="fas fa-broom"></i> Compacting Garbage Collection
                    Algorithm
                </div>
                <div class="complexity-badge">
                    Time Complexity: O(n) | Eliminates Fragmentation
                </div>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <!-- Left Column: Algorithm Details -->
                <div class="left-column">
                    <!-- Description Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-file-alt"></i> Algorithm Overview
                        </h2>
                        <p>
                            Mark-and-Compact is a garbage collection algorithm
                            that combines the marking phase of Mark-and-Sweep
                            with a compaction phase that moves all reachable
                            objects to one end of the heap. This process
                            eliminates memory fragmentation, making subsequent
                            allocations faster and more efficient.
                        </p>
                        <p>
                            The algorithm operates in three phases: marking all
                            reachable objects, calculating new locations for
                            these objects, updating all references to point to
                            the new locations, and finally moving the objects.
                            While more complex than Mark-and-Sweep, it provides
                            better memory locality and eliminates fragmentation.
                        </p>

                        <div class="key-points">
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-check-circle"></i> Key
                                    Feature
                                </h3>
                                <p>
                                    Eliminates memory fragmentation by
                                    compacting live objects
                                </p>
                            </div>
                            <div class="point-card">
                                <h3><i class="fas fa-bolt"></i> Performance</h3>
                                <p>
                                    Better memory locality and allocation speed
                                    after compaction
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-memory"></i> Memory Usage
                                </h3>
                                <p>
                                    No additional memory overhead like copying
                                    collectors
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-project-diagram"></i>
                                    Approach
                                </h3>
                                <p>
                                    Mark reachable objects, compute new
                                    locations, update references, move objects
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Visualization Console -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-laptop-code"></i> Interactive
                            Visualization
                        </h2>
                        <p>
                            The visualization below demonstrates the
                            Mark-and-Compact algorithm in action. You can see
                            objects in the heap, some of which are reachable and
                            some are not. The algorithm will mark reachable
                            objects, compute new locations, update references,
                            and finally compact the objects. Use the controls to
                            simulate allocation and trigger garbage collection.
                        </p>

                        <div class="visualization-console">
                            <div class="console-header">
                                <h3>
                                    <i class="fas fa-memory"></i> Heap
                                    Visualization
                                </h3>
                                <div class="console-controls">
                                    <button
                                        class="console-btn secondary"
                                        id="step-btn"
                                    >
                                        <i class="fas fa-step-forward"></i> Step
                                    </button>
                                    <button class="console-btn" id="run-gc-btn">
                                        <i class="fas fa-play"></i> Run GC
                                    </button>
                                    <button
                                        class="console-btn secondary"
                                        id="reset-btn"
                                    >
                                        <i class="fas fa-redo"></i> Reset
                                    </button>
                                </div>
                            </div>

                            <div
                                class="visualization-area"
                                id="gc-visualization"
                            >
                                <!-- Visualization will be rendered here by JavaScript -->
                                <div class="heap-container" id="heap-container">
                                    <div
                                        class="heap-memory"
                                        id="heap-memory"
                                    ></div>
                                    <div class="algorithm-stats">
                                        <div class="stat-item">
                                            <span
                                                class="stat-value"
                                                id="total-objects"
                                                >0</span
                                            >
                                            <span class="stat-label"
                                                >Total Objects</span
                                            >
                                        </div>
                                        <div class="stat-item">
                                            <span
                                                class="stat-value"
                                                id="reachable-objects"
                                                >0</span
                                            >
                                            <span class="stat-label"
                                                >Reachable</span
                                            >
                                        </div>
                                        <div class="stat-item">
                                            <span
                                                class="stat-value"
                                                id="free-space"
                                                >0</span
                                            >
                                            <span class="stat-label"
                                                >Free Space</span
                                            >
                                        </div>
                                        <div class="stat-item">
                                            <span
                                                class="stat-value"
                                                id="fragmentation"
                                                >0%</span
                                            >
                                            <span class="stat-label"
                                                >Fragmentation</span
                                            >
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="console-input">
                                <button class="console-btn" id="allocate-btn">
                                    <i class="fas fa-plus-circle"></i> Allocate
                                    Object
                                </button>
                                <button class="console-btn" id="create-ref-btn">
                                    <i class="fas fa-link"></i> Create Reference
                                </button>
                                <button
                                    class="console-btn secondary"
                                    id="null-ref-btn"
                                >
                                    <i class="fas fa-unlink"></i> Nullify
                                    Reference
                                </button>
                                <button
                                    class="console-btn secondary"
                                    id="fragment-btn"
                                >
                                    <i class="fas fa-puzzle-piece"></i> Fragment
                                    Heap
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Algorithm Steps -->
                    <div class="section">
                        <h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
                        <p>
                            The Mark-and-Compact garbage collection algorithm
                            operates through these key phases:
                        </p>

                        <div class="key-points">
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-pause"></i> 1. Stop The
                                    World
                                </h3>
                                <p>
                                    Pause program execution to ensure memory
                                    consistency during collection
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-search"></i> 2. Mark Phase
                                </h3>
                                <p>
                                    Traverse object graph starting from root
                                    pointers, mark each reachable object
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-calculator"></i> 3. Compute
                                    New Locations
                                </h3>
                                <p>
                                    Calculate where each live object will be
                                    moved during compaction
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-sync-alt"></i> 4. Update
                                    References
                                </h3>
                                <p>
                                    Update all references to point to the new
                                    object locations
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-arrows-alt-h"></i> 5.
                                    Compact Objects
                                </h3>
                                <p>
                                    Move objects to their new locations,
                                    compacting all live data
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-play"></i> 6. Resume
                                    Execution
                                </h3>
                                <p>
                                    Resume program execution with a compacted,
                                    defragmented heap
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Pseudocode Section -->
                    <div class="section">
                        <h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Mark-and-Compact Algorithm</span>
                                <button class="copy-btn">
                                    <i class="fas fa-copy"></i> Copy Code
                                </button>
                            </div>
                            <pre><code>// Mark-and-Compact Garbage Collection
function collectGarbage():
  stopTheWorld()  // Pause all mutator threads

  // Mark phase: identify reachable objects
  markFromRoots()

  // Calculate new locations for objects
  computeNewLocations()

  // Update all references to new locations
  updateReferences()

  // Move objects to new locations
  moveObjects()

  resumeExecution()  // Resume mutator threads

// Mark all reachable objects from roots
function markFromRoots():
  for each root in roots:
    mark(root)

function mark(object):
  if object is not marked:
    setMarked(object)
    for each reference in object.references:
      mark(reference)

// Calculate where objects will be moved
function computeNewLocations():
  newAddress = heapStart
  for each object in heap:
    if object is marked:
      object.newAddress = newAddress
      newAddress += size(object)

// Update all references to new addresses
function updateReferences():
  for each object in heap:
    if object is marked:
      for each reference in object.references:
        reference = referencedObject.newAddress

// Move objects to their new locations
function moveObjects():
  for each object in heap:
    if object is marked:
      copy object to object.newAddress
      unmark(object)  // For next GC cycle</code></pre>
                        </div>
                    </div>

                    <!-- Implementation Section -->
                    <div class="section">
                        <h2><i class="fas fa-code"></i> Implementation</h2>
                        <p>
                            Below is a simplified Python implementation of the
                            Mark-and-Compact garbage collector. This example
                            demonstrates the core algorithm with object
                            representation and reference management.
                        </p>

                        <div class="code-block">
                            <div class="code-header">
                                <span>Python Implementation</span>
                                <button class="copy-btn">
                                    <i class="fas fa-copy"></i> Copy Code
                                </button>
                            </div>
                            <pre><code><span class="keyword">class</span> <span class="function">GCObject</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, size=1):
        <span class="keyword">self</span>.marked = <span class="keyword">False</span>
        <span class="keyword">self</span>.size = size
        <span class="keyword">self</span>.references = []
        <span class="keyword">self</span>.new_address = <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">add_reference</span>(<span class="keyword">self</span>, obj):
        <span class="keyword">self</span>.references.append(obj)

<span class="keyword">class</span> <span class="function">MarkCompactGC</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, heap_size):
        <span class="keyword">self</span>.heap = [<span class="keyword">None</span>] * heap_size
        <span class="keyword">self</span>.roots = []
        <span class="keyword">self</span>.free_ptr = 0

    <span class="keyword">def</span> <span class="function">allocate</span>(<span class="keyword">self</span>, obj):
        <span class="comment"># Find free space for object</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(<span class="keyword">self</span>.heap)):
            <span class="keyword">if</span> <span class="keyword">self</span>.heap[i] <span class="keyword">is</span> <span class="keyword">None</span>:
                <span class="keyword">self</span>.heap[i] = obj
                <span class="keyword">return</span> i
        <span class="keyword">raise</span> MemoryError(<span class="string">"Out of memory"</span>)

    <span class="keyword">def</span> <span class="function">add_root</span>(<span class="keyword">self</span>, obj_index):
        <span class="keyword">self</span>.roots.append(obj_index)

    <span class="keyword">def</span> <span class="function">collect</span>(<span class="keyword">self</span>):
        <span class="comment"># Mark phase</span>
        <span class="keyword">self</span>.mark()

        <span class="comment"># Compact phase</span>
        <span class="keyword">self</span>.compact()

    <span class="keyword">def</span> <span class="function">mark</span>(<span class="keyword">self</span>):
        <span class="comment"># Mark all reachable objects from roots</span>
        <span class="keyword">for</span> root_index <span class="keyword">in</span> <span class="keyword">self</span>.roots:
            <span class="keyword">self</span>.mark_object(root_index)

    <span class="keyword">def</span> <span class="function">mark_object</span>(<span class="keyword">self</span>, obj_index):
        <span class="keyword">if</span> obj_index <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> <span class="keyword">self</span>.heap[obj_index] <span class="keyword">is</span> <span class="keyword">None</span>:
            <span class="keyword">return</span>

        obj = <span class="keyword">self</span>.heap[obj_index]
        <span class="keyword">if</span> <span class="keyword">not</span> obj.marked:
            obj.marked = <span class="keyword">True</span>
            <span class="keyword">for</span> ref_index <span class="keyword">in</span> obj.references:
                <span class="keyword">self</span>.mark_object(ref_index)

    <span class="keyword">def</span> <span class="function">compact</span>(<span class="keyword">self</span>):
        <span class="comment"># Calculate new addresses</span>
        new_address = 0
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(<span class="keyword">self</span>.heap)):
            <span class="keyword">if</span> <span class="keyword">self</span>.heap[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">self</span>.heap[i].marked:
                <span class="keyword">self</span>.heap[i].new_address = new_address
                new_address += <span class="keyword">self</span>.heap[i].size

        <span class="comment"># Update references</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(<span class="keyword">self</span>.heap)):
            <span class="keyword">if</span> <span class="keyword">self</span>.heap[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">self</span>.heap[i].marked:
                obj = <span class="keyword">self</span>.heap[i]
                <span class="keyword">for</span> j <span class="keyword">in</span> range(len(obj.references)):
                    <span class="keyword">if</span> obj.references[j] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
                        ref_obj = <span class="keyword">self</span>.heap[obj.references[j]]
                        <span class="keyword">if</span> ref_obj <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
                            obj.references[j] = ref_obj.new_address

        <span class="comment"># Move objects and update roots</span>
        new_heap = [<span class="keyword">None</span>] * len(<span class="keyword">self</span>.heap)
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(<span class="keyword">self</span>.heap)):
            <span class="keyword">if</span> <span class="keyword">self</span>.heap[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">self</span>.heap[i].marked:
                obj = <span class="keyword">self</span>.heap[i]
                new_heap[obj.new_address] = obj
                obj.marked = <span class="keyword">False</span>  <span class="comment"># Reset for next GC</span>

        <span class="comment"># Update root references</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(<span class="keyword">self</span>.roots)):
            <span class="keyword">if</span> <span class="keyword">self</span>.roots[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
                obj = <span class="keyword">self</span>.heap[self.roots[i]]
                <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
                    <span class="keyword">self</span>.roots[i] = obj.new_address

        <span class="keyword">self</span>.heap = new_heap
        <span class="keyword">self</span>.free_ptr = new_address

<span class="comment"># Example usage</span>
gc = MarkCompactGC(<span class="number">20</span>)

<span class="comment"># Create and allocate objects</span>
obj1 = GCObject()
obj2 = GCObject()
obj3 = GCObject()

idx1 = gc.allocate(obj1)
idx2 = gc.allocate(obj2)
idx3 = gc.allocate(obj3)

<span class="comment"># Set up references</span>
obj1.add_reference(idx2)
obj2.add_reference(idx3)

<span class="comment"># Add roots</span>
gc.add_root(idx1)

<span class="comment"># Run garbage collection</span>
gc.collect()</code></pre>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Additional Info -->
                <div class="right-column">
                    <!-- Properties Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-info-circle"></i> Algorithm
                            Properties
                        </h2>
                        <div class="properties-grid">
                            <div class="property-card">
                                <h4>Category</h4>
                                <div class="value">Compacting GC</div>
                            </div>
                            <div class="property-card">
                                <h4>Type</h4>
                                <div class="value">Tracing</div>
                            </div>
                            <div class="property-card">
                                <h4>Fragmentation</h4>
                                <div class="value">None</div>
                            </div>
                            <div class="property-card">
                                <h4>Pause Time</h4>
                                <div class="value">Medium-High</div>
                            </div>
                            <div class="property-card">
                                <h4>Throughput</h4>
                                <div class="value">Medium</div>
                            </div>
                            <div class="property-card">
                                <h4>Memory Overhead</h4>
                                <div class="value">Low</div>
                            </div>
                            <div class="property-card">
                                <h4>Complexity</h4>
                                <div class="value">O(n)</div>
                            </div>
                            <div class="property-card">
                                <h4>Allocation</h4>
                                <div class="value">Pointer Bump</div>
                            </div>
                        </div>
                    </div>

                    <!-- Applications Section -->
                    <div class="section">
                        <h2><i class="fas fa-lightbulb"></i> Applications</h2>
                        <p>
                            Mark-and-Compact is used in various systems and
                            languages:
                        </p>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                .NET CLR (as part of generational GC)
                            </li>
                            <li style="margin-bottom: 10px">
                                JavaScript engines (V8, SpiderMonkey)
                            </li>
                            <li style="margin-bottom: 10px">
                                JVM implementations
                            </li>
                            <li style="margin-bottom: 10px">
                                Real-time systems requiring predictable
                                allocation
                            </li>
                            <li>Embedded systems with limited memory</li>
                            <li>
                                Applications with long runtimes and
                                fragmentation issues
                            </li>
                        </ul>
                    </div>

                    <!-- Advantages Section -->
                    <div class="section">
                        <h2><i class="fas fa-star"></i> Key Advantages</h2>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                <strong>No Fragmentation:</strong> Eliminates
                                memory fragmentation completely
                            </li>
                            <li style="margin-bottom: 10px">
                                <strong>Fast Allocation:</strong> Simple pointer
                                bump allocation after compaction
                            </li>
                            <li style="margin-bottom: 10px">
                                <strong>Memory Efficiency:</strong> No memory
                                overhead like copying collectors
                            </li>
                            <li style="margin-bottom: 10px">
                                <strong>Cache Performance:</strong> Better
                                locality of reference
                            </li>
                            <li>
                                <strong>Predictable:</strong> Works well for
                                real-time systems
                            </li>
                        </ul>
                    </div>

                    <!-- Disadvantages Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-exclamation-triangle"></i>
                            Limitations
                        </h2>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                Longer pause times compared to non-compacting
                                collectors
                            </li>
                            <li style="margin-bottom: 10px">
                                More complex implementation than Mark-and-Sweep
                            </li>
                            <li style="margin-bottom: 10px">
                                Requires multiple passes over the heap
                            </li>
                            <li>Higher CPU overhead during collection</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <footer>
                <div class="footer-links">
                    <a href="#"
                        ><i class="fa-brands fa-linkedin"></i> LinkedIN</a
                    >
                    <a href="#"><i class="fa-solid fa-at"></i> E-Mail</a>
                    <a href="#"
                        ><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a
                    >
                </div>
                <p>
                    AlgoViz Hub - Interactive Algorithm Visualization Platform
                </p>
                <p>&copy; 2025 AlgoViz Hub. All rights reserved.</p>
            </footer>
        </div>

        <script>
            // Visualization for Mark-and-Compact Garbage Collection
            document.addEventListener("DOMContentLoaded", function () {
                const visualization =
                    document.getElementById("gc-visualization");
                const heapMemory = document.getElementById("heap-memory");
                const allocateBtn = document.getElementById("allocate-btn");
                const runGcBtn = document.getElementById("run-gc-btn");
                const resetBtn = document.getElementById("reset-btn");
                const createRefBtn = document.getElementById("create-ref-btn");
                const nullRefBtn = document.getElementById("null-ref-btn");
                const fragmentBtn = document.getElementById("fragment-btn");

                // State variables
                let objects = [];
                let roots = [];
                let references = [];
                let selectedObject = null;
                let heapSize = 16; // Number of memory blocks
                let currentPhase = 0;

                // Initialize visualization
                function initVisualization() {
                    heapMemory.innerHTML = "";
                    objects = [];
                    references = [];
                    roots = [];
                    selectedObject = null;
                    currentPhase = 0;

                    // Create heap memory blocks
                    for (let i = 0; i < heapSize; i++) {
                        const block = document.createElement("div");
                        block.className = "memory-block block-free";
                        block.innerHTML = `Free<div class="memory-address">${i}</div>`;
                        block.dataset.index = i;
                        heapMemory.appendChild(block);
                    }

                    // Create log container
                    const logContainer = document.createElement("div");
                    logContainer.className = "log-container";
                    logContainer.id = "log-container";
                    visualization.appendChild(logContainer);

                    // Create status panel
                    const statusPanel = document.createElement("div");
                    statusPanel.className = "status-panel";
                    statusPanel.id = "status-panel";
                    statusPanel.innerHTML = "System Status: Initialized";
                    visualization.appendChild(statusPanel);

                    // Create 2 root objects
                    roots = [createObject(), createObject()];
                    roots[0].element.textContent = "Root 1";
                    roots[1].element.textContent = "Root 2";

                    // Create some additional objects with references
                    const obj1 = createObject();
                    const obj2 = createObject();
                    const obj3 = createObject();

                    createReference(roots[0], obj1);
                    createReference(roots[0], obj2);
                    createReference(obj1, obj3);

                    // Create some garbage (unreachable objects)
                    createObject();
                    createObject();

                    updateStats();
                    logEvent("Initialized heap with objects and references");
                    updateStatus(
                        "Ready - Heap contains objects and references",
                    );
                }

                // Create a new object
                function createObject() {
                    // Find a free block
                    const freeBlocks = Array.from(heapMemory.children).filter(
                        (block) => block.classList.contains("block-free"),
                    );

                    if (freeBlocks.length === 0) {
                        logEvent("Cannot allocate object: heap full");
                        return null;
                    }

                    // Select a random free block
                    const randomIndex = Math.floor(
                        Math.random() * freeBlocks.length,
                    );
                    const block = freeBlocks[randomIndex];
                    const index = parseInt(block.dataset.index);

                    const object = {
                        id: objects.length,
                        index: index,
                        marked: false,
                        compacted: false,
                        references: [],
                        element: block,
                        newIndex: null,
                    };

                    block.className = "memory-block block-allocated";
                    block.innerHTML = `Obj ${object.id}<div class="memory-address">${index}</div>`;
                    block.dataset.objId = object.id;
                    objects.push(object);

                    logEvent(
                        `Allocated new object: ${object.id} at position ${index}`,
                    );
                    updateStatus(`Allocated object ${object.id}`);
                    updateStats();

                    return object;
                }

                // Create a reference between objects
                function createReference(from, to) {
                    if (from === to || !from || !to) return;

                    // Check if reference already exists
                    if (from.references.includes(to)) return;

                    from.references.push(to);

                    logEvent(`Created reference from ${from.id} to ${to.id}`);
                }

                // Select an object for reference creation
                function selectObject(object) {
                    if (selectedObject === null) {
                        selectedObject = object;
                        object.element.style.border = "2px solid white";
                        logEvent(
                            `Selected object ${object.id} as reference source`,
                        );
                        updateStatus(
                            `Select target object for reference from ${object.id}`,
                        );
                    } else if (selectedObject === object) {
                        selectedObject.element.style.border = "";
                        selectedObject = null;
                    } else {
                        createReference(selectedObject, object);
                        selectedObject.element.style.border = "";
                        selectedObject = null;
                    }
                }

                // Nullify a random reference
                function nullifyRandomReference() {
                    const objectsWithRefs = objects.filter(
                        (obj) => obj.references.length > 0,
                    );
                    if (objectsWithRefs.length === 0) return;

                    const from =
                        objectsWithRefs[
                            Math.floor(Math.random() * objectsWithRefs.length)
                        ];
                    const refIndex = Math.floor(
                        Math.random() * from.references.length,
                    );
                    const to = from.references[refIndex];

                    // Remove reference
                    from.references.splice(refIndex, 1);

                    logEvent(`Nullified reference from ${from.id} to ${to.id}`);
                    updateStatus(
                        `Reference from ${from.id} to ${to.id} removed`,
                    );
                }

                // Fragment the heap by creating gaps
                function fragmentHeap() {
                    // Free some random objects to create gaps
                    const objectsToFree = objects.filter(
                        (obj) =>
                            !roots.includes(obj) &&
                            obj.references.length === 0 &&
                            Math.random() > 0.5,
                    );

                    if (objectsToFree.length === 0) return;

                    objectsToFree.forEach((obj) => {
                        // Free the object
                        obj.element.className = "memory-block block-free";
                        obj.element.innerHTML = `Free<div class="memory-address">${obj.index}</div>`;
                        obj.element.removeAttribute("data-obj-id");

                        // Remove from objects array
                        objects = objects.filter((o) => o !== obj);

                        // Remove any references to this object
                        objects.forEach((o) => {
                            o.references = o.references.filter(
                                (ref) => ref !== obj,
                            );
                        });
                    });

                    logEvent(
                        `Fragmented heap by freeing ${objectsToFree.length} objects`,
                    );
                    updateStatus(
                        `Heap fragmented with ${objectsToFree.length} free blocks`,
                    );
                    updateStats();
                }

                // Run garbage collection
                function runGarbageCollection() {
                    logEvent("Starting Mark-and-Compact GC...");
                    updateStatus("GC: Stopping program execution");
                    currentPhase = 1;
                    highlightPhase(0);

                    // Mark phase
                    setTimeout(() => {
                        logEvent("Starting mark phase");
                        updateStatus("GC: Marking reachable objects");
                        highlightPhase(1);

                        // Reset marks
                        objects.forEach((obj) => {
                            obj.marked = false;
                            obj.element.classList.remove(
                                "block-marked",
                                "block-reachable",
                            );
                        });

                        // Mark from roots
                        let markedCount = 0;
                        function markNextRoot() {
                            if (markedCount < roots.length) {
                                markObject(roots[markedCount]);
                                markedCount++;
                                setTimeout(markNextRoot, 800);
                            } else {
                                // Proceed to compute new locations
                                setTimeout(computeNewLocations, 1000);
                            }
                        }

                        markNextRoot();
                    }, 1000);
                }

                // Recursively mark an object and its references
                function markObject(obj) {
                    if (obj.marked) return;

                    obj.marked = true;
                    obj.element.classList.remove("block-allocated");
                    obj.element.classList.add("block-marked");
                    logEvent(`Marked object ${obj.id}`);

                    // Mark references
                    obj.references.forEach((ref) => {
                        markObject(ref);
                    });
                }

                // Compute new locations for objects
                function computeNewLocations() {
                    logEvent("Computing new locations for objects");
                    updateStatus("GC: Computing new locations");
                    highlightPhase(2);

                    // Sort objects by current index
                    const sortedObjects = [...objects].sort(
                        (a, b) => a.index - b.index,
                    );
                    let newIndex = 0;

                    sortedObjects.forEach((obj) => {
                        if (obj.marked) {
                            obj.newIndex = newIndex;
                            newIndex++;
                            logEvent(
                                `Object ${obj.id} will move to position ${newIndex}`,
                            );
                        }
                    });

                    // Proceed to update references
                    setTimeout(updateReferences, 1000);
                }

                // Update references to new locations
                function updateReferences() {
                    logEvent("Updating references to new locations");
                    updateStatus("GC: Updating references");
                    highlightPhase(3);

                    // For visualization purposes, we'll just log the reference updates
                    objects.forEach((obj) => {
                        if (obj.marked) {
                            obj.references.forEach((ref) => {
                                logEvent(
                                    `Reference from object ${obj.id} to object ${ref.id} will be updated`,
                                );
                            });
                        }
                    });

                    // Proceed to move objects
                    setTimeout(moveObjects, 1000);
                }

                // Move objects to their new locations
                function moveObjects() {
                    logEvent("Moving objects to new locations");
                    updateStatus("GC: Compacting objects");
                    highlightPhase(4);

                    // Sort objects by new index
                    const objectsToMove = objects.filter(
                        (obj) => obj.marked && obj.newIndex !== null,
                    );
                    objectsToMove.sort((a, b) => a.newIndex - b.newIndex);

                    let movedCount = 0;

                    function moveNextObject() {
                        if (movedCount < objectsToMove.length) {
                            const obj = objectsToMove[movedCount];

                            // Clear old position
                            obj.element.className = "memory-block block-free";
                            obj.element.innerHTML = `Free<div class="memory-address">${obj.index}</div>`;

                            // Update object index
                            obj.index = obj.newIndex;
                            obj.compacted = true;

                            // Move to new position
                            const newBlock = heapMemory.children[obj.index];
                            newBlock.className = "memory-block block-compacted";
                            newBlock.innerHTML = `Obj ${obj.id}<div class="memory-address">${obj.index}</div>`;
                            newBlock.dataset.objId = obj.id;
                            obj.element = newBlock;

                            logEvent(
                                `Moved object ${obj.id} to position ${obj.index}`,
                            );
                            movedCount++;

                            setTimeout(moveNextObject, 800);
                        } else {
                            // GC complete
                            setTimeout(() => {
                                logEvent("Garbage collection completed");
                                updateStatus(
                                    "GC: Completed, resuming program execution",
                                );
                                highlightPhase(5);

                                // Reset object states
                                objects.forEach((obj) => {
                                    obj.marked = false;
                                    obj.newIndex = null;
                                    if (obj.compacted) {
                                        obj.element.classList.remove(
                                            "block-compacted",
                                        );
                                        obj.element.classList.add(
                                            "block-allocated",
                                        );
                                        obj.compacted = false;
                                    }
                                });

                                setTimeout(() => {
                                    highlightPhase(0);
                                    updateStatus(
                                        "Program resumed with compacted heap",
                                    );
                                    updateStats();
                                }, 1500);
                            }, 1000);
                        }
                    }

                    moveNextObject();
                }

                // Update statistics
                function updateStats() {
                    const totalObjects = objects.length;
                    const reachableObjects = objects.filter(
                        (obj) =>
                            roots.includes(obj) ||
                            objects.some((o) => o.references.includes(obj)),
                    ).length;
                    const freeSpace = heapSize - totalObjects;
                    const fragmentation = calculateFragmentation();

                    document.getElementById("total-objects").textContent =
                        totalObjects;
                    document.getElementById("reachable-objects").textContent =
                        reachableObjects;
                    document.getElementById("free-space").textContent =
                        freeSpace;
                    document.getElementById("fragmentation").textContent =
                        `${fragmentation}%`;
                }

                // Calculate heap fragmentation
                function calculateFragmentation() {
                    if (objects.length === 0) return 0;

                    // Get all used indices
                    const usedIndices = objects
                        .map((obj) => obj.index)
                        .sort((a, b) => a - b);

                    // Calculate gaps between used blocks
                    let totalGaps = 0;
                    for (let i = 1; i < usedIndices.length; i++) {
                        const gap = usedIndices[i] - usedIndices[i - 1] - 1;
                        if (gap > 0) {
                            totalGaps += gap;
                        }
                    }

                    // Calculate fragmentation percentage
                    const fragmentation =
                        (totalGaps / (heapSize - objects.length)) * 100;
                    return Math.round(fragmentation);
                }

                // Log event to log container
                function logEvent(message) {
                    const logContainer =
                        document.getElementById("log-container");
                    if (!logContainer) return;

                    const logEntry = document.createElement("div");
                    logEntry.className = "log-entry";
                    logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                    logContainer.appendChild(logEntry);

                    // Auto-scroll
                    logContainer.scrollTop = logContainer.scrollHeight;
                }

                // Update status panel
                function updateStatus(status) {
                    const statusPanel = document.getElementById("status-panel");
                    if (!statusPanel) return;

                    statusPanel.innerHTML = `System Status: ${status}`;

                    const phaseIndicator = document.createElement("div");
                    phaseIndicator.className = "phase-indicator";
                    phaseIndicator.innerHTML = `
            <div class="phase">Stopped</div>
            <div class="phase">Mark</div>
            <div class="phase">Compute</div>
            <div class="phase">Update</div>
            <div class="phase">Compact</div>
            <div class="phase">Resume</div>
          `;
                    statusPanel.appendChild(phaseIndicator);
                }

                // Highlight current phase
                function highlightPhase(index) {
                    const phases = document.querySelectorAll(".phase");
                    phases.forEach((phase, i) => {
                        if (i === index) {
                            phase.classList.add("active");
                        } else {
                            phase.classList.remove("active");
                        }
                    });
                }

                // Event listeners
                allocateBtn.addEventListener("click", createObject);
                runGcBtn.addEventListener("click", runGarbageCollection);
                createRefBtn.addEventListener("click", () => {
                    if (selectedObject) {
                        selectedObject.element.style.border = "";
                        selectedObject = null;
                    }
                    updateStatus("Select source object for new reference");
                });
                nullRefBtn.addEventListener("click", nullifyRandomReference);
                fragmentBtn.addEventListener("click", fragmentHeap);
                resetBtn.addEventListener("click", initVisualization);

                // Add click event to memory blocks
                heapMemory.addEventListener("click", (e) => {
                    const block = e.target.closest(".memory-block");
                    if (!block) return;

                    const objId = block.dataset.objId;
                    if (objId) {
                        const object = objects.find((obj) => obj.id == objId);
                        if (object) {
                            selectObject(object);
                        }
                    }
                });

                // Initialize the visualization
                initVisualization();

                // Copy button functionality
                document
                    .querySelector(".copy-btn")
                    .addEventListener("click", function () {
                        const code =
                            document.querySelector(
                                ".code-block code",
                            ).innerText;
                        navigator.clipboard.writeText(code);

                        const originalText = this.innerHTML;
                        this.innerHTML = '<i class="fas fa-check"></i> Copied!';

                        setTimeout(() => {
                            this.innerHTML = originalText;
                        }, 2000);
                    });
            });
        </script>
    </body>
</html>
