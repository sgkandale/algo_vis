<!doctype html>
<html lang="en">
    <head>
        <meta
            content="Interactive visualization of the Anti-Entropy Gossip Protocol for distributed systems"
            name="description"
        />
        <meta
            content="gossip protocol, anti-entropy, distributed systems, consistency, fault tolerance, visualization, interactive"
            name="keywords"
        />
        <meta charset="utf-8" />
        <meta content="width=device-width, initial-scale=1.0" name="viewport" />
        <title>Anti-Entropy Gossip Protocol | AlgoViz Hub</title>
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
            rel="stylesheet"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap"
            rel="stylesheet"
        />
        <style>
            :root {
                --primary: #0f172a;
                --secondary: #1e293b;
                --accent: #6366f1;
                --accent-light: #818cf8;
                --accent-glow: rgba(99, 102, 241, 0.2);
                --text: #e2e8f0;
                --text-secondary: #94a3b8;
                --card-bg: rgba(30, 41, 59, 0.7);
                --success: #10b981;
                --warning: #f59e0b;
                --danger: #ef4444;
                --transition: all 0.3s ease;
                --radius: 12px;
                --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                --glow: 0 0 15px var(--accent-glow);
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background: linear-gradient(
                    135deg,
                    var(--primary),
                    var(--secondary)
                );
                color: var(--text);
                font-family: "Roboto", sans-serif;
                line-height: 1.6;
                min-height: 100vh;
                padding: 0;
                position: relative;
                overflow-x: hidden;
            }

            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background:
                    radial-gradient(
                        circle at 10% 20%,
                        rgba(99, 102, 241, 0.1) 0%,
                        transparent 20%
                    ),
                    radial-gradient(
                        circle at 90% 80%,
                        rgba(129, 140, 248, 0.1) 0%,
                        transparent 20%
                    );
                z-index: -1;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }

            /* Header Styles */
            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px 0;
                position: relative;
                border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            }

            .logo {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .logo-icon {
                width: 50px;
                height: 50px;
                background: var(--accent);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: var(--glow);
            }

            .logo-icon i {
                font-size: 24px;
                color: white;
            }

            .logo-text h1 {
                font-family: "Roboto Mono", monospace;
                font-weight: 700;
                font-size: 28px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }

            .logo-text p {
                font-size: 14px;
                color: var(--text-secondary);
                letter-spacing: 1.5px;
            }

            .breadcrumb {
                font-size: 14px;
                color: var(--text-secondary);
                margin-top: 10px;
            }

            .breadcrumb a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .breadcrumb a:hover {
                text-decoration: underline;
            }

            /* Algorithm Header */
            .algorithm-header {
                margin: 40px 0;
                text-align: center;
                padding: 20px;
                background: var(--card-bg);
                border-radius: var(--radius);
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .algorithm-header::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .algorithm-header h1 {
                font-size: 42px;
                margin-bottom: 15px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                font-weight: 800;
            }

            .algorithm-header .category {
                font-size: 18px;
                color: var(--accent-light);
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

            .complexity-badge {
                display: inline-block;
                background: rgba(129, 140, 248, 0.2);
                color: var(--accent-light);
                padding: 6px 15px;
                border-radius: 20px;
                font-size: 16px;
                font-weight: 600;
                font-family: "Roboto Mono", monospace;
                margin-top: 15px;
            }

            /* Main Content Layout */
            .main-content {
                display: grid;
                grid-template-columns: 1fr 350px;
                gap: 30px;
                margin-bottom: 40px;
            }

            @media (max-width: 900px) {
                .main-content {
                    grid-template-columns: 1fr;
                }
            }

            /* Algorithm Detail Sections */
            .section {
                background: var(--card-bg);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                padding: 30px;
                margin-bottom: 30px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .section::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .section h2 {
                font-size: 26px;
                margin-bottom: 20px;
                color: var(--accent-light);
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .section h2 i {
                color: var(--accent);
                width: 36px;
                height: 36px;
                background: rgba(99, 102, 241, 0.2);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .section p {
                color: var(--text-secondary);
                font-size: 17px;
                line-height: 1.8;
                margin-bottom: 20px;
            }

            .key-points {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 20px;
                margin: 25px 0;
            }

            .point-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
            }

            .point-card h3 {
                color: var(--accent-light);
                margin-bottom: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .point-card h3 i {
                color: var(--accent);
            }

            .point-card p {
                margin-bottom: 0;
                font-size: 15px;
            }

            /* Visualization Console */
            .visualization-console {
                background: rgba(15, 23, 42, 0.8);
                border-radius: var(--radius);
                padding: 25px;
                margin: 30px 0;
                border: 1px solid rgba(99, 102, 241, 0.3);
                box-shadow: var(--glow);
            }

            .console-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }

            .console-header h3 {
                color: var(--accent-light);
                font-size: 20px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .console-controls {
                display: flex;
                gap: 10px;
            }

            .console-btn {
                background: var(--accent);
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .console-btn:hover {
                background: var(--accent-light);
            }

            .console-btn.secondary {
                background: rgba(148, 163, 184, 0.2);
            }

            .visualization-area {
                height: 300px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
                overflow: hidden;
            }

            .visualization-area::before {
                content: "Gossip Protocol Visualization";
                position: absolute;
                color: rgba(148, 163, 184, 0.5);
                font-size: 20px;
            }

            .console-input {
                display: flex;
                gap: 10px;
                margin-top: 20px;
            }

            .console-input input {
                flex: 1;
                padding: 12px 15px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(148, 163, 184, 0.2);
                border-radius: 5px;
                color: var(--text);
                font-family: "Roboto Mono", monospace;
            }

            .console-input input:focus {
                outline: none;
                border-color: var(--accent);
            }

            /* Algorithm Properties */
            .properties-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }

            .property-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                text-align: center;
            }

            .property-card h4 {
                color: var(--text-secondary);
                font-size: 14px;
                margin-bottom: 8px;
                font-weight: 400;
            }

            .property-card .value {
                font-size: 20px;
                font-weight: 700;
                color: var(--accent-light);
                font-family: "Roboto Mono", monospace;
            }

            /* Footer */
            footer {
                text-align: center;
                padding: 40px 0 30px;
                color: var(--text-secondary);
                font-size: 14px;
                border-top: 1px solid rgba(148, 163, 184, 0.1);
                margin-top: 40px;
            }

            footer p {
                margin: 10px 0;
            }

            .footer-links {
                display: flex;
                justify-content: center;
                gap: 25px;
                margin-top: 15px;
                flex-wrap: wrap;
                margin-bottom: 20px;
            }

            .footer-links a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .footer-links a:hover {
                color: var(--accent);
            }

            /* Animations */
            @keyframes float {
                0% {
                    transform: translateY(0px);
                }
                50% {
                    transform: translateY(-10px);
                }
                100% {
                    transform: translateY(0px);
                }
            }

            .floating {
                animation: float 6s ease-in-out infinite;
            }

            /* Responsive Design */
            @media (max-width: 768px) {
                header {
                    flex-direction: column;
                    gap: 25px;
                    text-align: center;
                }

                .algorithm-header h1 {
                    font-size: 32px;
                }

                .key-points {
                    grid-template-columns: 1fr;
                }
            }

            /* Code Block Styling */
            .code-block {
                background: #0d1117;
                border-radius: 8px;
                padding: 20px;
                margin: 25px 0;
                overflow-x: auto;
                font-family: "Roboto Mono", monospace;
                font-size: 15px;
                border: 1px solid rgba(99, 102, 241, 0.3);
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                color: var(--text-secondary);
            }

            .copy-btn {
                background: rgba(99, 102, 241, 0.2);
                color: var(--accent-light);
                border: none;
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .copy-btn:hover {
                background: rgba(99, 102, 241, 0.3);
            }

            .code-block pre {
                margin: 0;
            }

            .code-block code {
                color: #c9d1d9;
                line-height: 1.5;
            }

            .keyword {
                color: #ff7b72;
            }
            .function {
                color: #d2a8ff;
            }
            .comment {
                color: #8b949e;
            }
            .string {
                color: #a5d6ff;
            }
            .number {
                color: #79c0ff;
            }

            /* Node visualization styles */
            .node {
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: var(--accent);
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                position: absolute;
                box-shadow: var(--glow);
                transition: all 0.5s ease;
            }

            .node-connection {
                position: absolute;
                height: 2px;
                background: rgba(129, 140, 248, 0.5);
                transform-origin: 0 0;
                z-index: -1;
            }

            .gossip-message {
                position: absolute;
                background: var(--success);
                color: white;
                padding: 5px 10px;
                border-radius: 20px;
                font-size: 12px;
                opacity: 0;
                transition: all 0.5s ease;
            }
        </style>
        <meta
            content="Anti-Entropy Gossip Protocol | AlgoViz Hub"
            property="og:title"
        />
        <meta
            content="Interactive visualization of the Anti-Entropy Gossip Protocol for distributed systems"
            property="og:description"
        />
        <meta content="article" property="og:type" />
        <meta
            content="https://sgkandale.github.io/anti-entropy-gossip.html"
            property="og:url"
        />
        <meta content="AlgoViz Hub" property="og:site_name" />
        <meta content="summary" name="twitter:card" />
        <meta
            content="Anti-Entropy Gossip Protocol | AlgoViz Hub"
            name="twitter:title"
        />
        <meta
            content="Interactive visualization of the Anti-Entropy Gossip Protocol for distributed systems"
            name="twitter:description"
        />
        <meta content="@sgkandale" name="twitter:site" />
        <link
            href="https://sgkandale.github.io/anti-entropy-gossip.html"
            rel="canonical"
        />
        <script type="application/ld+json">
            {
                "@context": "https://schema.org",
                "@type": "Article",
                "headline": "Anti-Entropy Gossip Protocol | AlgoViz Hub",
                "description": "Interactive visualization of the Anti-Entropy Gossip Protocol for distributed systems",
                "author": {
                    "@type": "Person",
                    "name": "Shantanu Kandale"
                },
                "publisher": {
                    "@type": "Organization",
                    "name": "AlgoViz Hub",
                    "logo": {
                        "@type": "ImageObject",
                        "url": "https://sgkandale.github.io/favicon.ico"
                    }
                },
                "mainEntityOfPage": {
                    "@type": "WebPage",
                    "@id": "https://sgkandale.github.io/anti-entropy-gossip.html"
                }
            }
        </script>
    </head>
    <body>
        <div class="container">
            <!-- Header -->
            <header>
                <div class="logo">
                    <div class="logo-icon floating">
                        <i class="fas fa-project-diagram"></i>
                    </div>
                    <div class="logo-text">
                        <h1>AlgoViz Hub</h1>
                        <p>ALGORITHM VISUALIZATION REPOSITORY</p>
                        <div class="breadcrumb">
                            <a href="#"><i class="fas fa-home"></i> Home</a>
                            &gt; <a href="#">Distributed Systems</a> &gt;
                            <span>Anti-Entropy Gossip Protocol</span>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Algorithm Header -->
            <div class="algorithm-header">
                <h1>Anti-Entropy Gossip Protocol</h1>
                <div class="category">
                    <i class="fas fa-sync-alt"></i> Distributed Systems
Protocol
</div>
                <div class="complexity-badge">Convergence Time: O(log n)</div>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <!-- Left Column: Algorithm Details -->
                <div class="left-column">
                    <!-- Description Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-file-alt"></i> Protocol Overview
                        </h2>
                        <p>
                            The Anti-Entropy Gossip Protocol is an epidemic
                            algorithm used in distributed systems to achieve
                            eventual consistency across nodes. It works by
                            having each node periodically select another random
                            node to exchange state information with, resolving
                            any differences through a reconciliation process.
                        </p>
                        <p>
                            This protocol is highly fault-tolerant, scalable,
                            and robust against node failures. It's widely used
                            in distributed databases, blockchain networks, and
                            peer-to-peer systems where maintaining consistency
                            across all nodes is critical but immediate strong
                            consistency isn't required.
                        </p>
                        <div class="key-points">
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-check-circle"></i> Key
                                    Feature
                                </h3>
                                <p>
                                    Eventual consistency with high fault
                                    tolerance and scalability
                                </p>
                            </div>
                            <div class="point-card">
                                <h3><i class="fas fa-bolt"></i> Performance</h3>
                                <p>
                                    Efficient information dissemination with
                                    O(log n) rounds to reach all nodes
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-shield-alt"></i> Robustness
                                </h3>
                                <p>
                                    Tolerates node failures and network
                                    partitions gracefully
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-project-diagram"></i>
                                    Approach
                                </h3>
                                <p>
                                    Epidemic-style information dissemination
                                    through periodic peer communication
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Visualization Console -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-laptop-code"></i> Interactive
                            Visualization
                        </h2>
                        <p>
                            Use the interactive console below to visualize how
                            the Anti-Entropy Gossip Protocol works. Adjust the
                            number of nodes, failure rate, and gossip interval
                            to see how information propagates through the
                            network.
                        </p>
                        <div class="visualization-console">
                            <div class="console-header">
                                <h3>
                                    <i class="fas fa-play-circle"></i> Gossip
                                    Protocol Visualization
                                </h3>
                                <div class="console-controls">
                                    <button class="console-btn secondary">
                                        <i class="fas fa-cog"></i> Settings
                                    </button>
                                    <button class="console-btn">
                                        <i class="fas fa-play"></i> Run
                                    </button>
                                </div>
                            </div>
                            <div class="visualization-area">
                                <!-- Visualization will be rendered here -->
                            </div>
                            <div class="console-input">
                                <input
                                    placeholder="Number of nodes (e.g., 8)"
                                    type="text"
                                    value="8"
                                />
                                <button class="console-btn">
                                    <i class="fas fa-random"></i> Random Data
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Algorithm Steps -->
                    <div class="section">
                        <h2><i class="fas fa-list-ol"></i> Protocol Steps</h2>
                        <p>
                            The Anti-Entropy Gossip Protocol operates through
                            the following steps to achieve eventual consistency:
                        </p>
                        <div class="key-points">
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-clock"></i> 1. Periodic
                                    Initiation
                                </h3>
                                <p>
                                    Each node runs a periodic task (every T
                                    seconds) to initiate a gossip round. This
                                    ensures continuous information exchange even
                                    if some messages are lost.
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-random"></i> 2. Peer
                                    Selection
                                </h3>
                                <p>
                                    In each round, a node randomly selects one
                                    or more other nodes from the network to
                                    exchange information with. This random
                                    selection ensures robust dissemination.
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-exchange-alt"></i> 3. State
                                    Exchange
                                </h3>
                                <p>
                                    The initiating node sends a digest of its
                                    current state to the selected peer. The peer
                                    responds with any missing or newer
                                    information based on the digest.
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-sync-alt"></i> 4.
                                    Reconciliation
                                </h3>
                                <p>
                                    Nodes compare their states and resolve
                                    differences using a reconciliation mechanism
                                    (such as timestamp-based resolution or
                                    version vectors).
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-expand-arrows-alt"></i> 5.
                                    Propagation
                                </h3>
                                <p>
                                    The updated information continues to
                                    propagate through the network with each
                                    gossip round, eventually reaching all nodes
                                    (eventual consistency).
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Pseudocode Section -->
                    <div class="section">
                        <h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
                        <div class="code-block">
                            <pre><code>// Periodic gossip task
function gossipTask():
    while true:
        sleep(GOSSIP_INTERVAL)
        peer = selectRandomPeer()
        exchangeStateWith(peer)

// State exchange with a peer
function exchangeStateWith(peer):
    myDigest = generateStateDigest()
    sendTo(peer, myDigest)

    theirDigest = receiveFrom(peer)
    missingData = compareDigests(myDigest, theirDigest)

    if missingData.neededFromPeer:
        requestDataFrom(peer, missingData.neededFromPeer)

    if missingData.neededByPeer:
        sendDataTo(peer, missingData.neededByPeer)

// Digest comparison
function compareDigests(myDigest, theirDigest):
    result = {neededFromPeer: [], neededByPeer: []}

    for key in allKeys:
        if theirDigest[key].version > myDigest[key].version:
            result.neededFromPeer.append(key)
        else if myDigest[key].version > theirDigest[key].version:
            result.neededByPeer.append(key)

    return result</code></pre>
                        </div>
                    </div>

                    <!-- Implementation Section -->
                    <div class="section">
                        <h2><i class="fas fa-code"></i> Implementation</h2>
                        <p>
                            Below is a Python implementation of a simple
                            Anti-Entropy Gossip Protocol. This example
                            demonstrates the core concepts of periodic gossip,
                            state exchange, and reconciliation using version
                            vectors for conflict resolution.
                        </p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Python Implementation</span>
                                <button class="copy-btn">
                                    <i class="fas fa-copy"></i> Copy Code
                                </button>
                            </div>
                            <pre><code><span class="keyword">import</span> random
<span class="keyword">import</span> threading
<span class="keyword">import</span> time
<span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict

<span class="keyword">class</span> <span class="function">GossipNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, node_id, all_nodes):
        self.id = node_id
        self.all_nodes = all_nodes  <span class="comment"># List of all node references</span>
        self.data = defaultdict(<span class="keyword">lambda</span>: {<span class="string">'value'</span>: <span class="keyword">None</span>, <span class="string">'version'</span>: <span class="number">0</span>})
        self.running = <span class="keyword">True</span>

    <span class="keyword">def</span> <span class="function">start_gossip</span>(self):
        <span class="comment"># Start the periodic gossip task</span>
        self.gossip_thread = threading.Thread(target=self._gossip_task)
        self.gossip_thread.daemon = <span class="keyword">True</span>
        self.gossip_thread.start()

    <span class="keyword">def</span> <span class="function">_gossip_task</span>(self):
        <span class="keyword">while</span> self.running:
            time.sleep(random.uniform(<span class="number">0.8</span>, <span class="number">1.2</span>))  <span class="comment"># Gossip interval with jitter</span>
            peer = self._select_random_peer()
            <span class="keyword">if</span> peer:
                self._exchange_data_with(peer)

    <span class="keyword">def</span> <span class="function">_select_random_peer</span>(self):
        <span class="comment"># Select a random peer from all nodes (excluding self)</span>
        available_peers = [node <span class="keyword">for</span> node <span class="keyword">in</span> self.all_nodes <span class="keyword">if</span> node.id != self.id]
        <span class="keyword">return</span> random.choice(available_peers) <span class="keyword">if</span> available_peers <span class="keyword">else</span> <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">_exchange_data_with</span>(self, peer):
        <span class="comment"># Exchange data with a peer and reconcile differences</span>
        my_digest = self._generate_digest()
        peer_digest = peer._generate_digest()  <span class="comment"># In real implementation, this would be a remote call</span>

        <span class="comment"># Determine what data we need from peer</span>
        <span class="keyword">for</span> key, info <span class="keyword">in</span> peer_digest.items():
            <span class="keyword">if</span> info[<span class="string">'version'</span>] > self.data[key][<span class="string">'version'</span>]:
                <span class="comment"># In real implementation, would request actual data</span>
                self.data[key] = {<span class="string">'value'</span>: f<span class="string">"value_from_{peer.id}"</span>, <span class="string">'version'</span>: info[<span class="string">'version'</span>]}

    <span class="keyword">def</span> <span class="function">_generate_digest</span>(self):
        <span class="comment"># Generate a compact representation of our data state</span>
        <span class="keyword">return</span> {key: {<span class="string">'version'</span>: info[<span class="string">'version'</span>]} <span class="keyword">for</span> key, info <span class="keyword">in</span> self.data.items()}

    <span class="keyword">def</span> <span class="function">update_data</span>(self, key, value):
        <span class="comment"># Update data with a new version</span>
        self.data[key] = {
            <span class="string">'value'</span>: value,
            <span class="string">'version'</span>: self.data[key][<span class="string">'version'</span>] + <span class="number">1</span>
        }

    <span class="keyword">def</span> <span class="function">stop</span>(self):
        self.running = <span class="keyword">False</span>
        self.gossip_thread.join()

<span class="comment"># Example usage</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    nodes = [GossipNode(i, []) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]
    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:
        node.all_nodes = nodes  <span class="comment"># Set reference to all nodes</span>
        node.start_gossip()

    <span class="comment"># Simulate some data updates</span>
    nodes[<span class="number">0</span>].update_data(<span class="string">'key1'</span>, <span class="string">'value1'</span>)
    nodes[<span class="number">2</span>].update_data(<span class="string">'key2'</span>, <span class="string">'value2'</span>)

    time.sleep(<span class="number">5</span>)  <span class="comment"># Let gossip propagate</span>

    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:
        node.stop()</code></pre>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Additional Info -->
                <div class="right-column">
                    <!-- Properties Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-info-circle"></i> Protocol
                            Properties
                        </h2>
                        <div class="properties-grid">
                            <div class="property-card">
                                <h4>Category</h4>
                                <div class="value">Epidemic</div>
                            </div>
                            <div class="property-card">
                                <h4>Consistency</h4>
                                <div class="value">Eventual</div>
                            </div>
                            <div class="property-card">
                                <h4>Fault Tolerance</h4>
                                <div class="value">High</div>
                            </div>
                            <div class="property-card">
                                <h4>Scalability</h4>
                                <div class="value">High</div>
                            </div>
                            <div class="property-card">
                                <h4>Message Complexity</h4>
                                <div class="value">O(n log n)</div>
                            </div>
                            <div class="property-card">
                                <h4>Convergence Time</h4>
                                <div class="value">O(log n)</div>
                            </div>
                            <div class="property-card">
                                <h4>Network Overhead</h4>
                                <div class="value">Low</div>
                            </div>
                            <div class="property-card">
                                <h4>Topology</h4>
                                <div class="value">Any</div>
                            </div>
                        </div>
                    </div>

                    <!-- Applications Section -->
                    <div class="section">
                        <h2><i class="fas fa-lightbulb"></i> Applications</h2>
                        <p>
                            The Anti-Entropy Gossip Protocol is used in various
                            distributed systems where eventual consistency is
                            acceptable:
                        </p>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                Distributed databases (Cassandra, DynamoDB)
                            </li>
                            <li style="margin-bottom: 10px">
                                Blockchain and cryptocurrency networks
                            </li>
                            <li style="margin-bottom: 10px">
                                Peer-to-peer networks
                            </li>
                            <li style="margin-bottom: 10px">
                                Cluster management systems (Kubernetes, Consul)
                            </li>
                            <li>Content delivery networks</li>
                        </ul>
                    </div>

                    <!-- Advantages Section -->
                    <div class="section">
                        <h2><i class="fas fa-plus-circle"></i> Advantages</h2>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                Highly resilient to node failures and network
                                partitions
                            </li>
                            <li style="margin-bottom: 10px">
                                Naturally load-balanced with no single point of
                                failure
                            </li>
                            <li style="margin-bottom: 10px">
                                Scalable to very large networks (thousands of
                                nodes)
                            </li>
                            <li style="margin-bottom: 10px">
                                Easy to implement and deploy
                            </li>
                            <li>
                                Adapts automatically to network topology changes
                            </li>
                        </ul>
                    </div>

                    <!-- Limitations Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-exclamation-triangle"></i>
                            Limitations
                        </h2>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                Only provides eventual consistency, not strong
                                consistency
                            </li>
                            <li style="margin-bottom: 10px">
                                Can produce conflicting updates that need
                                resolution
                            </li>
                            <li style="margin-bottom: 10px">
                                Message redundancy can cause network overhead in
                                some scenarios
                            </li>
                            <li>
                                Convergence time may be too slow for some
                                applications
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <footer>
                <div class="footer-links">
                    <a
                        href="https://www.linkedin.com/in/sgkandale/"
                        target="_blank"
                        ><i class="fa-brands fa-linkedin"></i> LinkedIN</a
                    >
                    <a href="mailto:me@sgkandale.com"
                        ><i class="fa-solid fa-at"></i> E-Mail</a
                    >
                    <a href="https://buymeacoffee.com/sgkandale" target="_blank"
                        ><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a
                    >
                </div>
                <p>
                    AlgoViz Hub - Interactive Algorithm Visualization Platform
                </p>
                <p>Â© 2025 AlgoViz Hub. All rights reserved.</p>
            </footer>
        </div>

        <script>
    class GossipNode {
        constructor(id, allNodes) {
            this.id = id;
            this.allNodes = allNodes;
            this.data = new Set();
            this.element = null;
            this.gossipInterval = null;
        }

        start() {
            this.gossipInterval = setInterval(() => this.gossip(), 2000);
        }

        stop() {
            clearInterval(this.gossipInterval);
        }

        gossip() {
            const peer = this.selectRandomPeer();
            if (peer) {
                this.exchangeWith(peer);
            }
        }

        selectRandomPeer() {
            const availablePeers = this.allNodes.filter(node => node.id !== this.id);
            return availablePeers[Math.floor(Math.random() * availablePeers.length)];
        }

        exchangeWith(peer) {
            // In a real implementation, this would be more complex with digests.
            // For visualization, we'll do a simple state merge.
            const myData = new Set(this.data);
            const peerData = new Set(peer.data);

            peerData.forEach(item => myData.add(item));
            myData.forEach(item => peerData.add(item));

            this.data = myData;
            peer.data = peerData;
            
            this.visualizeGossip(peer);
        }
        
        visualizeGossip(peer) {
            const message = document.createElement("div");
            message.className = "gossip-message";
            message.textContent = "Gossip";
            
            const vizArea = document.querySelector('.visualization-area');
            vizArea.appendChild(message);

            const sourceRect = this.element.getBoundingClientRect();
            const targetRect = peer.element.getBoundingClientRect();
            const containerRect = vizArea.getBoundingClientRect();

            const sourceX = sourceRect.left - containerRect.left + sourceRect.width / 2;
            const sourceY = sourceRect.top - containerRect.top + sourceRect.height / 2;
            const targetX = targetRect.left - containerRect.left + targetRect.width / 2;
            const targetY = targetRect.top - containerRect.top + targetRect.height / 2;

            message.style.left = `${sourceX}px`;
            message.style.top = `${sourceY}px`;
            message.style.opacity = "1";

            setTimeout(() => {
                message.style.left = `${targetX}px`;
                message.style.top = `${targetY}px`;
                setTimeout(() => {
                    message.remove();
                    this.updateNodeAppearance();
                    peer.updateNodeAppearance();
                }, 500);
            }, 100);
        }

        updateData(item) {
            this.data.add(item);
            this.updateNodeAppearance();
        }
        
        updateNodeAppearance() {
            if(this.data.size > 0) {
                this.element.style.backgroundColor = 'var(--success)';
            }
        }
    }

    let nodes = [];
    let simulationRunning = false;

    function setupVisualization() {
        const vizArea = document.querySelector(".visualization-area");
        vizArea.innerHTML = '';
        nodes = [];
        
        const nodeCount = parseInt(document.querySelector(".console-input input").value) || 8;
        const width = vizArea.offsetWidth;
        const height = vizArea.offsetHeight;
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) * 0.35;

        for (let i = 0; i < nodeCount; i++) {
            const angle = (2 * Math.PI * i) / nodeCount;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);

            const nodeEl = document.createElement("div");
            nodeEl.className = "node";
            nodeEl.id = `node-${i}`;
            nodeEl.style.left = `${x - 30}px`;
            nodeEl.style.top = `${y - 30}px`;
            nodeEl.innerHTML = `N${i}`;
            vizArea.appendChild(nodeEl);
            
            const node = new GossipNode(i, nodes);
            node.element = nodeEl;
            nodes.push(node);
        }
        
        nodes.forEach(node => node.allNodes = nodes);
        
        // Initial data
        if(nodes.length > 0) {
            nodes[0].updateData('Initial Message');
        }
    }

    function startSimulation() {
        if (simulationRunning) return;
        simulationRunning = true;
        setupVisualization();
        nodes.forEach(node => node.start());
        document.querySelector(".console-btn").innerHTML = '<i class="fas fa-stop"></i> Stop';
    }

    function stopSimulation() {
        if (!simulationRunning) return;
        simulationRunning = false;
        nodes.forEach(node => node.stop());
        document.querySelector(".console-btn").innerHTML = '<i class="fas fa-play"></i> Run';
    }

    document.querySelector(".console-btn").addEventListener("click", () => {
        if (simulationRunning) {
            stopSimulation();
        } else {
            startSimulation();
        }
    });
    
    document.querySelector(".console-input input").addEventListener("change", () => {
        if(!simulationRunning) {
            setupVisualization();
        }
    });

    setupVisualization();
</script>
    </body>
</html>
