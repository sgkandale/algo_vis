<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Gossip-based Aggregation Protocol | AlgoViz Hub</title>
        <meta
            content="Interactive visualization of Gossip-based Aggregation Protocols for distributed systems"
            name="description"
        />
        <meta
            content="gossip protocol, aggregation protocol, distributed systems, data aggregation, consensus, visualization, interactive"
            name="keywords"
        />
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
            rel="stylesheet"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap"
            rel="stylesheet"
        />
        <style>
            :root {
                --primary: #0f172a;
                --secondary: #1e293b;
                --accent: #6366f1;
                --accent-light: #818cf8;
                --accent-glow: rgba(99, 102, 241, 0.2);
                --text: #e2e8f0;
                --text-secondary: #94a3b8;
                --card-bg: rgba(30, 41, 59, 0.7);
                --success: #10b981;
                --warning: #f59e0b;
                --danger: #ef4444;
                --transition: all 0.3s ease;
                --radius: 12px;
                --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                --glow: 0 0 15px var(--accent-glow);
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background: linear-gradient(
                    135deg,
                    var(--primary),
                    var(--secondary)
                );
                color: var(--text);
                font-family: "Roboto", sans-serif;
                line-height: 1.6;
                min-height: 100vh;
                padding: 0;
                position: relative;
                overflow-x: hidden;
            }

            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background:
                    radial-gradient(
                        circle at 10% 20%,
                        rgba(99, 102, 241, 0.1) 0%,
                        transparent 20%
                    ),
                    radial-gradient(
                        circle at 90% 80%,
                        rgba(129, 140, 248, 0.1) 0%,
                        transparent 20%
                    );
                z-index: -1;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }

            /* Header Styles */
            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px 0;
                position: relative;
                border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            }

            .logo {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .logo-icon {
                width: 50px;
                height: 50px;
                background: var(--accent);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: var(--glow);
            }

            .logo-icon i {
                font-size: 24px;
                color: white;
            }

            .logo-text h1 {
                font-family: "Roboto Mono", monospace;
                font-weight: 700;
                font-size: 28px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }

            .logo-text p {
                font-size: 14px;
                color: var(--text-secondary);
                letter-spacing: 1.5px;
            }

            .breadcrumb {
                font-size: 14px;
                color: var(--text-secondary);
                margin-top: 10px;
            }

            .breadcrumb a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .breadcrumb a:hover {
                text-decoration: underline;
            }

            /* Algorithm Header */
            .algorithm-header {
                margin: 40px 0;
                text-align: center;
                padding: 20px;
                background: var(--card-bg);
                border-radius: var(--radius);
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .algorithm-header::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .algorithm-header h1 {
                font-size: 42px;
                margin-bottom: 15px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                font-weight: 800;
            }

            .algorithm-header .category {
                font-size: 18px;
                color: var(--accent-light);
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

            .complexity-badge {
                display: inline-block;
                background: rgba(129, 140, 248, 0.2);
                color: var(--accent-light);
                padding: 6px 15px;
                border-radius: 20px;
                font-size: 16px;
                font-weight: 600;
                font-family: "Roboto Mono", monospace;
                margin-top: 15px;
            }

            /* Main Content Layout */
            .main-content {
                display: grid;
                grid-template-columns: 1fr 350px;
                gap: 30px;
                margin-bottom: 40px;
            }

            @media (max-width: 900px) {
                .main-content {
                    grid-template-columns: 1fr;
                }
            }

            /* Algorithm Detail Sections */
            .section {
                background: var(--card-bg);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                padding: 30px;
                margin-bottom: 30px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .section::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .section h2 {
                font-size: 26px;
                margin-bottom: 20px;
                color: var(--accent-light);
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .section h2 i {
                color: var(--accent);
                width: 36px;
                height: 36px;
                background: rgba(99, 102, 241, 0.2);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .section p {
                color: var(--text-secondary);
                font-size: 17px;
                line-height: 1.8;
                margin-bottom: 20px;
            }

            .key-points {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 20px;
                margin: 25px 0;
            }

            .point-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
            }

            .point-card h3 {
                color: var(--accent-light);
                margin-bottom: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .point-card h3 i {
                color: var(--accent);
            }

            .point-card p {
                margin-bottom: 0;
                font-size: 15px;
            }

            /* Visualization Console */
            .visualization-console {
                background: rgba(15, 23, 42, 0.8);
                border-radius: var(--radius);
                padding: 25px;
                margin: 30px 0;
                border: 1px solid rgba(99, 102, 241, 0.3);
                box-shadow: var(--glow);
            }

            .console-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }

            .console-header h3 {
                color: var(--accent-light);
                font-size: 20px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .console-controls {
                display: flex;
                gap: 10px;
            }

            .console-btn {
                background: var(--accent);
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .console-btn:hover {
                background: var(--accent-light);
            }

            .console-btn.secondary {
                background: rgba(148, 163, 184, 0.2);
            }

            .visualization-area {
                height: 300px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
                overflow: hidden;
            }

            .visualization-area::before {
                content: "Aggregation Protocol Visualization";
                position: absolute;
                color: rgba(148, 163, 184, 0.5);
                font-size: 20px;
            }

            .console-input {
                display: flex;
                gap: 10px;
                margin-top: 20px;
            }

            .console-input input {
                flex: 1;
                padding: 12px 15px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(148, 163, 184, 0.2);
                border-radius: 5px;
                color: var(--text);
                font-family: "Roboto Mono", monospace;
            }

            .console-input input:focus {
                outline: none;
                border-color: var(--accent);
            }

            /* Algorithm Properties */
            .properties-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }

            .property-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                text-align: center;
            }

            .property-card h4 {
                color: var(--text-secondary);
                font-size: 14px;
                margin-bottom: 8px;
                font-weight: 400;
            }

            .property-card .value {
                font-size: 20px;
                font-weight: 700;
                color: var(--accent-light);
                font-family: "Roboto Mono", monospace;
            }

            /* Footer */
            footer {
                text-align: center;
                padding: 40px 0 30px;
                color: var(--text-secondary);
                font-size: 14px;
                border-top: 1px solid rgba(148, 163, 184, 0.1);
                margin-top: 40px;
            }

            footer p {
                margin: 10px 0;
            }

            .footer-links {
                display: flex;
                justify-content: center;
                gap: 25px;
                margin-top: 15px;
                flex-wrap: wrap;
                margin-bottom: 20px;
            }

            .footer-links a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .footer-links a:hover {
                color: var(--accent);
            }

            /* Animations */
            @keyframes float {
                0% {
                    transform: translateY(0px);
                }
                50% {
                    transform: translateY(-10px);
                }
                100% {
                    transform: translateY(0px);
                }
            }

            .floating {
                animation: float 6s ease-in-out infinite;
            }

            /* Responsive Design */
            @media (max-width: 768px) {
                header {
                    flex-direction: column;
                    gap: 25px;
                    text-align: center;
                }

                .algorithm-header h1 {
                    font-size: 32px;
                }

                .key-points {
                    grid-template-columns: 1fr;
                }
            }

            /* Code Block Styling */
            .code-block {
                background: #0d1117;
                border-radius: 8px;
                padding: 20px;
                margin: 25px 0;
                overflow-x: auto;
                font-family: "Roboto Mono", monospace;
                font-size: 15px;
                border: 1px solid rgba(99, 102, 241, 0.3);
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                color: var(--text-secondary);
            }

            .copy-btn {
                background: rgba(99, 102, 241, 0.2);
                color: var(--accent-light);
                border: none;
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .copy-btn:hover {
                background: rgba(99, 102, 241, 0.3);
            }

            .code-block pre {
                margin: 0;
            }

            .code-block code {
                color: #c9d1d9;
                line-height: 1.5;
            }

            .keyword {
                color: #ff7b72;
            }
            .function {
                color: #d2a8ff;
            }
            .comment {
                color: #8b949e;
            }
            .string {
                color: #a5d6ff;
            }
            .number {
                color: #79c0ff;
            }

            /* Node visualization styles */
            .node {
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: var(--accent);
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                position: absolute;
                box-shadow: var(--glow);
                transition: all 0.5s ease;
                z-index: 10;
            }

            .node.converging {
                background: var(--warning);
            }

            .node.converged {
                background: var(--success);
            }

            .node-connection {
                position: absolute;
                height: 2px;
                background: rgba(129, 140, 248, 0.5);
                transform-origin: 0 0;
                z-index: 1;
            }

            .aggregation-message {
                position: absolute;
                background: var(--success);
                color: white;
                padding: 5px 10px;
                border-radius: 20px;
                font-size: 12px;
                opacity: 0;
                transition: all 0.5s ease;
                z-index: 100;
            }

            .stats-panel {
                display: flex;
                justify-content: space-around;
                margin-top: 15px;
                font-family: "Roboto Mono", monospace;
                font-size: 14px;
            }

            .stat-item {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .stat-value {
                font-weight: bold;
                color: var(--accent-light);
                font-size: 18px;
            }

            .stat-label {
                color: var(--text-secondary);
                font-size: 12px;
            }

            .node-info {
                position: absolute;
                background: var(--card-bg);
                border: 1px solid var(--accent);
                padding: 10px;
                border-radius: 8px;
                font-size: 12px;
                display: none;
                z-index: 1000;
                max-width: 200px;
            }

            .slider-container {
                display: flex;
                flex-direction: column;
                gap: 8px;
                margin-top: 10px;
            }

            .slider-label {
                display: flex;
                justify-content: space-between;
                font-size: 14px;
                color: var(--text-secondary);
            }

            .aggregation-result {
                text-align: center;
                margin-top: 15px;
                font-family: "Roboto Mono", monospace;
                font-size: 18px;
                color: var(--accent-light);
            }
        </style>
        <meta
            content="Gossip-based Aggregation Protocol | AlgoViz Hub"
            property="og:title"
        />
        <meta
            content="Interactive visualization of Gossip-based Aggregation Protocols for distributed systems"
            property="og:description"
        />
        <meta content="article" property="og:type" />
        <meta
            content="https://sgkandale.github.io/gossip-aggregation.html"
            property="og:url"
        />
        <meta content="AlgoViz Hub" property="og:site_name" />
        <meta content="summary" name="twitter:card" />
        <meta
            content="Gossip-based Aggregation Protocol | AlgoViz Hub"
            name="twitter:title"
        />
        <meta
            content="Interactive visualization of Gossip-based Aggregation Protocols for distributed systems"
            name="twitter:description"
        />
        <meta content="@sgkandale" name="twitter:site" />
        <link
            href="https://sgkandale.github.io/gossip-aggregation.html"
            rel="canonical"
        />
        <script type="application/ld+json">
            {
                "@context": "https://schema.org",
                "@type": "Article",
                "headline": "Gossip-based Aggregation Protocol | AlgoViz Hub",
                "description": "Interactive visualization of Gossip-based Aggregation Protocols for distributed systems",
                "author": {
                    "@type": "Person",
                    "name": "Shantanu Kandale"
                },
                "publisher": {
                    "@type": "Organization",
                    "name": "AlgoViz Hub",
                    "logo": {
                        "@type": "ImageObject",
                        "url": "https://sgkandale.github.io/favicon.ico"
                    }
                },
                "mainEntityOfPage": {
                    "@type": "WebPage",
                    "@id": "https://sgkandale.github.io/gossip-aggregation.html"
                }
            }
        </script>
    </head>
    <body>
        <div class="container">
            <!-- Header -->
            <header>
                <div class="logo">
                    <div class="logo-icon floating">
                        <i class="fas fa-project-diagram"></i>
                    </div>
                    <div class="logo-text">
                        <h1>AlgoViz Hub</h1>
                        <p>ALGORITHM VISUALIZATION REPOSITORY</p>
                        <div class="breadcrumb">
                            <a href="#"><i class="fas fa-home"></i> Home</a>
                            &gt; <a href="#">Distributed Systems</a> &gt;
                            <span>Gossip-based Aggregation</span>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Algorithm Header -->
            <div class="algorithm-header">
                <h1>Gossip-based Aggregation Protocol</h1>
                <div class="category">
                    <i class="fas fa-network-wired"></i> Distributed Data
                    Aggregation
                </div>
                <div class="complexity-badge">Convergence Time: O(log n)</div>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <!-- Left Column: Algorithm Details -->
                <div class="left-column">
                    <!-- Description Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-file-alt"></i> Protocol Overview
                        </h2>
                        <p>
                            Gossip-based Aggregation Protocols are decentralized
                            algorithms used in distributed systems to compute
                            global aggregates (sum, average, count, max, min)
                            from local data across nodes. These protocols use
                            gossip-style communication to efficiently
                            disseminate and combine information without
                            requiring centralized coordination.
                        </p>
                        <p>
                            Aggregation protocols are fundamental for monitoring
                            and managing large-scale distributed systems,
                            enabling tasks like computing system-wide metrics,
                            load balancing, and making decentralized decisions
                            based on global system state.
                        </p>
                        <div class="key-points">
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-check-circle"></i> Key
                                    Feature
                                </h3>
                                <p>
                                    Decentralized computation of global
                                    aggregates from local data
                                </p>
                            </div>
                            <div class="point-card">
                                <h3><i class="fas fa-bolt"></i> Performance</h3>
                                <p>
                                    Efficient convergence with O(log n)
                                    communication rounds
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-shield-alt"></i> Robustness
                                </h3>
                                <p>
                                    Resilient to node failures and network
                                    dynamics
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-project-diagram"></i>
                                    Approach
                                </h3>
                                <p>
                                    Pairwise averaging through randomized gossip
                                    exchanges
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Visualization Console -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-laptop-code"></i> Interactive
                            Visualization
                        </h2>
                        <p>
                            Use the interactive console below to visualize how
                            the Gossip-based Aggregation Protocol works. Observe
                            how nodes exchange values and converge toward the
                            global average through gossip communication.
                        </p>
                        <div class="visualization-console">
                            <div class="console-header">
                                <h3>
                                    <i class="fas fa-play-circle"></i>
                                    Aggregation Protocol Visualization
                                </h3>
                                <div class="console-controls">
                                    <button
                                        class="console-btn secondary"
                                        id="settings-btn"
                                    >
                                        <i class="fas fa-cog"></i> Settings
                                    </button>
                                    <button class="console-btn" id="run-btn">
                                        <i class="fas fa-play"></i> Run
                                    </button>
                                </div>
                            </div>
                            <div
                                class="visualization-area"
                                id="visualization-area"
                            >
                                <!-- Visualization will be rendered here -->
                            </div>
                            <div class="console-input">
                                <div class="slider-container">
                                    <div class="slider-label">
                                        <span
                                            >Node Count:
                                            <span id="node-count-value"
                                                >8</span
                                            ></span
                                        >
                                        <span
                                            >Convergence Threshold:
                                            <span id="threshold-value"
                                                >0.1</span
                                            ></span
                                        >
                                    </div>
                                    <input
                                        type="range"
                                        id="node-count"
                                        min="5"
                                        max="15"
                                        value="8"
                                        style="width: 100%"
                                    />
                                    <input
                                        type="range"
                                        id="convergence-threshold"
                                        min="1"
                                        max="20"
                                        value="10"
                                        style="width: 100%"
                                    />
                                </div>
                                <button class="console-btn" id="reset-btn">
                                    <i class="fas fa-sync"></i> Reset Values
                                </button>
                            </div>
                            <div class="stats-panel">
                                <div class="stat-item">
                                    <span class="stat-value" id="round-count"
                                        >0</span
                                    >
                                    <span class="stat-label"
                                        >Gossip Rounds</span
                                    >
                                </div>
                                <div class="stat-item">
                                    <span
                                        class="stat-value"
                                        id="converged-nodes"
                                        >0</span
                                    >
                                    <span class="stat-label"
                                        >Converged Nodes</span
                                    >
                                </div>
                                <div class="stat-item">
                                    <span class="stat-value" id="current-avg"
                                        >0</span
                                    >
                                    <span class="stat-label"
                                        >Current Average</span
                                    >
                                </div>
                            </div>
                            <div
                                class="aggregation-result"
                                id="aggregation-result"
                            >
                                Target Average: <span id="target-avg">0</span>
                            </div>
                        </div>
                    </div>

                    <!-- Algorithm Steps -->
                    <div class="section">
                        <h2><i class="fas fa-list-ol"></i> Protocol Steps</h2>
                        <p>
                            The Gossip-based Aggregation Protocol operates
                            through the following steps to compute global
                            aggregates:
                        </p>
                        <div class="key-points">
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-plus-circle"></i> 1.
                                    Initialization
                                </h3>
                                <p>
                                    Each node initializes with its local value.
                                    For average computation, nodes typically
                                    start with (value, 1) pairs, where the first
                                    component is the local value and the second
                                    represents the weight (count).
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-clock"></i> 2. Periodic
                                    Gossip
                                </h3>
                                <p>
                                    At regular intervals, each node selects a
                                    random peer and initiates a gossip exchange.
                                    The interval is typically randomized to
                                    avoid synchronization and thundering herd
                                    problems.
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-exchange-alt"></i> 3. Value
                                    Exchange
                                </h3>
                                <p>
                                    During gossip exchanges, nodes share their
                                    current estimates. For average computation,
                                    nodes exchange both their current sum
                                    estimates and their weight (count) values.
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-calculator"></i> 4. Local
                                    Update
                                </h3>
                                <p>
                                    Upon receiving values from a peer, a node
                                    updates its own estimate by computing a
                                    weighted average of its current value and
                                    the received value. Different aggregation
                                    functions require different update rules.
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-project-diagram"></i> 5.
                                    Convergence
                                </h3>
                                <p>
                                    Through repeated gossip exchanges, values
                                    propagate through the network and nodes
                                    gradually converge toward the global
                                    aggregate. Convergence is typically
                                    exponential.
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Pseudocode Section -->
                    <div class="section">
                        <h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
                        <div class="code-block">
                            <pre><code>// Node state for average computation
Node {
    id: unique identifier
    value: local value or current estimate
    weight: weight for weighted averages (1 for simple average)
    converged: boolean indicating if converged
}

// Periodic gossip task
Every T seconds:
    if not converged:
        peer = selectRandomPeer()
        sendUpdate(peer, (value, weight))

        // Also handle incoming requests asynchronously

// Handle incoming update
On receiveUpdate(sender, (theirValue, theirWeight)):
    // Compute new weighted average
    totalWeight = weight + theirWeight
    newValue = (value * weight + theirValue * theirWeight) / totalWeight

    // Update state
    value = newValue
    weight = totalWeight / 2  // For symmetric averaging

    // Check for convergence
    if abs(value - previousValue) < threshold:
        converged = true

// Alternative: Push-Sum Protocol for average
On receivePushSum(sender, s, w):
    value = value + s
    weight = weight + w

    // Share half of the values with a random peer
    halfValue = value / 2
    halfWeight = weight / 2
    value = halfValue
    weight = halfWeight

    peer = selectRandomPeer()
    sendPushSum(peer, halfValue, halfWeight)</code></pre>
                        </div>
                    </div>

                    <!-- Implementation Section -->
                    <div class="section">
                        <h2><i class="fas fa-code"></i> Implementation</h2>
                        <p>
                            Below is a Python implementation of a Gossip-based
                            Aggregation Protocol for computing the global
                            average. This example demonstrates the core concepts
                            of value exchange, weighted averaging, and
                            convergence detection.
                        </p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Python Implementation</span>
                                <button class="copy-btn">
                                    <i class="fas fa-copy"></i> Copy Code
                                </button>
                            </div>
                            <pre><code><span class="keyword">import</span> random
<span class="keyword">import</span> threading
<span class="keyword">import</span> time
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="keyword">class</span> <span class="function">AggregationNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, node_id, all_nodes, initial_value):
        self.id = node_id
        self.all_nodes = all_nodes
        self.initial_value = initial_value
        self.value = initial_value
        self.weight = 1.0
        self.converged = False
        self.running = True
        self.previous_value = initial_value
        self.convergence_threshold = 0.1

    <span class="keyword">def</span> <span class="function">start</span>(self):
        self.gossip_thread = threading.Thread(target=self._gossip_task)
        self.gossip_thread.daemon = True
        self.gossip_thread.start()

    <span class="keyword">def</span> <span class="function">_gossip_task</span>(self):
        <span class="keyword">while</span> self.running:
            <span class="keyword">if</span> <span class="keyword">not</span> self.converged:
                time.sleep(random.uniform(0.8, 1.2))  <span class="comment"># Randomize interval</span>
                peer = self._select_random_peer()
                <span class="keyword">if</span> peer:
                    self._send_update(peer)
            <span class="keyword">else</span>:
                time.sleep(1)  <span class="comment"># Sleep longer if converged</span>

    <span class="keyword">def</span> <span class="function">_select_random_peer</span>(self):
        available_peers = [n <span class="keyword">for</span> n <span class="keyword">in</span> self.all_nodes <span class="keyword">if</span> n.id != self.id]
        <span class="keyword">return</span> random.choice(available_peers) <span class="keyword">if</span> available_peers <span class="keyword">else</span> <span class="keyword">None</span>

    <span class="keyword">def</span> <span class="function">_send_update</span>(self, peer):
        <span class="comment"># In real implementation, this would be a network call</span>
        peer.receive_update(self.id, self.value, self.weight)

    <span class="keyword">def</span> <span class="function">receive_update</span>(self, sender_id, their_value, their_weight):
        <span class="keyword">if</span> self.converged:
            <span class="keyword">return</span>

        <span class="comment"># Store previous value for convergence check</span>
        self.previous_value = self.value

        <span class="comment"># Compute weighted average</span>
        total_weight = self.weight + their_weight
        self.value = (self.value * self.weight + their_value * their_weight) / total_weight

        <span class="comment"># Update weight (symmetric averaging)</span>
        self.weight = total_weight / 2.0

        <span class="comment"># Check for convergence</span>
        <span class="keyword">if</span> abs(self.value - self.previous_value) < self.convergence_threshold:
            self.converged = True
            print(f<span class="string">"Node {self.id} converged to value: {self.value}"</span>)

    <span class="keyword">def</span> <span class="function">stop</span>(self):
        self.running = False
        <span class="keyword">if</span> self.gossip_thread:
            self.gossip_thread.join()

<span class="comment"># Example usage</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Create nodes with random initial values</span>
    n_nodes = 10
    initial_values = np.random.randint(1, 100, n_nodes)
    nodes = [AggregationNode(i, [], initial_values[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n_nodes)]

    <span class="comment"># Set reference to all nodes</span>
    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:
        node.all_nodes = nodes
        node.start()

    <span class="comment"># Calculate actual average for comparison</span>
    actual_avg = np.mean(initial_values)
    print(f<span class="string">"Actual average: {actual_avg}"</span>)

    <span class="comment"># Let the protocol run</span>
    time.sleep(<span class="number">10</span>)

    <span class="comment"># Check results</span>
    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:
        print(f<span class="string">"Node {node.id}: initial={node.initial_value}, final={node.value}, converged={node.converged}"</span>)
        node.stop()</code></pre>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Additional Info -->
                <div class="right-column">
                    <!-- Properties Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-info-circle"></i> Protocol
                            Properties
                        </h2>
                        <div class="properties-grid">
                            <div class="property-card">
                                <h4>Category</h4>
                                <div class="value">Aggregation</div>
                            </div>
                            <div class="property-card">
                                <h4>Convergence</h4>
                                <div class="value">Exponential</div>
                            </div>
                            <div class="property-card">
                                <h4>Message Complexity</h4>
                                <div class="value">O(n log n)</div>
                            </div>
                            <div class="property-card">
                                <h4>Convergence Time</h4>
                                <div class="value">O(log n)</div>
                            </div>
                            <div class="property-card">
                                <h4>Fault Tolerance</h4>
                                <div class="value">High</div>
                            </div>
                            <div class="property-card">
                                <h4>Scalability</h4>
                                <div class="value">High</div>
                            </div>
                            <div class="property-card">
                                <h4>Network Overhead</h4>
                                <div class="value">Low</div>
                            </div>
                            <div class="property-card">
                                <h4>Topology</h4>
                                <div class="value">Decentralized</div>
                            </div>
                        </div>
                    </div>

                    <!-- Applications Section -->
                    <div class="section">
                        <h2><i class="fas fa-lightbulb"></i> Applications</h2>
                        <p>
                            Gossip-based Aggregation Protocols are used in
                            various distributed systems where global information
                            is needed:
                        </p>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                Sensor networks for data aggregation
                            </li>
                            <li style="margin-bottom: 10px">
                                Cloud computing platforms for resource
                                monitoring
                            </li>
                            <li style="margin-bottom: 10px">
                                Distributed databases for query processing
                            </li>
                            <li style="margin-bottom: 10px">
                                Peer-to-peer networks for load balancing
                            </li>
                            <li>
                                Cluster management systems for metrics
                                collection
                            </li>
                        </ul>
                    </div>

                    <!-- Advantages Section -->
                    <div class="section">
                        <h2><i class="fas fa-plus-circle"></i> Advantages</h2>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                Fully decentralized with no single point of
                                failure
                            </li>
                            <li style="margin-bottom: 10px">
                                Scalable to very large networks (thousands of
                                nodes)
                            </li>
                            <li style="margin-bottom: 10px">
                                Robust to node failures and network dynamics
                            </li>
                            <li style="margin-bottom: 10px">
                                Provides provable convergence guarantees
                            </li>
                            <li>
                                Adapts automatically to network topology changes
                            </li>
                        </ul>
                    </div>

                    <!-- Limitations Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-exclamation-triangle"></i>
                            Limitations
                        </h2>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                Only provides approximate results (with error
                                bounds)
                            </li>
                            <li style="margin-bottom: 10px">
                                Convergence time depends on network size and
                                structure
                            </li>
                            <li style="margin-bottom: 10px">
                                May not handle byzantine failures without
                                additional mechanisms
                            </li>
                            <li>
                                Requires careful parameter tuning for optimal
                                performance
                            </li>
                        </ul>
                    </div>

                    <!-- Aggregation Types Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-calculator"></i> Aggregation
                            Functions
                        </h2>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                <strong>Average</strong>: Most common, uses
                                pairwise averaging
                            </li>
                            <li style="margin-bottom: 10px">
                                <strong>Sum</strong>: Similar to average with
                                different weights
                            </li>
                            <li style="margin-bottom: 10px">
                                <strong>Count</strong>: Special case of sum
                                aggregation
                            </li>
                            <li style="margin-bottom: 10px">
                                <strong>Max/Min</strong>: Uses different
                                comparison-based approaches
                            </li>
                            <li>
                                <strong>Variance</strong>: More complex,
                                requires multiple values
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <footer>
                <div class="footer-links">
                    <a
                        href="https://www.linkedin.com/in/sgkandale/"
                        target="_blank"
                        ><i class="fa-brands fa-linkedin"></i> LinkedIN</a
                    >
                    <a href="mailto:me@sgkandale.com"
                        ><i class="fa-solid fa-at"></i> E-Mail</a
                    >
                    <a href="https://buymeacoffee.com/sgkandale" target="_blank"
                        ><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a
                    >
                </div>
                <p>
                    AlgoViz Hub - Interactive Algorithm Visualization Platform
                </p>
                <p> 2025 AlgoViz Hub. All rights reserved.</p>
            </footer>
        </div>

        <script>
            // Copy button functionality
            document.querySelectorAll(".copy-btn").forEach((button) => {
                button.addEventListener("click", function () {
                    const codeBlock =
                        this.closest(".code-block").querySelector("code");
                    const code = codeBlock.innerText;
                    navigator.clipboard.writeText(code);

                    // Show feedback
                    const originalText = this.innerHTML;
                    this.innerHTML = '<i class="fas fa-check"></i> Copied!';

                    setTimeout(() => {
                        this.innerHTML = originalText;
                    }, 2000);
                });
            });

            // Aggregation Protocol visualization
            const runBtn = document.getElementById("run-btn");
            const resetBtn = document.getElementById("reset-btn");
            const nodeCountSlider = document.getElementById("node-count");
            const thresholdSlider = document.getElementById(
                "convergence-threshold",
            );
            const nodeCountValue = document.getElementById("node-count-value");
            const thresholdValue = document.getElementById("threshold-value");
            const vizArea = document.getElementById("visualization-area");
            const roundCount = document.getElementById("round-count");
            const convergedNodes = document.getElementById("converged-nodes");
            const currentAvg = document.getElementById("current-avg");
            const targetAvg = document.getElementById("target-avg");
            const aggregationResult =
                document.getElementById("aggregation-result");

            let simulationInterval;
            let nodes = [];
            let currentRound = 0;
            let convergedCount = 0;
            let actualAverage = 0;

            // Update slider values
            nodeCountSlider.addEventListener("input", () => {
                nodeCountValue.textContent = nodeCountSlider.value;
                initVisualization();
            });

            thresholdSlider.addEventListener("input", () => {
                const threshold = parseInt(thresholdSlider.value) / 100;
                thresholdValue.textContent = threshold.toFixed(2);
                if (nodes.length > 0) {
                    nodes.forEach((node) => {
                        node.convergenceThreshold = threshold;
                    });
                }
            });

            // Initialize visualization
            function initVisualization() {
                vizArea.innerHTML = "";
                const nodeCount = parseInt(nodeCountSlider.value);
                nodes = [];

                const width = vizArea.offsetWidth;
                const height = vizArea.offsetHeight;
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) * 0.35;

                // Generate random initial values
                const initialValues = [];
                let sum = 0;
                for (let i = 0; i < nodeCount; i++) {
                    const value = Math.floor(Math.random() * 100) + 1;
                    initialValues.push(value);
                    sum += value;
                }
                actualAverage = sum / nodeCount;
                targetAvg.textContent = actualAverage.toFixed(2);

                // Create nodes
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (2 * Math.PI * i) / nodeCount;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);

                    const node = document.createElement("div");
                    node.className = "node";
                    node.id = `node-${i}`;
                    node.style.left = `${x}px`;
                    node.style.top = `${y}px`;
                    node.innerHTML = initialValues[i];
                    node.dataset.value = initialValues[i];
                    node.dataset.converged = "false";
                    vizArea.appendChild(node);

                    nodes.push({
                        id: i,
                        element: node,
                        value: initialValues[i],
                        weight: 1.0,
                        converged: false,
                        position: { x, y },
                        convergenceThreshold:
                            parseInt(thresholdSlider.value) / 100,
                    });
                }

                // Create connections
                for (let i = 0; i < nodeCount; i++) {
                    for (let j = i + 1; j < nodeCount; j++) {
                        const node1 = nodes[i];
                        const node2 = nodes[j];

                        const dx = node2.position.x - node1.position.x;
                        const dy = node2.position.y - node1.position.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const angleLine = (Math.atan2(dy, dx) * 180) / Math.PI;

                        const connection = document.createElement("div");
                        connection.className = "node-connection";
                        connection.style.width = `${length}px`;
                        connection.style.left = `${node1.position.x}px`;
                        connection.style.top = `${node1.position.y}px`;
                        connection.style.transform = `rotate(${angleLine}deg)`;
                        vizArea.appendChild(connection);
                    }
                }

                // Reset counters
                currentRound = 0;
                convergedCount = 0;
                updateCounters();
            }

            // Reset node values
            function resetValues() {
                if (simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                    runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
                }

                initVisualization();
            }

            // Run simulation
            function runSimulation() {
                if (simulationInterval) {
                    clearInterval(simulationInterval);
                    simulationInterval = null;
                    runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
                    return;
                }

                runBtn.innerHTML = '<i class="fas fa-stop"></i> Stop';
                currentRound = 0;

                simulationInterval = setInterval(() => {
                    currentRound++;

                    // Perform gossip exchanges
                    const gossipExchanges = Math.ceil(nodes.length * 0.5); // 50% of nodes gossip each round
                    for (let i = 0; i < gossipExchanges; i++) {
                        const sourceIdx = Math.floor(
                            Math.random() * nodes.length,
                        );
                        const source = nodes[sourceIdx];

                        if (source.converged) continue;

                        // Select a random target
                        let targetIdx;
                        do {
                            targetIdx = Math.floor(
                                Math.random() * nodes.length,
                            );
                        } while (targetIdx === sourceIdx);

                        const target = nodes[targetIdx];

                        if (target.converged) continue;

                        // Animate gossip message
                        animateGossipMessage(source, target);

                        // Perform aggregation (weighted average)
                        const totalWeight = source.weight + target.weight;
                        const newValue =
                            (source.value * source.weight +
                                target.value * target.weight) /
                            totalWeight;

                        // Update both nodes (simplified)
                        source.value = newValue;
                        target.value = newValue;
                        source.weight = totalWeight / 2;
                        target.weight = totalWeight / 2;

                        // Update visual representation
                        source.element.innerHTML = source.value.toFixed(1);
                        target.element.innerHTML = target.value.toFixed(1);
                        source.element.dataset.value = source.value.toFixed(1);
                        target.element.dataset.value = target.value.toFixed(1);

                        // Check for convergence
                        if (
                            !source.converged &&
                            Math.abs(source.value - actualAverage) <
                                source.convergenceThreshold
                        ) {
                            source.converged = true;
                            source.element.classList.add("converged");
                            convergedCount++;
                        }

                        if (
                            !target.converged &&
                            Math.abs(target.value - actualAverage) <
                                target.convergenceThreshold
                        ) {
                            target.converged = true;
                            target.element.classList.add("converged");
                            convergedCount++;
                        }
                    }

                    updateCounters();

                    // Check if simulation should end (all nodes converged)
                    if (convergedCount >= nodes.length) {
                        clearInterval(simulationInterval);
                        simulationInterval = null;
                        runBtn.innerHTML =
                            '<i class="fas fa-redo"></i> Restart';

                        // Show convergence message
                        aggregationResult.innerHTML = `All nodes converged to average: ${actualAverage.toFixed(2)}`;
                        aggregationResult.style.color = "var(--success)";
                    }
                }, 1500);
            }

            // Animate gossip message between nodes
            function animateGossipMessage(source, target) {
                const message = document.createElement("div");
                message.className = "aggregation-message";
                message.innerHTML = "Avg";
                message.style.left = `${source.position.x}px`;
                message.style.top = `${source.position.y}px`;
                vizArea.appendChild(message);

                // Animate message movement
                setTimeout(() => {
                    message.style.left = `${target.position.x}px`;
                    message.style.top = `${target.position.y}px`;

                    // Remove message after animation
                    setTimeout(() => {
                        message.remove();
                    }, 500);
                }, 100);
            }

            // Update counters
            function updateCounters() {
                roundCount.textContent = currentRound;
                convergedNodes.textContent = convergedCount;

                // Calculate current average
                let sum = 0;
                nodes.forEach((node) => {
                    sum += node.value;
                });
                const avg = sum / nodes.length;
                currentAvg.textContent = avg.toFixed(2);
            }

            // Event listeners
            runBtn.addEventListener("click", runSimulation);
            resetBtn.addEventListener("click", resetValues);
            nodeCountSlider.addEventListener("input", initVisualization);

            // Initialize visualization on load
            window.addEventListener("load", initVisualization);
        </script>
    </body>
</html>
