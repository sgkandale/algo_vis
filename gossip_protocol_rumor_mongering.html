<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Rumor Mongering Algorithm | AlgoViz Hub</title>
        <meta
            content="Interactive visualization of the Rumor Mongering algorithm for distributed systems"
            name="description"
        />
        <meta
            content="rumor mongering, gossip protocol, distributed systems, epidemic algorithm, visualization, interactive"
            name="keywords"
        />
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
            rel="stylesheet"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap"
            rel="stylesheet"
        />
        <style>
            :root {
                --primary: #0f172a;
                --secondary: #1e293b;
                --accent: #6366f1;
                --accent-light: #818cf8;
                --accent-glow: rgba(99, 102, 241, 0.2);
                --text: #e2e8f0;
                --text-secondary: #94a3b8;
                --card-bg: rgba(30, 41, 59, 0.7);
                --success: #10b981;
                --warning: #f59e0b;
                --danger: #ef4444;
                --transition: all 0.3s ease;
                --radius: 12px;
                --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                --glow: 0 0 15px var(--accent-glow);
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background: linear-gradient(
                    135deg,
                    var(--primary),
                    var(--secondary)
                );
                color: var(--text);
                font-family: "Roboto", sans-serif;
                line-height: 1.6;
                min-height: 100vh;
                padding: 0;
                position: relative;
                overflow-x: hidden;
            }

            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background:
                    radial-gradient(
                        circle at 10% 20%,
                        rgba(99, 102, 241, 0.1) 0%,
                        transparent 20%
                    ),
                    radial-gradient(
                        circle at 90% 80%,
                        rgba(129, 140, 248, 0.1) 0%,
                        transparent 20%
                    );
                z-index: -1;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 20px;
            }

            /* Header Styles */
            header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px 0;
                position: relative;
                border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            }

            .logo {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .logo-icon {
                width: 50px;
                height: 50px;
                background: var(--accent);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: var(--glow);
            }

            .logo-icon i {
                font-size: 24px;
                color: white;
            }

            .logo-text h1 {
                font-family: "Roboto Mono", monospace;
                font-weight: 700;
                font-size: 28px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }

            .logo-text p {
                font-size: 14px;
                color: var(--text-secondary);
                letter-spacing: 1.5px;
            }

            .breadcrumb {
                font-size: 14px;
                color: var(--text-secondary);
                margin-top: 10px;
            }

            .breadcrumb a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .breadcrumb a:hover {
                text-decoration: underline;
            }

            /* Algorithm Header */
            .algorithm-header {
                margin: 40px 0;
                text-align: center;
                padding: 20px;
                background: var(--card-bg);
                border-radius: var(--radius);
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .algorithm-header::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .algorithm-header h1 {
                font-size: 42px;
                margin-bottom: 15px;
                background: linear-gradient(
                    to right,
                    var(--accent-light),
                    var(--accent)
                );
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                font-weight: 800;
            }

            .algorithm-header .category {
                font-size: 18px;
                color: var(--accent-light);
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

            .complexity-badge {
                display: inline-block;
                background: rgba(129, 140, 248, 0.2);
                color: var(--accent-light);
                padding: 6px 15px;
                border-radius: 20px;
                font-size: 16px;
                font-weight: 600;
                font-family: "Roboto Mono", monospace;
                margin-top: 15px;
            }

            /* Main Content Layout */
            .main-content {
                display: grid;
                grid-template-columns: 1fr 350px;
                gap: 30px;
                margin-bottom: 40px;
            }

            @media (max-width: 900px) {
                .main-content {
                    grid-template-columns: 1fr;
                }
            }

            /* Algorithm Detail Sections */
            .section {
                background: var(--card-bg);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                padding: 30px;
                margin-bottom: 30px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                backdrop-filter: blur(10px);
                position: relative;
                overflow: hidden;
            }

            .section::before {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 4px;
                background: linear-gradient(
                    to right,
                    var(--accent),
                    var(--accent-light)
                );
            }

            .section h2 {
                font-size: 26px;
                margin-bottom: 20px;
                color: var(--accent-light);
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .section h2 i {
                color: var(--accent);
                width: 36px;
                height: 36px;
                background: rgba(99, 102, 241, 0.2);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .section p {
                color: var(--text-secondary);
                font-size: 17px;
                line-height: 1.8;
                margin-bottom: 20px;
            }

            .key-points {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 20px;
                margin: 25px 0;
            }

            .point-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
            }

            .point-card h3 {
                color: var(--accent-light);
                margin-bottom: 12px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .point-card h3 i {
                color: var(--accent);
            }

            .point-card p {
                margin-bottom: 0;
                font-size: 15px;
            }

            /* Visualization Console */
            .visualization-console {
                background: rgba(15, 23, 42, 0.8);
                border-radius: var(--radius);
                padding: 25px;
                margin: 30px 0;
                border: 1px solid rgba(99, 102, 241, 0.3);
                box-shadow: var(--glow);
            }

            .console-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }

            .console-header h3 {
                color: var(--accent-light);
                font-size: 20px;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .console-controls {
                display: flex;
                gap: 10px;
            }

            .console-btn {
                background: var(--accent);
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .console-btn:hover {
                background: var(--accent-light);
            }

            .console-btn.secondary {
                background: rgba(148, 163, 184, 0.2);
            }

            .visualization-area {
                height: 300px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
                overflow: hidden;
            }

            .visualization-area::before {
                content: "Rumor Mongering Visualization";
                position: absolute;
                color: rgba(148, 163, 184, 0.5);
                font-size: 20px;
            }

            .console-input {
                display: flex;
                gap: 10px;
                margin-top: 20px;
            }

            .console-input input {
                flex: 1;
                padding: 12px 15px;
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(148, 163, 184, 0.2);
                border-radius: 5px;
                color: var(--text);
                font-family: "Roboto Mono", monospace;
            }

            .console-input input:focus {
                outline: none;
                border-color: var(--accent);
            }

            /* Algorithm Properties */
            .properties-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 20px;
                margin-top: 20px;
            }

            .property-card {
                background: rgba(15, 23, 42, 0.5);
                border-radius: var(--radius);
                padding: 20px;
                border: 1px solid rgba(148, 163, 184, 0.1);
                text-align: center;
            }

            .property-card h4 {
                color: var(--text-secondary);
                font-size: 14px;
                margin-bottom: 8px;
                font-weight: 400;
            }

            .property-card .value {
                font-size: 20px;
                font-weight: 700;
                color: var(--accent-light);
                font-family: "Roboto Mono", monospace;
            }

            /* Footer */
            footer {
                text-align: center;
                padding: 40px 0 30px;
                color: var(--text-secondary);
                font-size: 14px;
                border-top: 1px solid rgba(148, 163, 184, 0.1);
                margin-top: 40px;
            }

            footer p {
                margin: 10px 0;
            }

            .footer-links {
                display: flex;
                justify-content: center;
                gap: 25px;
                margin-top: 15px;
                flex-wrap: wrap;
                margin-bottom: 20px;
            }

            .footer-links a {
                color: var(--accent-light);
                text-decoration: none;
                transition: var(--transition);
            }

            .footer-links a:hover {
                color: var(--accent);
            }

            /* Animations */
            @keyframes float {
                0% {
                    transform: translateY(0px);
                }
                50% {
                    transform: translateY(-10px);
                }
                100% {
                    transform: translateY(0px);
                }
            }

            .floating {
                animation: float 6s ease-in-out infinite;
            }

            /* Responsive Design */
            @media (max-width: 768px) {
                header {
                    flex-direction: column;
                    gap: 25px;
                    text-align: center;
                }

                .algorithm-header h1 {
                    font-size: 32px;
                }

                .key-points {
                    grid-template-columns: 1fr;
                }
            }

            /* Code Block Styling */
            .code-block {
                background: #0d1117;
                border-radius: 8px;
                padding: 20px;
                margin: 25px 0;
                overflow-x: auto;
                font-family: "Roboto Mono", monospace;
                font-size: 15px;
                border: 1px solid rgba(99, 102, 241, 0.3);
            }

            .code-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                color: var(--text-secondary);
            }

            .copy-btn {
                background: rgba(99, 102, 241, 0.2);
                color: var(--accent-light);
                border: none;
                padding: 5px 10px;
                border-radius: 5px;
                cursor: pointer;
                font-family: "Roboto Mono", monospace;
                transition: var(--transition);
            }

            .copy-btn:hover {
                background: rgba(99, 102, 241, 0.3);
            }

            .code-block pre {
                margin: 0;
            }

            .code-block code {
                color: #c9d1d9;
                line-height: 1.5;
            }

            .keyword {
                color: #ff7b72;
            }
            .function {
                color: #d2a8ff;
            }
            .comment {
                color: #8b949e;
            }
            .string {
                color: #a5d6ff;
            }
            .number {
                color: #79c0ff;
            }

            /* Node visualization styles */
            .node {
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: var(--accent);
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                position: absolute;
                box-shadow: var(--glow);
                transition: all 0.5s ease;
            }

            .node-connection {
                position: absolute;
                height: 2px;
                background: rgba(129, 140, 248, 0.5);
                transform-origin: 0 0;
                z-index: -1;
            }

            .rumor-message {
                position: absolute;
                background: var(--warning);
                color: white;
                padding: 5px 10px;
                border-radius: 20px;
                font-size: 12px;
                opacity: 0;
                transition: all 0.5s ease;
            }

            .stats-panel {
                display: flex;
                justify-content: space-around;
                margin-top: 15px;
                font-family: "Roboto Mono", monospace;
                font-size: 14px;
            }

            .stat-item {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .stat-value {
                font-weight: bold;
                color: var(--accent-light);
                font-size: 18px;
            }

            .stat-label {
                color: var(--text-secondary);
                font-size: 12px;
            }
        </style>
        <meta
            content="Rumor Mongering Algorithm | AlgoViz Hub"
            property="og:title"
        />
        <meta
            content="Interactive visualization of the Rumor Mongering algorithm for distributed systems"
            property="og:description"
        />
        <meta content="article" property="og:type" />
        <meta
            content="https://sgkandale.github.io/rumor-mongering.html"
            property="og:url"
        />
        <meta content="AlgoViz Hub" property="og:site_name" />
        <meta content="summary" name="twitter:card" />
        <meta
            content="Rumor Mongering Algorithm | AlgoViz Hub"
            name="twitter:title"
        />
        <meta
            content="Interactive visualization of the Rumor Mongering algorithm for distributed systems"
            name="twitter:description"
        />
        <meta content="@sgkandale" name="twitter:site" />
        <link
            href="https://sgkandale.github.io/rumor-mongering.html"
            rel="canonical"
        />
        <script type="application/ld+json">
            {
                "@context": "https://schema.org",
                "@type": "Article",
                "headline": "Rumor Mongering Algorithm | AlgoViz Hub",
                "description": "Interactive visualization of the Rumor Mongering algorithm for distributed systems",
                "author": {
                    "@type": "Person",
                    "name": "Shantanu Kandale"
                },
                "publisher": {
                    "@type": "Organization",
                    "name": "AlgoViz Hub",
                    "logo": {
                        "@type": "ImageObject",
                        "url": "https://sgkandale.github.io/favicon.ico"
                    }
                },
                "mainEntityOfPage": {
                    "@type": "WebPage",
                    "@id": "https://sgkandale.github.io/rumor-mongering.html"
                }
            }
        </script>
    </head>
    <body>
        <div class="container">
            <!-- Header -->
            <header>
                <div class="logo">
                    <div class="logo-icon floating">
                        <i class="fas fa-project-diagram"></i>
                    </div>
                    <div class="logo-text">
                        <h1>AlgoViz Hub</h1>
                        <p>ALGORITHM VISUALIZATION REPOSITORY</p>
                        <div class="breadcrumb">
                            <a href="#"><i class="fas fa-home"></i> Home</a>
                            &gt; <a href="#">Distributed Systems</a> &gt;
                            <span>Rumor Mongering</span>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Algorithm Header -->
            <div class="algorithm-header">
                <h1>Rumor Mongering</h1>
                <div class="category">
                    <i class="fas fa-network-wired"></i> Gossip Protocol
                    Algorithm
                </div>
                <div class="complexity-badge">Dissemination Time: O(log n)</div>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <!-- Left Column: Algorithm Details -->
                <div class="left-column">
                    <!-- Description Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-file-alt"></i> Algorithm Overview
                        </h2>
                        <p>
                            Rumor Mongering is a gossip protocol used in
                            distributed systems for efficient information
                            dissemination. It operates by having nodes that
                            possess new information (rumors) periodically share
                            it with randomly selected peers. This creates an
                            epidemic-like spread of information throughout the
                            network.
                        </p>
                        <p>
                            Unlike Anti-Entropy which focuses on state
                            reconciliation, Rumor Mongering is designed for
                            rapid information propagation. Each node maintains a
                            rumor list and stops gossiping when it believes most
                            nodes have received the information, making it more
                            efficient for frequent updates.
                        </p>
                        <div class="key-points">
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-check-circle"></i> Key
                                    Feature
                                </h3>
                                <p>
                                    Efficient information dissemination with
                                    probabilistic guarantees
                                </p>
                            </div>
                            <div class="point-card">
                                <h3><i class="fas fa-bolt"></i> Performance</h3>
                                <p>
                                    Rapid propagation with O(log n) rounds to
                                    reach all nodes
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-shield-alt"></i> Robustness
                                </h3>
                                <p>
                                    Resilient to node failures and network
                                    partitions
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-project-diagram"></i>
                                    Approach
                                </h3>
                                <p>
                                    Epidemic-style rumor spreading with
                                    termination mechanism
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Visualization Console -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-laptop-code"></i> Interactive
                            Visualization
                        </h2>
                        <p>
                            Use the interactive console below to visualize how
                            the Rumor Mongering algorithm works. Adjust the
                            number of nodes, rumor starting point, and watch how
                            the rumor spreads through the network.
                        </p>
                        <div class="visualization-console">
                            <div class="console-header">
                                <h3>
                                    <i class="fas fa-play-circle"></i> Rumor
                                    Mongering Visualization
                                </h3>
                                <div class="console-controls">
                                    <button
                                        class="console-btn secondary"
                                        id="settings-btn"
                                    >
                                        <i class="fas fa-cog"></i> Settings
                                    </button>
                                    <button class="console-btn" id="run-btn">
                                        <i class="fas fa-play"></i> Run
                                    </button>
                                </div>
                            </div>
                            <div
                                class="visualization-area"
                                id="visualization-area"
                            >
                                <!-- Visualization will be rendered here -->
                            </div>
                            <div class="console-input">
                                <input
                                    type="range"
                                    id="node-count"
                                    min="5"
                                    max="15"
                                    value="8"
                                    style="width: 100%"
                                />
                                <button
                                    class="console-btn"
                                    id="random-rumor-btn"
                                >
                                    <i class="fas fa-random"></i> Random Rumor
                                </button>
                            </div>
                            <div class="stats-panel">
                                <div class="stat-item">
                                    <span class="stat-value" id="round-count"
                                        >0</span
                                    >
                                    <span class="stat-label">Rounds</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-value" id="infected-count"
                                        >0</span
                                    >
                                    <span class="stat-label"
                                        >Infected Nodes</span
                                    >
                                </div>
                                <div class="stat-item">
                                    <span class="stat-value" id="rumor-count"
                                        >1</span
                                    >
                                    <span class="stat-label"
                                        >Active Rumors</span
                                    >
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Algorithm Steps -->
                    <div class="section">
                        <h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
                        <p>
                            The Rumor Mongering algorithm operates through the
                            following steps to disseminate information:
                        </p>
                        <div class="key-points">
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-bullhorn"></i> 1. Rumor
                                    Creation
                                </h3>
                                <p>
                                    A node creates or receives new information,
                                    marking it as a "rumor" to be disseminated.
                                    The node becomes "infected" with the rumor
                                    and will participate in spreading it.
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-clock"></i> 2. Periodic
                                    Gossip
                                </h3>
                                <p>
                                    Each infected node periodically selects
                                    random peers to gossip with. The interval
                                    between gossip rounds is typically
                                    randomized to avoid synchronization.
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-share-alt"></i> 3. Rumor
                                    Spreading
                                </h3>
                                <p>
                                    During each gossip round, infected nodes
                                    send rumors to selected peers. Nodes
                                    receiving a rumor for the first time become
                                    infected and join the spreading process.
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-user-check"></i> 4.
                                    Feedback Mechanism
                                </h3>
                                <p>
                                    Nodes may exchange information about which
                                    rumors they've already received. This helps
                                    reduce redundant transmissions and improves
                                    efficiency.
                                </p>
                            </div>
                            <div class="point-card">
                                <h3>
                                    <i class="fas fa-ban"></i> 5. Rumor Removal
                                </h3>
                                <p>
                                    Nodes stop spreading a rumor after several
                                    rounds or when they believe most nodes have
                                    received it. This removal mechanism prevents
                                    infinite propagation.
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Pseudocode Section -->
                    <div class="section">
                        <h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
                        <div class="code-block">
                            <pre><code>// Node state
Node {
    id: unique identifier
    rumors: set of known rumors
    infected: boolean for each rumor
    counter: round counter for each rumor
}

// Initialization
On rumor creation at node n:
    n.rumors.add(rumor)
    n.infected[rumor] = true
    n.counter[rumor] = 0

// Periodic gossip task
Every T seconds:
    For each rumor r where infected[r] is true:
        If counter[r] < MAX_ROUNDS:
            Select k random peers
            For each peer p:
                Send rumor r to p
            counter[r] += 1
        Else:
            infected[r] = false  // Stop spreading

// Handling incoming rumor
On receiving rumor r from node s:
    If r not in rumors:
        rumors.add(r)
        infected[r] = true
        counter[r] = 0
        Send acknowledgment to s
    Else:
        // Already know this rumor
        Send negative acknowledgment to s</code></pre>
                        </div>
                    </div>

                    <!-- Implementation Section -->
                    <div class="section">
                        <h2><i class="fas fa-code"></i> Implementation</h2>
                        <p>
                            Below is a Python implementation of a simplified
                            Rumor Mongering algorithm. This example demonstrates
                            the core concepts of rumor propagation, round
                            counting, and termination.
                        </p>
                        <div class="code-block">
                            <div class="code-header">
                                <span>Python Implementation</span>
                                <button class="copy-btn">
                                    <i class="fas fa-copy"></i> Copy Code
                                </button>
                            </div>
                            <pre><code><span class="keyword">import</span> random
<span class="keyword">import</span> threading
<span class="keyword">import</span> time
<span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict

<span class="keyword">class</span> <span class="function">RumorNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self, node_id, all_nodes):
        self.id = node_id
        self.all_nodes = all_nodes
        self.rumors = set()
        self.infected = defaultdict(bool)
        self.counters = defaultdict(int)
        self.max_rounds = 5
        self.running = True

    <span class="keyword">def</span> <span class="function">start_gossip</span>(self):
        self.gossip_thread = threading.Thread(target=self._gossip_task)
        self.gossip_thread.daemon = True
        self.gossip_thread.start()

    <span class="keyword">def</span> <span class="function">_gossip_task</span>(self):
        <span class="keyword">while</span> self.running:
            time.sleep(random.uniform(0.9, 1.1))  <span class="comment"># Randomize interval</span>
            self._gossip_round()

    <span class="keyword">def</span> <span class="function">_gossip_round</span>(self):
        <span class="keyword">for</span> rumor <span class="keyword">in</span> list(self.rumors):
            <span class="keyword">if</span> self.infected[rumor]:
                <span class="keyword">if</span> self.counters[rumor] < self.max_rounds:
                    peers = self._select_random_peers(2)
                    <span class="keyword">for</span> peer <span class="keyword">in</span> peers:
                        self._send_rumor(rumor, peer)
                    self.counters[rumor] += 1
                <span class="keyword">else</span>:
                    self.infected[rumor] = False  <span class="comment"># Stop spreading</span>

    <span class="keyword">def</span> <span class="function">_select_random_peers</span>(self, count):
        available_peers = [n <span class="keyword">for</span> n <span class="keyword">in</span> self.all_nodes <span class="keyword">if</span> n.id != self.id]
        <span class="keyword">return</span> random.sample(available_peers, min(count, len(available_peers)))

    <span class="keyword">def</span> <span class="function">_send_rumor</span>(self, rumor, peer):
        <span class="comment"># In real implementation, this would be a network call</span>
        peer.receive_rumor(rumor, self)

    <span class="keyword">def</span> <span class="function">receive_rumor</span>(self, rumor, sender):
        <span class="keyword">if</span> rumor <span class="keyword">not</span> <span class="keyword">in</span> self.rumors:
            self.rumors.add(rumor)
            self.infected[rumor] = True
            self.counters[rumor] = 0
            print(f<span class="string">"Node {self.id} learned rumor {rumor} from Node {sender.id}"</span>)

    <span class="keyword">def</span> <span class="function">create_rumor</span>(self, rumor_id):
        self.rumors.add(rumor_id)
        self.infected[rumor_id] = True
        self.counters[rumor_id] = 0
        print(f<span class="string">"Node {self.id} created rumor {rumor_id}"</span>)

    <span class="keyword">def</span> <span class="function">stop</span>(self):
        self.running = False
        <span class="keyword">if</span> self.gossip_thread:
            self.gossip_thread.join()

<span class="comment"># Example usage</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    nodes = [RumorNode(i, []) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]
    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:
        node.all_nodes = nodes
        node.start_gossip()

    <span class="comment"># Start a rumor</span>
    nodes[<span class="number">0</span>].create_rumor(<span class="string">"R1"</span>)

    time.sleep(<span class="number">10</span>)  <span class="comment"># Let the rumor spread</span>

    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:
        node.stop()

    <span class="comment"># Check which nodes received the rumor</span>
    <span class="keyword">for</span> node <span class="keyword">in</span> nodes:
        print(f<span class="string">"Node {node.id} knows rumors: {node.rumors}"</span>)</code></pre>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Additional Info -->
                <div class="right-column">
                    <!-- Properties Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-info-circle"></i> Algorithm
                            Properties
                        </h2>
                        <div class="properties-grid">
                            <div class="property-card">
                                <h4>Category</h4>
                                <div class="value">Epidemic</div>
                            </div>
                            <div class="property-card">
                                <h4>Message Complexity</h4>
                                <div class="value">O(n log n)</div>
                            </div>
                            <div class="property-card">
                                <h4>Dissemination Time</h4>
                                <div class="value">O(log n)</div>
                            </div>
                            <div class="property-card">
                                <h4>Fault Tolerance</h4>
                                <div class="value">High</div>
                            </div>
                            <div class="property-card">
                                <h4>Scalability</h4>
                                <div class="value">High</div>
                            </div>
                            <div class="property-card">
                                <h4>Termination</h4>
                                <div class="value">Probabilistic</div>
                            </div>
                            <div class="property-card">
                                <h4>Network Overhead</h4>
                                <div class="value">Medium</div>
                            </div>
                            <div class="property-card">
                                <h4>Topology</h4>
                                <div class="value">Any</div>
                            </div>
                        </div>
                    </div>

                    <!-- Applications Section -->
                    <div class="section">
                        <h2><i class="fas fa-lightbulb"></i> Applications</h2>
                        <p>
                            Rumor Mongering is used in various distributed
                            systems where efficient information dissemination is
                            needed:
                        </p>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                Database replication systems
                            </li>
                            <li style="margin-bottom: 10px">
                                Membership management in clusters
                            </li>
                            <li style="margin-bottom: 10px">
                                Blockchain networks
                            </li>
                            <li style="margin-bottom: 10px">
                                News feeds and content distribution
                            </li>
                            <li>Sensor networks and IoT devices</li>
                        </ul>
                    </div>

                    <!-- Advantages Section -->
                    <div class="section">
                        <h2><i class="fas fa-plus-circle"></i> Advantages</h2>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                Highly resilient to node failures and network
                                partitions
                            </li>
                            <li style="margin-bottom: 10px">
                                Simple to implement with no central coordination
                            </li>
                            <li style="margin-bottom: 10px">
                                Scalable to very large networks
                            </li>
                            <li style="margin-bottom: 10px">
                                Adaptive to network topology changes
                            </li>
                            <li>
                                Provides probabilistic guarantees of delivery
                            </li>
                        </ul>
                    </div>

                    <!-- Limitations Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-exclamation-triangle"></i>
                            Limitations
                        </h2>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                Does not guarantee all nodes receive the
                                information
                            </li>
                            <li style="margin-bottom: 10px">
                                Can generate significant network traffic
                            </li>
                            <li style="margin-bottom: 10px">
                                Difficult to determine when to stop gossiping
                            </li>
                            <li>Might deliver information out of order</li>
                        </ul>
                    </div>

                    <!-- Comparison Section -->
                    <div class="section">
                        <h2>
                            <i class="fas fa-not-equal"></i> Vs. Anti-Entropy
                        </h2>
                        <ul
                            style="
                                padding-left: 20px;
                                margin: 15px 0;
                                color: var(--text-secondary);
                            "
                        >
                            <li style="margin-bottom: 10px">
                                <strong>Rumor Mongering</strong> is optimized
                                for speed of dissemination
                            </li>
                            <li style="margin-bottom: 10px">
                                <strong>Anti-Entropy</strong> focuses on state
                                reconciliation
                            </li>
                            <li style="margin-bottom: 10px">
                                <strong>Rumor Mongering</strong> uses a
                                termination condition
                            </li>
                            <li style="margin-bottom: 10px">
                                <strong>Anti-Entropy</strong> continues until
                                consistency is achieved
                            </li>
                            <li>
                                <strong>Rumor Mongering</strong> is better for
                                frequent updates
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <footer>
                <div class="footer-links">
                    <a
                        href="https://www.linkedin.com/in/sgkandale/"
                        target="_blank"
                        ><i class="fa-brands fa-linkedin"></i> LinkedIN</a
                    >
                    <a href="mailto:me@sgkandale.com"
                        ><i class="fa-solid fa-at"></i> E-Mail</a
                    >
                    <a href="https://buymeacoffee.com/sgkandale" target="_blank"
                        ><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a
                    >
                </div>
                <p>
                    AlgoViz Hub - Interactive Algorithm Visualization Platform
                </p>
                <p>Â© 2025 AlgoViz Hub. All rights reserved.</p>
            </footer>
        </div>

        <script>
            class RumorNode {
        constructor(id, allNodes) {
            this.id = id;
            this.allNodes = allNodes;
            this.infected = false;
            this.rounds = 0;
            this.maxRounds = 5;
            this.element = null;
            this.gossipInterval = null;
        }

        start() {
            this.gossipInterval = setInterval(() => this.gossip(), 1500);
        }

        stop() {
            clearInterval(this.gossipInterval);
        }

        gossip() {
            if (this.infected && this.rounds < this.maxRounds) {
                const peer = this.selectRandomPeer();
                if (peer) {
                    this.spreadTo(peer);
                }
                this.rounds++;
                if (this.rounds >= this.maxRounds) {
                    this.element.style.backgroundColor = 'var(--success)';
                }
            }
        }

        selectRandomPeer() {
            const availablePeers = this.allNodes.filter(node => node.id !== this.id && !node.infected);
            return availablePeers[Math.floor(Math.random() * availablePeers.length)];
        }

        spreadTo(peer) {
            peer.infect();
            this.visualizeGossip(peer);
        }
        
        infect() {
            if(!this.infected) {
                this.infected = true;
                this.element.style.backgroundColor = 'var(--warning)';
            }
        }

        visualizeGossip(peer) {
            const message = document.createElement("div");
            message.className = "rumor-message";
            message.textContent = "Rumor";
            
            const vizArea = document.querySelector('.visualization-area');
            vizArea.appendChild(message);

            const sourceRect = this.element.getBoundingClientRect();
            const targetRect = peer.element.getBoundingClientRect();
            const containerRect = vizArea.getBoundingClientRect();

            const sourceX = sourceRect.left - containerRect.left + sourceRect.width / 2;
            const sourceY = sourceRect.top - containerRect.top + sourceRect.height / 2;
            const targetX = targetRect.left - containerRect.left + targetRect.width / 2;
            const targetY = targetRect.top - containerRect.top + targetRect.height / 2;

            message.style.left = `${sourceX}px`;
            message.style.top = `${sourceY}px`;
            message.style.opacity = "1";

            setTimeout(() => {
                message.style.left = `${targetX}px`;
                message.style.top = `${targetY}px`;
                setTimeout(() => {
                    message.remove();
                }, 500);
            }, 100);
        }
    }

    class RumorMongeringSimulation {
        constructor() {
            this.nodes = [];
            this.simulationInterval = null;
            this.runBtn = document.getElementById("run-btn");
            this.randomRumorBtn = document.getElementById("random-rumor-btn");
            this.nodeCountSlider = document.getElementById("node-count");
            this.vizArea = document.getElementById("visualization-area");
            this.roundCountEl = document.getElementById("round-count");
            this.infectedCountEl = document.getElementById("infected-count");
            this.rumorCountEl = document.getElementById("rumor-count");
            
            this.init();
            this.setupEventListeners();
        }

        init() {
            this.stop();
            this.vizArea.innerHTML = '';
            this.nodes = [];
            
            const nodeCount = parseInt(this.nodeCountSlider.value);
            const width = this.vizArea.offsetWidth;
            const height = this.vizArea.offsetHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;

            for (let i = 0; i < nodeCount; i++) {
                const angle = (2 * Math.PI * i) / nodeCount;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                const nodeEl = document.createElement("div");
                nodeEl.className = "node";
                nodeEl.id = `node-${i}`;
                nodeEl.style.left = `${x - 30}px`;
                nodeEl.style.top = `${y - 30}px`;
                nodeEl.innerHTML = `N${i}`;
                this.vizArea.appendChild(nodeEl);
                
                const node = new RumorNode(i, this.nodes);
                node.element = nodeEl;
                this.nodes.push(node);
            }
            
            this.nodes.forEach(node => node.allNodes = this.nodes);
            this.updateCounters();
        }

        start() {
            if (this.simulationInterval) return;
            this.runBtn.innerHTML = '<i class="fas fa-stop"></i> Stop';
            this.nodes.forEach(node => node.start());
            this.simulationInterval = setInterval(() => this.updateCounters(), 100);
        }

        stop() {
            clearInterval(this.simulationInterval);
            this.simulationInterval = null;
            this.nodes.forEach(node => node.stop());
            this.runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
        }
        
        startRandomRumor() {
            this.init();
            if(this.nodes.length > 0) {
                const randomNode = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                randomNode.infect();
            }
            this.start();
        }

        updateCounters() {
            this.infectedCountEl.textContent = this.nodes.filter(n => n.infected).length;
            this.rumorCountEl.textContent = this.nodes.filter(n => n.infected && n.rounds < n.maxRounds).length;
        }

        setupEventListeners() {
            this.runBtn.addEventListener("click", () => {
                if (this.simulationInterval) this.stop();
                else this.start();
            });
            this.randomRumorBtn.addEventListener("click", () => this.startRandomRumor());
            this.nodeCountSlider.addEventListener("input", () => this.init());
        }
    }

    new RumorMongeringSimulation();
</script>
    </body>
</html>
