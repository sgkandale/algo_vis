<!DOCTYPE html>

<html lang="en">
<head><meta content="Study machine learning algorithms and their practical applications" name="description"/><meta content="machine learning algorithm, linear regression, logistic regression, decision tree, random forest, svm, knn, naive bayes, clustering, pca" name="keywords"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>DBSCAN Clustering | AlgoViz Hub</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap" rel="stylesheet"/>
<style>
      :root {
        --primary: #0f172a;
        --secondary: #1e293b;
        --accent: #6366f1;
        --accent-light: #818cf8;
        --accent-glow: rgba(99, 102, 241, 0.2);
        --text: #e2e8f0;
        --text-secondary: #94a3b8;
        --card-bg: rgba(30, 41, 59, 0.7);
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --transition: all 0.3s ease;
        --radius: 12px;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        --glow: 0 0 15px var(--accent-glow);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: var(--text);
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        min-height: 100vh;
        padding: 0;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 10% 20%,
            rgba(99, 102, 241, 0.1) 0%,
            transparent 20%
          ),
          radial-gradient(
            circle at 90% 80%,
            rgba(129, 140, 248, 0.1) 0%,
            transparent 20%
          );
        z-index: -1;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      /* Header Styles */
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 0;
        position: relative;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .logo-icon {
        width: 50px;
        height: 50px;
        background: var(--accent);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--glow);
      }

      .logo-icon i {
        font-size: 24px;
        color: white;
      }

      .logo-text h1 {
        font-family: "Roboto Mono", monospace;
        font-weight: 700;
        font-size: 28px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .logo-text p {
        font-size: 14px;
        color: var(--text-secondary);
        letter-spacing: 1.5px;
      }

      .breadcrumb {
        font-size: 14px;
        color: var(--text-secondary);
        margin-top: 10px;
      }

      .breadcrumb a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .breadcrumb a:hover {
        text-decoration: underline;
      }

      /* Algorithm Header */
      .algorithm-header {
        margin: 40px 0;
        text-align: center;
        padding: 20px;
        background: var(--card-bg);
        border-radius: var(--radius);
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .algorithm-header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .algorithm-header h1 {
        font-size: 42px;
        margin-bottom: 15px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 800;
      }

      .algorithm-header .category {
        font-size: 18px;
        color: var(--accent-light);
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .complexity-badge {
        display: inline-block;
        background: rgba(129, 140, 248, 0.2);
        color: var(--accent-light);
        padding: 6px 15px;
        border-radius: 20px;
        font-size: 16px;
        font-weight: 600;
        font-family: "Roboto Mono", monospace;
        margin-top: 15px;
      }

      /* Main Content Layout */
      .main-content {
        display: grid;
        grid-template-columns: 1fr 350px;
        gap: 30px;
        margin-bottom: 40px;
      }

      @media (max-width: 900px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }

      /* Algorithm Detail Sections */
      .section {
        background: var(--card-bg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 30px;
        margin-bottom: 30px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .section::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .section h2 {
        font-size: 26px;
        margin-bottom: 20px;
        color: var(--accent-light);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .section h2 i {
        color: var(--accent);
        width: 36px;
        height: 36px;
        background: rgba(99, 102, 241, 0.2);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .section p {
        color: var(--text-secondary);
        font-size: 17px;
        line-height: 1.8;
        margin-bottom: 20px;
      }

      .key-points {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin: 25px 0;
      }

      .point-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
      }

      .point-card h3 {
        color: var(--accent-light);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .point-card h3 i {
        color: var(--accent);
      }

      .point-card p {
        margin-bottom: 0;
        font-size: 15px;
      }

      /* Visualization Console */
      .visualization-console {
        background: rgba(15, 23, 42, 0.8);
        border-radius: var(--radius);
        padding: 25px;
        margin: 30px 0;
        border: 1px solid rgba(99, 102, 241, 0.3);
        box-shadow: var(--glow);
      }

      .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .console-header h3 {
        color: var(--accent-light);
        font-size: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .console-controls {
        display: flex;
        gap: 10px;
      }

      .console-btn {
        background: var(--accent);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .console-btn:hover {
        background: var(--accent-light);
      }

      .console-btn.secondary {
        background: rgba(148, 163, 184, 0.2);
      }

      .visualization-area {
        height: 400px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      .console-input {
        display: flex;
        gap: 10px;
        margin-top: 20px;
        flex-wrap: wrap;
      }

      .console-input input,
      .console-input select {
        flex: 1;
        padding: 12px 15px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 5px;
        color: var(--text);
        font-family: "Roboto Mono", monospace;
        min-width: 150px;
      }

      .console-input input:focus,
      .console-input select:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Algorithm Properties */
      .properties-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .property-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        text-align: center;
      }

      .property-card h4 {
        color: var(--text-secondary);
        font-size: 14px;
        margin-bottom: 8px;
        font-weight: 400;
      }

      .property-card .value {
        font-size: 20px;
        font-weight: 700;
        color: var(--accent-light);
        font-family: "Roboto Mono", monospace;
      }

      /* Footer */
      footer {
        text-align: center;
        padding: 40px 0 30px;
        color: var(--text-secondary);
        font-size: 14px;
        border-top: 1px solid rgba(148, 163, 184, 0.1);
        margin-top: 40px;
      }

      footer p {
        margin: 10px 0;
      }

      .footer-links {
        display: flex;
        justify-content: center;
        gap: 25px;
        margin-top: 15px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .footer-links a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .footer-links a:hover {
        color: var(--accent);
      }

      /* Animations */
      @keyframes float {
        0% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
        100% {
          transform: translateY(0px);
        }
      }

      .floating {
        animation: float 6s ease-in-out infinite;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        header {
          flex-direction: column;
          gap: 25px;
          text-align: center;
        }

        .algorithm-header h1 {
          font-size: 32px;
        }

        .key-points {
          grid-template-columns: 1fr;
        }
      }

      /* Code Block Styling */
      .code-block {
        background: #0d1117;
        border-radius: 8px;
        padding: 20px;
        margin: 25px 0;
        overflow-x: auto;
        font-family: "Roboto Mono", monospace;
        font-size: 15px;
        border: 1px solid rgba(99, 102, 241, 0.3);
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        color: var(--text-secondary);
      }

      .copy-btn {
        background: rgba(99, 102, 241, 0.2);
        color: var(--accent-light);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-block pre {
        margin: 0;
      }

      .code-block code {
        color: #c9d1d9;
        line-height: 1.5;
      }

      .keyword {
        color: #ff7b72;
      }
      .function {
        color: #d2a8ff;
      }
      .comment {
        color: #8b949e;
      }
      .string {
        color: #a5d6ff;
      }
      .number {
        color: #79c0ff;
      }

      /* DBSCAN Visualization */
      #dbscan-viz {
        width: 100%;
        height: 100%;
        position: relative;
      }

      .data-point {
        position: absolute;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: all 0.5s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        z-index: 10;
      }

      .core-point {
        border: 3px solid white;
        box-shadow: 0 0 8px currentColor;
      }

      .noise-point {
        background-color: var(--text-secondary) !important;
      }

      .epsilon-circle {
        position: absolute;
        border-radius: 50%;
        border: 2px dashed var(--accent-light);
        transform: translate(-50%, -50%);
        z-index: 5;
        opacity: 0.7;
      }

      .cluster-line {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.3);
        transform-origin: 0 0;
        z-index: 6;
      }

      .iteration-info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(30, 41, 59, 0.8);
        padding: 8px 12px;
        border-radius: 8px;
        font-family: "Roboto Mono", monospace;
        color: var(--accent-light);
        z-index: 20;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      .legend {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(30, 41, 59, 0.8);
        padding: 10px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 20;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }

      .legend-label {
        font-size: 12px;
        color: var(--text);
      }

      .param-controls {
        display: flex;
        gap: 15px;
        margin-top: 15px;
      }

      .param-slider {
        flex: 1;
      }

      .param-label {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: 5px;
      }

      .param-value {
        font-family: "Roboto Mono", monospace;
        color: var(--accent-light);
        text-align: center;
        margin-top: 5px;
      }

      /* Step-by-step instructions */
      .step-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 20px;
      }

      .step {
        display: flex;
        gap: 15px;
        padding: 15px;
        background: rgba(15, 23, 42, 0.3);
        border-radius: 8px;
        align-items: flex-start;
      }

      .step-number {
        background: var(--accent);
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        font-weight: bold;
        font-family: "Roboto Mono", monospace;
      }

      .step-content {
        flex: 1;
      }

      .step-content h4 {
        margin-bottom: 8px;
        color: var(--accent-light);
      }
    </style>
<meta content="DBSCAN Clustering | AlgoViz Hub" property="og:title"/><meta content="Study machine learning algorithms and their practical applications" property="og:description"/><meta content="article" property="og:type"/><meta content="https://sgkandale.github.io/machine_learning_dbscan.html" property="og:url"/><meta content="AlgoViz Hub" property="og:site_name"/><meta content="summary" name="twitter:card"/><meta content="DBSCAN Clustering | AlgoViz Hub" name="twitter:title"/><meta content="Study machine learning algorithms and their practical applications" name="twitter:description"/><meta content="@sgkandale" name="twitter:site"/><link href="https://sgkandale.github.io/machine_learning_dbscan.html" rel="canonical"/><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "DBSCAN Clustering | AlgoViz Hub",
  "description": "Study machine learning algorithms and their practical applications",
  "author": {
    "@type": "Person",
    "name": "Shantanu Kandale"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AlgoViz Hub",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sgkandale.github.io/favicon.ico"
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sgkandale.github.io/machine_learning_dbscan.html"
  }
}</script></head>
<body>
<div class="container">
<!-- Header -->
<header>
<div class="logo">
<div class="logo-icon floating">
<i class="fas fa-project-diagram"></i>
</div>
<div class="logo-text">
<h1>AlgoViz Hub</h1>
<p>ALGORITHM VISUALIZATION REPOSITORY</p>
<div class="breadcrumb">
<a href="#"><i class="fas fa-home"></i> Home</a> &gt;
              <a href="#">Unsupervised Learning</a> &gt;
              <span>DBSCAN Clustering</span>
</div>
</div>
</div>
</header>
<!-- Algorithm Header -->
<div class="algorithm-header">
<h1>DBSCAN Clustering</h1>
<div class="category">
<i class="fas fa-object-group"></i> Density-Based Clustering Algorithm
        </div>
<div class="complexity-badge">Time Complexity: O(n log n)</div>
</div>
<!-- Main Content -->
<div class="main-content">
<!-- Left Column: Algorithm Details -->
<div class="left-column">
<!-- Description Section -->
<div class="section">
<h2><i class="fas fa-file-alt"></i> Algorithm Overview</h2>
<p>
              DBSCAN (Density-Based Spatial Clustering of Applications with
              Noise) is a density-based clustering algorithm that groups
              together points that are closely packed together, marking points
              in low-density regions as outliers. Unlike centroid-based
              algorithms like K-Means, DBSCAN does not require specifying the
              number of clusters in advance.
            </p>
<p>
              DBSCAN is particularly effective for discovering clusters of
              arbitrary shapes and handling noise. It works by defining clusters
              as dense regions of points separated by regions of lower density.
            </p>
<div class="key-points">
<div class="point-card">
<h3><i class="fas fa-check-circle"></i> Key Feature</h3>
<p>
                  Discovers clusters of arbitrary shapes and identifies noise
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-bolt"></i> Performance</h3>
<p>
                  Efficient for large datasets with spatial indexing (O(n log
                  n))
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-memory"></i> Space</h3>
<p>Requires O(n) space for data storage</p>
</div>
<div class="point-card">
<h3><i class="fas fa-project-diagram"></i> Approach</h3>
<p>Based on density connectivity between points</p>
</div>
</div>
</div>
<!-- Visualization Console -->
<div class="section">
<h2>
<i class="fas fa-laptop-code"></i> Interactive Visualization
            </h2>
<p>
              Explore how DBSCAN identifies clusters based on density. Adjust
              the epsilon (ε) and minPoints parameters, then step through the
              algorithm to see how core points, border points, and noise are
              identified. Click "Generate Data" to create new datasets or
              "Reset" to start over.
            </p>
<div class="visualization-console">
<div class="console-header">
<h3><i class="fas fa-play-circle"></i> DBSCAN Clustering</h3>
<div class="console-controls">
<button class="console-btn" id="reset-btn">
<i class="fas fa-redo"></i> Reset
                  </button>
<button class="console-btn" id="step-btn">
<i class="fas fa-step-forward"></i> Step
                  </button>
<button class="console-btn" id="run-btn">
<i class="fas fa-play"></i> Run
                  </button>
</div>
</div>
<div class="visualization-area" id="visualization-area">
<div id="dbscan-viz">
<div class="iteration-info">Iteration: 0 | Clusters: 0</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color" style="background: #818cf8"></div>
<div class="legend-label">Core Point</div>
</div>
<div class="legend-item">
<div class="legend-color" style="background: #10b981"></div>
<div class="legend-label">Border Point</div>
</div>
<div class="legend-item">
<div class="legend-color" style="background: #ef4444"></div>
<div class="legend-label">Noise Point</div>
</div>
<div class="legend-item">
<div class="legend-color" style="background: #f59e0b"></div>
<div class="legend-label">Current Point</div>
</div>
</div>
</div>
</div>
<div class="console-input">
<div class="param-controls">
<div class="param-slider">
<div class="param-label">Epsilon (ε)</div>
<input id="epsilon" max="100" min="20" type="range" value="40"/>
<div class="param-value">
                      ε = <span id="epsilon-value">40</span>
</div>
</div>
<div class="param-slider">
<div class="param-label">Min Points</div>
<input id="min-points" max="10" min="3" type="range" value="4"/>
<div class="param-value">
                      MinPts = <span id="min-points-value">4</span>
</div>
</div>
</div>
<button class="console-btn" id="generate-btn">
<i class="fas fa-random"></i> Generate Data
                </button>
</div>
</div>
</div>
<!-- Algorithm Steps -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
<p>
              DBSCAN works by categorizing points and expanding clusters based
              on density:
            </p>
<div class="step-container">
<div class="step">
<div class="step-number">1</div>
<div class="step-content">
<h4>Point Classification</h4>
<p>
                    For each point, find points within ε distance (neighbors).
                  </p>
</div>
</div>
<div class="step">
<div class="step-number">2</div>
<div class="step-content">
<h4>Identify Core Points</h4>
<p>
                    If a point has ≥ minPts neighbors, mark it as a core point.
                  </p>
</div>
</div>
<div class="step">
<div class="step-number">3</div>
<div class="step-content">
<h4>Expand Clusters</h4>
<p>
                    For each core point, if not assigned to a cluster, start a
                    new cluster and add all density-reachable points.
                  </p>
</div>
</div>
<div class="step">
<div class="step-number">4</div>
<div class="step-content">
<h4>Identify Border Points</h4>
<p>
                    Points that are reachable from a core point but have fewer
                    than minPts neighbors are border points.
                  </p>
</div>
</div>
<div class="step">
<div class="step-number">5</div>
<div class="step-content">
<h4>Mark Noise</h4>
<p>
                    Points not reachable from any core point are marked as
                    noise.
                  </p>
</div>
</div>
</div>
</div>
<!-- Pseudocode Section -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
<div class="code-block">
<pre><code>function DBSCAN(data, ε, minPts):
    cluster_id = 0
    for each point p in data:
        if p is visited: continue
        mark p as visited
        neighbors = regionQuery(p, ε)
        if len(neighbors) &lt; minPts:
            mark p as noise
        else:
            cluster_id += 1
            expandCluster(p, neighbors, cluster_id, ε, minPts)

function expandCluster(p, neighbors, cluster_id, ε, minPts):
    add p to cluster cluster_id
    for each point q in neighbors:
        if q is not visited:
            mark q as visited
            q_neighbors = regionQuery(q, ε)
            if len(q_neighbors) &gt;= minPts:
                neighbors = neighbors ∪ q_neighbors
        if q is not assigned to any cluster:
            add q to cluster cluster_id

function regionQuery(p, ε):
    return all points within ε distance of p</code></pre>
</div>
</div>
<!-- Implementation Section -->
<div class="section">
<h2><i class="fas fa-code"></i> Implementation</h2>
<p>
              Below is a Python implementation of the DBSCAN clustering
              algorithm. The implementation includes core point identification,
              cluster expansion, and noise detection.
            </p>
<div class="code-block">
<div class="code-header">
<span>Python Implementation</span>
<button class="copy-btn">
<i class="fas fa-copy"></i> Copy Code
                </button>
</div>
<pre><code><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> NearestNeighbors
<span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt

<span class="keyword">class</span> <span class="function">DBSCAN</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, eps=0.5, min_samples=5):
        <span class="keyword">self</span>.eps = eps
        <span class="keyword">self</span>.min_samples = min_samples
        <span class="keyword">self</span>.labels_ = None
        
    <span class="keyword">def</span> <span class="function">fit</span>(<span class="keyword">self</span>, X):
        n_samples = X.shape[0]
        self.labels_ = -1 * np.ones(n_samples)  <span class="comment"># -1 for unvisited</span>
        cluster_id = 0
        
        <span class="comment"># Create nearest neighbors model for efficient region queries</span>
        nn = NearestNeighbors(radius=self.eps)
        nn.fit(X)
        
        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(n_samples):
            <span class="keyword">if</span> <span class="keyword">self</span>.labels_[i] != -1:
                <span class="keyword">continue</span>  <span class="comment"># Skip visited points</span>
                
            <span class="comment"># Find neighbors</span>
            neighbors = nn.radius_neighbors([X[i]], return_distance=False)[0]
            
            <span class="keyword">if</span> len(neighbors) &lt; <span class="keyword">self</span>.min_samples:
                <span class="keyword">self</span>.labels_[i] = -2  <span class="comment"># Mark as noise</span>
            <span class="keyword">else</span>:
                <span class="keyword">self</span>._expand_cluster(i, neighbors, cluster_id, nn)
                cluster_id += 1
                
        <span class="keyword">return</span> <span class="keyword">self</span>
    
    <span class="keyword">def</span> <span class="function">_expand_cluster</span>(<span class="keyword">self</span>, idx, neighbors, cluster_id, nn):
        <span class="comment"># Assign current point to cluster</span>
        <span class="keyword">self</span>.labels_[idx] = cluster_id
        queue = list(neighbors)
        i = 0
        
        <span class="keyword">while</span> i &lt; len(queue):
            point_idx = queue[i]
            
            <span class="comment"># If point is noise, add to current cluster</span>
            <span class="keyword">if</span> <span class="keyword">self</span>.labels_[point_idx] == -2:
                <span class="keyword">self</span>.labels_[point_idx] = cluster_id
                
            <span class="comment"># If point is unvisited</span>
            <span class="keyword">if</span> <span class="keyword">self</span>.labels_[point_idx] == -1:
                <span class="keyword">self</span>.labels_[point_idx] = cluster_id
                
                <span class="comment"># Find neighbors of this point</span>
                point_neighbors = nn.radius_neighbors([nn._fit_X[point_idx]], 
                                                     return_distance=False)[0]
                
                <span class="comment"># If core point, add its neighbors to queue</span>
                <span class="keyword">if</span> len(point_neighbors) &gt;= <span class="keyword">self</span>.min_samples:
                    <span class="comment"># Add new neighbors not already in queue</span>
                    <span class="keyword">for</span> n <span class="keyword">in</span> point_neighbors:
                        <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> queue:
                            queue.append(n)
            i += 1

<span class="comment"># Example usage</span>
<span class="comment"># Generate sample data</span>
X, y = make_blobs(n_samples=300, centers=3, cluster_std=0.6, random_state=42)

<span class="comment"># Add some noise</span>
noise = np.random.rand(20, 2) * 10 - 5
X = np.vstack([X, noise])

<span class="comment"># Create and fit DBSCAN model</span>
dbscan = DBSCAN(eps=0.5, min_samples=5)
dbscan.fit(X)
labels = dbscan.labels_

<span class="comment"># Visualize results</span>
plt.figure(figsize=(10, 6))
plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis', alpha=0.7)
plt.title(<span class="string">"DBSCAN Clustering Results"</span>)
plt.show()</code></pre>
</div>
</div>
</div>
<!-- Right Column: Additional Info -->
<div class="right-column">
<!-- Properties Section -->
<div class="section">
<h2><i class="fas fa-info-circle"></i> Algorithm Properties</h2>
<div class="properties-grid">
<div class="property-card">
<h4>Category</h4>
<div class="value">Clustering</div>
</div>
<div class="property-card">
<h4>Type</h4>
<div class="value">Density-Based</div>
</div>
<div class="property-card">
<h4>Supervision</h4>
<div class="value">Unsupervised</div>
</div>
<div class="property-card">
<h4>Parametric</h4>
<div class="value">No</div>
</div>
<div class="property-card">
<h4>Training Time</h4>
<div class="value">O(n log n)</div>
</div>
<div class="property-card">
<h4>Prediction Time</h4>
<div class="value">O(1)</div>
</div>
<div class="property-card">
<h4>Memory</h4>
<div class="value">O(n)</div>
</div>
<div class="property-card">
<h4>Hyperparameters</h4>
<div class="value">ε, minPts</div>
</div>
</div>
</div>
<!-- Applications Section -->
<div class="section">
<h2><i class="fas fa-lightbulb"></i> Applications</h2>
<p>
              DBSCAN is widely used in various domains for density-based
              clustering:
            </p>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
                Anomaly detection in network security
              </li>
<li style="margin-bottom: 10px">
                Geographic data analysis and hotspot detection
              </li>
<li style="margin-bottom: 10px">
                Image segmentation and computer vision
              </li>
<li style="margin-bottom: 10px">
                Customer segmentation in marketing
              </li>
<li>Astronomy data analysis (star/galaxy clustering)</li>
</ul>
</div>
<!-- Advantages Section -->
<div class="section">
<h2><i class="fas fa-thumbs-up"></i> Advantages</h2>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
                Discovers clusters of arbitrary shapes
              </li>
<li style="margin-bottom: 10px">Robust to noise and outliers</li>
<li style="margin-bottom: 10px">
                Does not require specifying number of clusters
              </li>
<li style="margin-bottom: 10px">
                Handles clusters of varying densities
              </li>
<li>Efficient with spatial indexing</li>
</ul>
</div>
<!-- Limitations Section -->
<div class="section">
<h2><i class="fas fa-exclamation-triangle"></i> Limitations</h2>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
                Sensitive to parameter selection (ε, minPts)
              </li>
<li style="margin-bottom: 10px">
                Struggles with clusters of varying densities
              </li>
<li style="margin-bottom: 10px">
                Performance degrades in high dimensions
              </li>
<li style="margin-bottom: 10px">
                Border points can belong to multiple clusters
              </li>
<li>Not deterministic for border points</li>
</ul>
</div>
<!-- Point Types Section -->
<div class="section">
<h2><i class="fas fa-dot-circle"></i> Point Types</h2>
<p>DBSCAN categorizes points into three types:</p>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
<b>Core Points:</b> Have at least minPts within ε distance
              </li>
<li style="margin-bottom: 10px">
<b>Border Points:</b> Within ε of a core point but have fewer
                than minPts neighbors
              </li>
<li style="margin-bottom: 10px">
<b>Noise Points:</b> Neither core nor border points
              </li>
</ul>
</div>
</div>
</div>
<!-- Footer -->
<footer>
<div class="footer-links">
<a href="https://www.linkedin.com/in/sgkandale/" target="_blank"><i class="fa-brands fa-linkedin"></i> LinkedIN</a>
<a href="mailto:me@sgkandale.com"><i class="fa-solid fa-at"></i> E-Mail</a>
<a href="https://buymeacoffee.com/sgkandale" target="_blank"><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a>
</div>
<p>AlgoViz Hub - Interactive Algorithm Visualization Platform</p>
<p>© 2025 AlgoViz Hub. All rights reserved.</p>
</footer>
</div>
<script>
    class DBSCANVisualization {
        constructor() {
            this.vizContainer = document.getElementById("dbscan-viz");
            this.runBtn = document.getElementById("run-btn");
            this.stepBtn = document.getElementById("step-btn");
            this.resetBtn = document.getElementById("reset-btn");
            this.generateBtn = document.getElementById("generate-btn");
            this.epsilonInput = document.getElementById("epsilon");
            this.epsilonValue = document.getElementById("epsilon-value");
            this.minPointsInput = document.getElementById("min-points");
            this.minPointsValue = document.getElementById("min-points-value");
            this.iterationInfo = document.querySelector(".iteration-info");

            this.dataPoints = [];
            this.animationId = null;
            this.colors = ["#818cf8", "#10b981", "#f59e0b", "#ef4444", "#a78bfa", "#60a5fa", "#f97316", "#eab308", "#22c55e", "#14b8a6", "#06b6d4", "#3b82f6", "#6366f1", "#a855f7", "#d946eef", "#ec4899"];
            this.width = this.vizContainer.clientWidth;
            this.height = this.vizContainer.clientHeight;

            this.currentPointIndex = 0;
            this.currentClusterId = 0;
            this.visitedPoints = new Set();
            this.clusters = []; // Stores arrays of point indices for each cluster

            this.setupEventListeners();
            this.generateData();
        }

        setupEventListeners() {
            this.runBtn.addEventListener("click", () => this.runAlgorithm());
            this.stepBtn.addEventListener("click", () => this.stepAlgorithm());
            this.resetBtn.addEventListener("click", () => this.resetVisualization());
            this.generateBtn.addEventListener("click", () => this.generateData());
            this.epsilonInput.addEventListener("input", () => {
                this.epsilonValue.textContent = this.epsilonInput.value;
                this.resetVisualization(); // Reset on parameter change
            });
            this.minPointsInput.addEventListener("input", () => {
                this.minPointsValue.textContent = this.minPointsInput.value;
                this.resetVisualization(); // Reset on parameter change
            });
        }

        generateData() {
            this.stopAnimation();
            this.dataPoints = [];
            this.vizContainer.innerHTML = ''; // Clear previous points
            this.currentPointIndex = 0;
            this.currentClusterId = 0;
            this.visitedPoints.clear();
            this.clusters = [];

            const pointCount = 200;
            const numClusters = 4;
            const clusterStd = 50; // Spread of points in a cluster

            for (let i = 0; i < numClusters; i++) {
                const centerX = Math.random() * (this.width - 2 * clusterStd) + clusterStd;
                const centerY = Math.random() * (this.height - 2 * clusterStd) + clusterStd;
                for (let j = 0; j < pointCount / numClusters; j++) {
                    this.dataPoints.push({
                        x: centerX + (Math.random() - 0.5) * clusterStd,
                        y: centerY + (Math.random() - 0.5) * clusterStd,
                        cluster: 0, // 0 = unclassified
                        type: 'unclassified' // unclassified, noise, border, core
                    });
                }
            }

            // Add some random noise points
            for (let i = 0; i < 20; i++) {
                this.dataPoints.push({
                    x: Math.random() * this.width,
                    y: Math.random() * this.height,
                    cluster: 0,
                    type: 'unclassified'
                });
            }

            this.render();
            this.updateIterationInfo();
        }

        render() {
            this.vizContainer.innerHTML = ''; // Clear previous points and circles/lines
            const epsilon = parseInt(this.epsilonInput.value);

            this.dataPoints.forEach((p, index) => {
                const pointEl = document.createElement("div");
                pointEl.className = "data-point";
                pointEl.style.left = `${p.x}px`;
                pointEl.style.top = `${p.y}px`;

                if (p.cluster > 0) {
                    pointEl.style.backgroundColor = this.colors[p.cluster % this.colors.length];
                } else if (p.type === 'noise') {
                    pointEl.style.backgroundColor = this.colors[3]; // Red for noise
                } else {
                    pointEl.style.backgroundColor = this.colors[0]; // Default unclassified color
                }

                if (p.type === 'core') {
                    pointEl.classList.add('core-point');
                } else if (p.type === 'noise') {
                    pointEl.classList.add('noise-point');
                }

                if (index === this.currentPointIndex && this.isAnimating) {
                    pointEl.style.backgroundColor = this.colors[2]; // Orange for current point
                }

                this.vizContainer.appendChild(pointEl);

                // Draw epsilon circle for core points
                if (p.type === 'core' && index === this.currentPointIndex) {
                    const circleEl = document.createElement("div");
                    circleEl.className = "epsilon-circle";
                    circleEl.style.width = `${2 * epsilon}px`;
                    circleEl.style.height = `${2 * epsilon}px`;
                    circleEl.style.left = `${p.x}px`;
                    circleEl.style.top = `${p.y}px`;
                    this.vizContainer.appendChild(circleEl);
                }
            });

            // Draw cluster lines (simplified: connect points within the same cluster)
            this.clusters.forEach(clusterIndices => {
                if (clusterIndices.length > 1) {
                    for (let i = 0; i < clusterIndices.length; i++) {
                        for (let j = i + 1; j < clusterIndices.length; j++) {
                            const p1 = this.dataPoints[clusterIndices[i]];
                            const p2 = this.dataPoints[clusterIndices[j]];
                            if (p1.cluster === p2.cluster && p1.cluster > 0) {
                                this.drawLine(p1, p2, this.colors[p1.cluster % this.colors.length]);
                            }
                        }
                    }
                }
            });
        }

        drawLine(p1, p2, color) {
            const line = document.createElement('div');
            line.className = 'cluster-line';
            const distance = this.distance(p1, p2);
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;

            line.style.width = `${distance}px`;
            line.style.left = `${p1.x}px`;
            line.style.top = `${p1.y}px`;
            line.style.transform = `rotate(${angle}deg)`;
            line.style.backgroundColor = color;
            line.style.height = '2px'; // Thickness of the line
            this.vizContainer.appendChild(line);
        }

        updateIterationInfo() {
            const numClusters = new Set(this.dataPoints.filter(p => p.cluster > 0).map(p => p.cluster)).size;
            this.iterationInfo.textContent = `Iteration: ${this.currentPointIndex} / ${this.dataPoints.length} | Clusters: ${numClusters}`;
        }

        runAlgorithm() {
            this.stopAnimation();
            this.isAnimating = true;
            this.animationId = setInterval(() => {
                if (!this.stepAlgorithm()) {
                    this.stopAnimation();
                }
            }, 100); // Adjust speed as needed
        }

        stepAlgorithm() {
            if (this.currentPointIndex >= this.dataPoints.length) {
                this.stopAnimation();
                return false;
            }

            const epsilon = parseInt(this.epsilonInput.value);
            const minPts = parseInt(this.minPointsInput.value);
            const p = this.dataPoints[this.currentPointIndex];

            if (!this.visitedPoints.has(p)) {
                this.visitedPoints.add(p);

                const neighbors = this.regionQuery(p, epsilon);

                if (neighbors.length >= minPts) {
                    p.type = 'core';
                    this.currentClusterId++;
                    p.cluster = this.currentClusterId;
                    this.clusters.push([this.currentPointIndex]); // Start new cluster with current point
                    this.expandCluster(p, neighbors, this.currentClusterId, epsilon, minPts);
                } else {
                    p.type = 'noise';
                }
            }

            this.currentPointIndex++;
            this.render();
            this.updateIterationInfo();
            return true;
        }

        expandCluster(p, neighbors, clusterId, epsilon, minPts) {
            let queue = [...neighbors];
            while (queue.length > 0) {
                const currentPoint = queue.shift();

                if (!this.visitedPoints.has(currentPoint)) {
                    this.visitedPoints.add(currentPoint);
                    const currentNeighbors = this.regionQuery(currentPoint, epsilon);

                    if (currentNeighbors.length >= minPts) {
                        currentPoint.type = 'core';
                        queue.push(...currentNeighbors);
                    } else {
                        currentPoint.type = 'border';
                    }
                }

                if (currentPoint.cluster === 0 || currentPoint.type === 'noise') {
                    currentPoint.cluster = clusterId;
                    this.clusters[clusterId - 1].push(this.dataPoints.indexOf(currentPoint));
                }
            }
        }

        regionQuery(point, epsilon) {
            return this.dataPoints.filter(p => this.distance(point, p) <= epsilon && p !== point);
        }

        distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        resetVisualization() {
            this.stopAnimation();
            this.dataPoints = [];
            this.currentPointIndex = 0;
            this.currentClusterId = 0;
            this.visitedPoints.clear();
            this.clusters = [];
            this.generateData(); // Regenerate data on reset
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        new DBSCANVisualization();
    });
</script>
</body>
</html>
