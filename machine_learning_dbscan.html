<!DOCTYPE html>

<html lang="en">
<head><meta content="Study machine learning algorithms and their practical applications" name="description"/><meta content="machine learning algorithm, linear regression, logistic regression, decision tree, random forest, svm, knn, naive bayes, clustering, pca" name="keywords"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>DBSCAN Clustering | AlgoViz Hub</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap" rel="stylesheet"/>
<style>
      :root {
        --primary: #0f172a;
        --secondary: #1e293b;
        --accent: #6366f1;
        --accent-light: #818cf8;
        --accent-glow: rgba(99, 102, 241, 0.2);
        --text: #e2e8f0;
        --text-secondary: #94a3b8;
        --card-bg: rgba(30, 41, 59, 0.7);
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --transition: all 0.3s ease;
        --radius: 12px;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        --glow: 0 0 15px var(--accent-glow);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: var(--text);
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        min-height: 100vh;
        padding: 0;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 10% 20%,
            rgba(99, 102, 241, 0.1) 0%,
            transparent 20%
          ),
          radial-gradient(
            circle at 90% 80%,
            rgba(129, 140, 248, 0.1) 0%,
            transparent 20%
          );
        z-index: -1;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      /* Header Styles */
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 0;
        position: relative;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .logo-icon {
        width: 50px;
        height: 50px;
        background: var(--accent);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--glow);
      }

      .logo-icon i {
        font-size: 24px;
        color: white;
      }

      .logo-text h1 {
        font-family: "Roboto Mono", monospace;
        font-weight: 700;
        font-size: 28px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .logo-text p {
        font-size: 14px;
        color: var(--text-secondary);
        letter-spacing: 1.5px;
      }

      .breadcrumb {
        font-size: 14px;
        color: var(--text-secondary);
        margin-top: 10px;
      }

      .breadcrumb a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .breadcrumb a:hover {
        text-decoration: underline;
      }

      /* Algorithm Header */
      .algorithm-header {
        margin: 40px 0;
        text-align: center;
        padding: 20px;
        background: var(--card-bg);
        border-radius: var(--radius);
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .algorithm-header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .algorithm-header h1 {
        font-size: 42px;
        margin-bottom: 15px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 800;
      }

      .algorithm-header .category {
        font-size: 18px;
        color: var(--accent-light);
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .complexity-badge {
        display: inline-block;
        background: rgba(129, 140, 248, 0.2);
        color: var(--accent-light);
        padding: 6px 15px;
        border-radius: 20px;
        font-size: 16px;
        font-weight: 600;
        font-family: "Roboto Mono", monospace;
        margin-top: 15px;
      }

      /* Main Content Layout */
      .main-content {
        display: grid;
        grid-template-columns: 1fr 350px;
        gap: 30px;
        margin-bottom: 40px;
      }

      @media (max-width: 900px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }

      /* Algorithm Detail Sections */
      .section {
        background: var(--card-bg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 30px;
        margin-bottom: 30px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .section::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .section h2 {
        font-size: 26px;
        margin-bottom: 20px;
        color: var(--accent-light);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .section h2 i {
        color: var(--accent);
        width: 36px;
        height: 36px;
        background: rgba(99, 102, 241, 0.2);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .section p {
        color: var(--text-secondary);
        font-size: 17px;
        line-height: 1.8;
        margin-bottom: 20px;
      }

      .key-points {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin: 25px 0;
      }

      .point-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
      }

      .point-card h3 {
        color: var(--accent-light);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .point-card h3 i {
        color: var(--accent);
      }

      .point-card p {
        margin-bottom: 0;
        font-size: 15px;
      }

      /* Visualization Console */
      .visualization-console {
        background: rgba(15, 23, 42, 0.8);
        border-radius: var(--radius);
        padding: 25px;
        margin: 30px 0;
        border: 1px solid rgba(99, 102, 241, 0.3);
        box-shadow: var(--glow);
      }

      .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .console-header h3 {
        color: var(--accent-light);
        font-size: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .console-controls {
        display: flex;
        gap: 10px;
      }

      .console-btn {
        background: var(--accent);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .console-btn:hover {
        background: var(--accent-light);
      }

      .console-btn.secondary {
        background: rgba(148, 163, 184, 0.2);
      }

      .visualization-area {
        height: 400px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      .console-input {
        display: flex;
        gap: 10px;
        margin-top: 20px;
        flex-wrap: wrap;
      }

      .console-input input,
      .console-input select {
        flex: 1;
        padding: 12px 15px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 5px;
        color: var(--text);
        font-family: "Roboto Mono", monospace;
        min-width: 150px;
      }

      .console-input input:focus,
      .console-input select:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Algorithm Properties */
      .properties-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .property-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        text-align: center;
      }

      .property-card h4 {
        color: var(--text-secondary);
        font-size: 14px;
        margin-bottom: 8px;
        font-weight: 400;
      }

      .property-card .value {
        font-size: 20px;
        font-weight: 700;
        color: var(--accent-light);
        font-family: "Roboto Mono", monospace;
      }

      /* Footer */
      footer {
        text-align: center;
        padding: 40px 0 30px;
        color: var(--text-secondary);
        font-size: 14px;
        border-top: 1px solid rgba(148, 163, 184, 0.1);
        margin-top: 40px;
      }

      footer p {
        margin: 10px 0;
      }

      .footer-links {
        display: flex;
        justify-content: center;
        gap: 25px;
        margin-top: 15px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .footer-links a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .footer-links a:hover {
        color: var(--accent);
      }

      /* Animations */
      @keyframes float {
        0% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
        100% {
          transform: translateY(0px);
        }
      }

      .floating {
        animation: float 6s ease-in-out infinite;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        header {
          flex-direction: column;
          gap: 25px;
          text-align: center;
        }

        .algorithm-header h1 {
          font-size: 32px;
        }

        .key-points {
          grid-template-columns: 1fr;
        }
      }

      /* Code Block Styling */
      .code-block {
        background: #0d1117;
        border-radius: 8px;
        padding: 20px;
        margin: 25px 0;
        overflow-x: auto;
        font-family: "Roboto Mono", monospace;
        font-size: 15px;
        border: 1px solid rgba(99, 102, 241, 0.3);
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        color: var(--text-secondary);
      }

      .copy-btn {
        background: rgba(99, 102, 241, 0.2);
        color: var(--accent-light);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-block pre {
        margin: 0;
      }

      .code-block code {
        color: #c9d1d9;
        line-height: 1.5;
      }

      .keyword {
        color: #ff7b72;
      }
      .function {
        color: #d2a8ff;
      }
      .comment {
        color: #8b949e;
      }
      .string {
        color: #a5d6ff;
      }
      .number {
        color: #79c0ff;
      }

      /* DBSCAN Visualization */
      #dbscan-viz {
        width: 100%;
        height: 100%;
        position: relative;
      }

      .data-point {
        position: absolute;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: all 0.5s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        z-index: 10;
      }

      .core-point {
        border: 3px solid white;
        box-shadow: 0 0 8px currentColor;
      }

      .noise-point {
        background-color: var(--text-secondary) !important;
      }

      .epsilon-circle {
        position: absolute;
        border-radius: 50%;
        border: 2px dashed var(--accent-light);
        transform: translate(-50%, -50%);
        z-index: 5;
        opacity: 0.7;
      }

      .cluster-line {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.3);
        transform-origin: 0 0;
        z-index: 6;
      }

      .iteration-info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(30, 41, 59, 0.8);
        padding: 8px 12px;
        border-radius: 8px;
        font-family: "Roboto Mono", monospace;
        color: var(--accent-light);
        z-index: 20;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      .legend {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(30, 41, 59, 0.8);
        padding: 10px;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        z-index: 20;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }

      .legend-label {
        font-size: 12px;
        color: var(--text);
      }

      .param-controls {
        display: flex;
        gap: 15px;
        margin-top: 15px;
      }

      .param-slider {
        flex: 1;
      }

      .param-label {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: 5px;
      }

      .param-value {
        font-family: "Roboto Mono", monospace;
        color: var(--accent-light);
        text-align: center;
        margin-top: 5px;
      }

      /* Step-by-step instructions */
      .step-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 20px;
      }

      .step {
        display: flex;
        gap: 15px;
        padding: 15px;
        background: rgba(15, 23, 42, 0.3);
        border-radius: 8px;
        align-items: flex-start;
      }

      .step-number {
        background: var(--accent);
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        font-weight: bold;
        font-family: "Roboto Mono", monospace;
      }

      .step-content {
        flex: 1;
      }

      .step-content h4 {
        margin-bottom: 8px;
        color: var(--accent-light);
      }
    </style>
<meta content="DBSCAN Clustering | AlgoViz Hub" property="og:title"/><meta content="Study machine learning algorithms and their practical applications" property="og:description"/><meta content="article" property="og:type"/><meta content="https://sgkandale.github.io/machine_learning_dbscan.html" property="og:url"/><meta content="AlgoViz Hub" property="og:site_name"/><meta content="summary" name="twitter:card"/><meta content="DBSCAN Clustering | AlgoViz Hub" name="twitter:title"/><meta content="Study machine learning algorithms and their practical applications" name="twitter:description"/><meta content="@sgkandale" name="twitter:site"/><link href="https://sgkandale.github.io/machine_learning_dbscan.html" rel="canonical"/><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "DBSCAN Clustering | AlgoViz Hub",
  "description": "Study machine learning algorithms and their practical applications",
  "author": {
    "@type": "Person",
    "name": "Shantanu Kandale"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AlgoViz Hub",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sgkandale.github.io/favicon.ico"
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sgkandale.github.io/machine_learning_dbscan.html"
  }
}</script></head>
<body>
<div class="container">
<!-- Header -->
<header>
<div class="logo">
<div class="logo-icon floating">
<i class="fas fa-project-diagram"></i>
</div>
<div class="logo-text">
<h1>AlgoViz Hub</h1>
<p>ALGORITHM VISUALIZATION REPOSITORY</p>
<div class="breadcrumb">
<a href="#"><i class="fas fa-home"></i> Home</a> &gt;
              <a href="#">Unsupervised Learning</a> &gt;
              <span>DBSCAN Clustering</span>
</div>
</div>
</div>
</header>
<!-- Algorithm Header -->
<div class="algorithm-header">
<h1>DBSCAN Clustering</h1>
<div class="category">
<i class="fas fa-object-group"></i> Density-Based Clustering Algorithm
        </div>
<div class="complexity-badge">Time Complexity: O(n log n)</div>
</div>
<!-- Main Content -->
<div class="main-content">
<!-- Left Column: Algorithm Details -->
<div class="left-column">
<!-- Description Section -->
<div class="section">
<h2><i class="fas fa-file-alt"></i> Algorithm Overview</h2>
<p>
              DBSCAN (Density-Based Spatial Clustering of Applications with
              Noise) is a density-based clustering algorithm that groups
              together points that are closely packed together, marking points
              in low-density regions as outliers. Unlike centroid-based
              algorithms like K-Means, DBSCAN does not require specifying the
              number of clusters in advance.
            </p>
<p>
              DBSCAN is particularly effective for discovering clusters of
              arbitrary shapes and handling noise. It works by defining clusters
              as dense regions of points separated by regions of lower density.
            </p>
<div class="key-points">
<div class="point-card">
<h3><i class="fas fa-check-circle"></i> Key Feature</h3>
<p>
                  Discovers clusters of arbitrary shapes and identifies noise
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-bolt"></i> Performance</h3>
<p>
                  Efficient for large datasets with spatial indexing (O(n log
                  n))
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-memory"></i> Space</h3>
<p>Requires O(n) space for data storage</p>
</div>
<div class="point-card">
<h3><i class="fas fa-project-diagram"></i> Approach</h3>
<p>Based on density connectivity between points</p>
</div>
</div>
</div>
<!-- Visualization Console -->
<div class="section">
<h2>
<i class="fas fa-laptop-code"></i> Interactive Visualization
            </h2>
<p>
              Explore how DBSCAN identifies clusters based on density. Adjust
              the epsilon (ε) and minPoints parameters, then step through the
              algorithm to see how core points, border points, and noise are
              identified. Click "Generate Data" to create new datasets or
              "Reset" to start over.
            </p>
<div class="visualization-console">
<div class="console-header">
<h3><i class="fas fa-play-circle"></i> DBSCAN Clustering</h3>
<div class="console-controls">
<button class="console-btn" id="reset-btn">
<i class="fas fa-redo"></i> Reset
                  </button>
<button class="console-btn" id="step-btn">
<i class="fas fa-step-forward"></i> Step
                  </button>
<button class="console-btn" id="run-btn">
<i class="fas fa-play"></i> Run
                  </button>
</div>
</div>
<div class="visualization-area" id="visualization-area">
<div id="dbscan-viz">
<div class="iteration-info">Iteration: 0 | Clusters: 0</div>
<div class="legend">
<div class="legend-item">
<div class="legend-color" style="background: #818cf8"></div>
<div class="legend-label">Core Point</div>
</div>
<div class="legend-item">
<div class="legend-color" style="background: #10b981"></div>
<div class="legend-label">Border Point</div>
</div>
<div class="legend-item">
<div class="legend-color" style="background: #ef4444"></div>
<div class="legend-label">Noise Point</div>
</div>
<div class="legend-item">
<div class="legend-color" style="background: #f59e0b"></div>
<div class="legend-label">Current Point</div>
</div>
</div>
</div>
</div>
<div class="console-input">
<div class="param-controls">
<div class="param-slider">
<div class="param-label">Epsilon (ε)</div>
<input id="epsilon" max="100" min="20" type="range" value="40"/>
<div class="param-value">
                      ε = <span id="epsilon-value">40</span>
</div>
</div>
<div class="param-slider">
<div class="param-label">Min Points</div>
<input id="min-points" max="10" min="3" type="range" value="4"/>
<div class="param-value">
                      MinPts = <span id="min-points-value">4</span>
</div>
</div>
</div>
<button class="console-btn" id="generate-btn">
<i class="fas fa-random"></i> Generate Data
                </button>
</div>
</div>
</div>
<!-- Algorithm Steps -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
<p>
              DBSCAN works by categorizing points and expanding clusters based
              on density:
            </p>
<div class="step-container">
<div class="step">
<div class="step-number">1</div>
<div class="step-content">
<h4>Point Classification</h4>
<p>
                    For each point, find points within ε distance (neighbors).
                  </p>
</div>
</div>
<div class="step">
<div class="step-number">2</div>
<div class="step-content">
<h4>Identify Core Points</h4>
<p>
                    If a point has ≥ minPts neighbors, mark it as a core point.
                  </p>
</div>
</div>
<div class="step">
<div class="step-number">3</div>
<div class="step-content">
<h4>Expand Clusters</h4>
<p>
                    For each core point, if not assigned to a cluster, start a
                    new cluster and add all density-reachable points.
                  </p>
</div>
</div>
<div class="step">
<div class="step-number">4</div>
<div class="step-content">
<h4>Identify Border Points</h4>
<p>
                    Points that are reachable from a core point but have fewer
                    than minPts neighbors are border points.
                  </p>
</div>
</div>
<div class="step">
<div class="step-number">5</div>
<div class="step-content">
<h4>Mark Noise</h4>
<p>
                    Points not reachable from any core point are marked as
                    noise.
                  </p>
</div>
</div>
</div>
</div>
<!-- Pseudocode Section -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
<div class="code-block">
<pre><code>function DBSCAN(data, ε, minPts):
    cluster_id = 0
    for each point p in data:
        if p is visited: continue
        mark p as visited
        neighbors = regionQuery(p, ε)
        if len(neighbors) &lt; minPts:
            mark p as noise
        else:
            cluster_id += 1
            expandCluster(p, neighbors, cluster_id, ε, minPts)

function expandCluster(p, neighbors, cluster_id, ε, minPts):
    add p to cluster cluster_id
    for each point q in neighbors:
        if q is not visited:
            mark q as visited
            q_neighbors = regionQuery(q, ε)
            if len(q_neighbors) &gt;= minPts:
                neighbors = neighbors ∪ q_neighbors
        if q is not assigned to any cluster:
            add q to cluster cluster_id

function regionQuery(p, ε):
    return all points within ε distance of p</code></pre>
</div>
</div>
<!-- Implementation Section -->
<div class="section">
<h2><i class="fas fa-code"></i> Implementation</h2>
<p>
              Below is a Python implementation of the DBSCAN clustering
              algorithm. The implementation includes core point identification,
              cluster expansion, and noise detection.
            </p>
<div class="code-block">
<div class="code-header">
<span>Python Implementation</span>
<button class="copy-btn">
<i class="fas fa-copy"></i> Copy Code
                </button>
</div>
<pre><code><span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> NearestNeighbors
<span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt

<span class="keyword">class</span> <span class="function">DBSCAN</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, eps=0.5, min_samples=5):
        <span class="keyword">self</span>.eps = eps
        <span class="keyword">self</span>.min_samples = min_samples
        <span class="keyword">self</span>.labels_ = None
        
    <span class="keyword">def</span> <span class="function">fit</span>(<span class="keyword">self</span>, X):
        n_samples = X.shape[0]
        self.labels_ = -1 * np.ones(n_samples)  <span class="comment"># -1 for unvisited</span>
        cluster_id = 0
        
        <span class="comment"># Create nearest neighbors model for efficient region queries</span>
        nn = NearestNeighbors(radius=self.eps)
        nn.fit(X)
        
        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(n_samples):
            <span class="keyword">if</span> <span class="keyword">self</span>.labels_[i] != -1:
                <span class="keyword">continue</span>  <span class="comment"># Skip visited points</span>
                
            <span class="comment"># Find neighbors</span>
            neighbors = nn.radius_neighbors([X[i]], return_distance=False)[0]
            
            <span class="keyword">if</span> len(neighbors) &lt; <span class="keyword">self</span>.min_samples:
                <span class="keyword">self</span>.labels_[i] = -2  <span class="comment"># Mark as noise</span>
            <span class="keyword">else</span>:
                <span class="keyword">self</span>._expand_cluster(i, neighbors, cluster_id, nn)
                cluster_id += 1
                
        <span class="keyword">return</span> <span class="keyword">self</span>
    
    <span class="keyword">def</span> <span class="function">_expand_cluster</span>(<span class="keyword">self</span>, idx, neighbors, cluster_id, nn):
        <span class="comment"># Assign current point to cluster</span>
        <span class="keyword">self</span>.labels_[idx] = cluster_id
        queue = list(neighbors)
        i = 0
        
        <span class="keyword">while</span> i &lt; len(queue):
            point_idx = queue[i]
            
            <span class="comment"># If point is noise, add to current cluster</span>
            <span class="keyword">if</span> <span class="keyword">self</span>.labels_[point_idx] == -2:
                <span class="keyword">self</span>.labels_[point_idx] = cluster_id
                
            <span class="comment"># If point is unvisited</span>
            <span class="keyword">if</span> <span class="keyword">self</span>.labels_[point_idx] == -1:
                <span class="keyword">self</span>.labels_[point_idx] = cluster_id
                
                <span class="comment"># Find neighbors of this point</span>
                point_neighbors = nn.radius_neighbors([nn._fit_X[point_idx]], 
                                                     return_distance=False)[0]
                
                <span class="comment"># If core point, add its neighbors to queue</span>
                <span class="keyword">if</span> len(point_neighbors) &gt;= <span class="keyword">self</span>.min_samples:
                    <span class="comment"># Add new neighbors not already in queue</span>
                    <span class="keyword">for</span> n <span class="keyword">in</span> point_neighbors:
                        <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> queue:
                            queue.append(n)
            i += 1

<span class="comment"># Example usage</span>
<span class="comment"># Generate sample data</span>
X, y = make_blobs(n_samples=300, centers=3, cluster_std=0.6, random_state=42)

<span class="comment"># Add some noise</span>
noise = np.random.rand(20, 2) * 10 - 5
X = np.vstack([X, noise])

<span class="comment"># Create and fit DBSCAN model</span>
dbscan = DBSCAN(eps=0.5, min_samples=5)
dbscan.fit(X)
labels = dbscan.labels_

<span class="comment"># Visualize results</span>
plt.figure(figsize=(10, 6))
plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis', alpha=0.7)
plt.title(<span class="string">"DBSCAN Clustering Results"</span>)
plt.show()</code></pre>
</div>
</div>
</div>
<!-- Right Column: Additional Info -->
<div class="right-column">
<!-- Properties Section -->
<div class="section">
<h2><i class="fas fa-info-circle"></i> Algorithm Properties</h2>
<div class="properties-grid">
<div class="property-card">
<h4>Category</h4>
<div class="value">Clustering</div>
</div>
<div class="property-card">
<h4>Type</h4>
<div class="value">Density-Based</div>
</div>
<div class="property-card">
<h4>Supervision</h4>
<div class="value">Unsupervised</div>
</div>
<div class="property-card">
<h4>Parametric</h4>
<div class="value">No</div>
</div>
<div class="property-card">
<h4>Training Time</h4>
<div class="value">O(n log n)</div>
</div>
<div class="property-card">
<h4>Prediction Time</h4>
<div class="value">O(1)</div>
</div>
<div class="property-card">
<h4>Memory</h4>
<div class="value">O(n)</div>
</div>
<div class="property-card">
<h4>Hyperparameters</h4>
<div class="value">ε, minPts</div>
</div>
</div>
</div>
<!-- Applications Section -->
<div class="section">
<h2><i class="fas fa-lightbulb"></i> Applications</h2>
<p>
              DBSCAN is widely used in various domains for density-based
              clustering:
            </p>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
                Anomaly detection in network security
              </li>
<li style="margin-bottom: 10px">
                Geographic data analysis and hotspot detection
              </li>
<li style="margin-bottom: 10px">
                Image segmentation and computer vision
              </li>
<li style="margin-bottom: 10px">
                Customer segmentation in marketing
              </li>
<li>Astronomy data analysis (star/galaxy clustering)</li>
</ul>
</div>
<!-- Advantages Section -->
<div class="section">
<h2><i class="fas fa-thumbs-up"></i> Advantages</h2>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
                Discovers clusters of arbitrary shapes
              </li>
<li style="margin-bottom: 10px">Robust to noise and outliers</li>
<li style="margin-bottom: 10px">
                Does not require specifying number of clusters
              </li>
<li style="margin-bottom: 10px">
                Handles clusters of varying densities
              </li>
<li>Efficient with spatial indexing</li>
</ul>
</div>
<!-- Limitations Section -->
<div class="section">
<h2><i class="fas fa-exclamation-triangle"></i> Limitations</h2>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
                Sensitive to parameter selection (ε, minPts)
              </li>
<li style="margin-bottom: 10px">
                Struggles with clusters of varying densities
              </li>
<li style="margin-bottom: 10px">
                Performance degrades in high dimensions
              </li>
<li style="margin-bottom: 10px">
                Border points can belong to multiple clusters
              </li>
<li>Not deterministic for border points</li>
</ul>
</div>
<!-- Point Types Section -->
<div class="section">
<h2><i class="fas fa-dot-circle"></i> Point Types</h2>
<p>DBSCAN categorizes points into three types:</p>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
<b>Core Points:</b> Have at least minPts within ε distance
              </li>
<li style="margin-bottom: 10px">
<b>Border Points:</b> Within ε of a core point but have fewer
                than minPts neighbors
              </li>
<li style="margin-bottom: 10px">
<b>Noise Points:</b> Neither core nor border points
              </li>
</ul>
</div>
</div>
</div>
<!-- Footer -->
<footer>
<div class="footer-links">
<a href="https://www.linkedin.com/in/sgkandale/" target="_blank"><i class="fa-brands fa-linkedin"></i> LinkedIN</a>
<a href="mailto:me@sgkandale.com"><i class="fa-solid fa-at"></i> E-Mail</a>
<a href="https://buymeacoffee.com/sgkandale" target="_blank"><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a>
</div>
<p>AlgoViz Hub - Interactive Algorithm Visualization Platform</p>
<p>© 2025 AlgoViz Hub. All rights reserved.</p>
</footer>
</div>
<script>
      // DBSCAN Visualization
      document.addEventListener("DOMContentLoaded", function () {
        // DOM Elements
        const vizContainer = document.getElementById("dbscan-viz");
        const runBtn = document.getElementById("run-btn");
        const stepBtn = document.getElementById("step-btn");
        const resetBtn = document.getElementById("reset-btn");
        const generateBtn = document.getElementById("generate-btn");
        const epsilonInput = document.getElementById("epsilon");
        const epsilonValue = document.getElementById("epsilon-value");
        const minPointsInput = document.getElementById("min-points");
        const minPointsValue = document.getElementById("min-points-value");
        const iterationInfo = document.querySelector(".iteration-info");
        const copyBtn = document.querySelector(".copy-btn");

        // Visualization state
        let dataPoints = [];
        let clusters = [];
        let currentStep = 0;
        let currentPointIndex = 0;
        let animationId = null;
        const colors = [
          "#818cf8",
          "#10b981",
          "#f59e0b",
          "#ef4444",
          "#a78bfa",
          "#60a5fa",
          "#34d399",
          "#fbbf24",
        ];
        const width = vizContainer.clientWidth;
        const height = vizContainer.clientHeight;

        // Update parameter displays
        epsilonInput.addEventListener("input", function () {
          epsilonValue.textContent = this.value;
        });

        minPointsInput.addEventListener("input", function () {
          minPointsValue.textContent = this.value;
        });

        // Generate random data points
        function generateData() {
          // Clear previous data
          dataPoints = [];
          clusters = [];
          currentStep = 0;
          currentPointIndex = 0;
          vizContainer.innerHTML = "";

          // Create iteration info
          const iterInfo = document.createElement("div");
          iterInfo.className = "iteration-info";
          iterInfo.textContent = "Iteration: 0 | Clusters: 0";
          vizContainer.appendChild(iterInfo);

          // Create legend
          const legend = document.createElement("div");
          legend.className = "legend";
          legend.innerHTML = `
                    <div class="legend-item">
                        <div class="legend-color" style="background:#818cf8"></div>
                        <div class="legend-label">Core Point</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background:#10b981"></div>
                        <div class="legend-label">Border Point</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background:#ef4444"></div>
                        <div class="legend-label">Noise Point</div>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background:#f59e0b"></div>
                        <div class="legend-label">Current Point</div>
                    </div>
                `;
          vizContainer.appendChild(legend);

          // Create dense clusters
          for (let i = 0; i < 3; i++) {
            const centerX = Math.random() * (width - 150) + 75;
            const centerY = Math.random() * (height - 150) + 75;

            for (let j = 0; j < 20; j++) {
              const point = {
                id: dataPoints.length,
                x: centerX + (Math.random() - 0.5) * 80,
                y: centerY + (Math.random() - 0.5) * 80,
                cluster: -1, // -1: unvisited, -2: noise
                isCore: false,
                neighbors: [],
              };
              dataPoints.push(point);
            }
          }

          // Add some noise points
          for (let i = 0; i < 10; i++) {
            const point = {
              id: dataPoints.length,
              x: Math.random() * width,
              y: Math.random() * height,
              cluster: -1,
              isCore: false,
              neighbors: [],
            };
            dataPoints.push(point);
          }

          // Render initial state
          renderVisualization();
        }

        // Calculate Euclidean distance
        function euclideanDistance(p1, p2) {
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          return Math.sqrt(dx * dx + dy * dy);
        }

        // Find neighbors for a point
        function findNeighbors(pointIndex) {
          const epsilon = parseInt(epsilonInput.value);
          const point = dataPoints[pointIndex];
          const neighbors = [];

          for (let i = 0; i < dataPoints.length; i++) {
            if (i === pointIndex) continue;
            if (euclideanDistance(point, dataPoints[i]) <= epsilon) {
              neighbors.push(i);
            }
          }

          return neighbors;
        }

        // Expand cluster from a core point
        function expandCluster(pointIndex, clusterId) {
          const minPts = parseInt(minPointsInput.value);
          const queue = [pointIndex];

          while (queue.length > 0) {
            const currentIdx = queue.shift();
            const currentPoint = dataPoints[currentIdx];

            if (currentPoint.cluster === -2) {
              // Noise point becomes border point
              currentPoint.cluster = clusterId;
            }

            if (currentPoint.cluster === -1) {
              // Unvisited point
              currentPoint.cluster = clusterId;
              const neighbors = findNeighbors(currentIdx);

              if (neighbors.length >= minPts) {
                // Core point
                currentPoint.isCore = true;

                // Add new neighbors to queue
                neighbors.forEach((neighborIdx) => {
                  if (
                    !queue.includes(neighborIdx) &&
                    dataPoints[neighborIdx].cluster <= 0
                  ) {
                    queue.push(neighborIdx);
                  }
                });
              }
            }

            renderVisualization();
          }
        }

        // Perform one step of the algorithm
        function performStep() {
          if (currentPointIndex >= dataPoints.length) {
            return false; // Algorithm completed
          }

          const point = dataPoints[currentPointIndex];
          const minPts = parseInt(minPointsInput.value);

          if (point.cluster === -1) {
            // Unvisited
            point.cluster = 0; // Mark as visited for visualization
            renderVisualization();

            setTimeout(() => {
              const neighbors = findNeighbors(currentPointIndex);

              if (neighbors.length < minPts) {
                // Mark as noise (temporarily)
                point.cluster = -2;
              } else {
                // Create new cluster
                const clusterId = clusters.length + 1;
                clusters.push(clusterId);
                point.isCore = true;
                point.cluster = clusterId;

                // Expand cluster
                expandCluster(currentPointIndex, clusterId);
              }

              currentPointIndex++;
              updateIterationInfo();
              renderVisualization();
            }, 1000);

            return true;
          }

          currentPointIndex++;
          return true;
        }

        // Render visualization
        function renderVisualization() {
          // Clear previous points and circles
          vizContainer
            .querySelectorAll(".data-point, .epsilon-circle, .cluster-line")
            .forEach((el) => el.remove());

          // Render data points
          dataPoints.forEach((point, idx) => {
            const pointEl = document.createElement("div");
            pointEl.className = "data-point";
            pointEl.style.left = `${point.x}px`;
            pointEl.style.top = `${point.y}px`;

            // Determine point color and style
            if (idx === currentPointIndex && point.cluster === -1) {
              // Current point being processed
              pointEl.style.backgroundColor = "#f59e0b";
              pointEl.classList.add("core-point");
            } else if (point.cluster === -2) {
              // Noise point
              pointEl.style.backgroundColor = "#ef4444";
            } else if (point.isCore) {
              // Core point
              pointEl.style.backgroundColor =
                colors[point.cluster % colors.length];
              pointEl.classList.add("core-point");
            } else if (point.cluster > 0) {
              // Border point
              pointEl.style.backgroundColor = "#10b981";
            } else {
              // Unvisited point
              pointEl.style.backgroundColor = "#94a3b8";
            }

            vizContainer.appendChild(pointEl);

            // Draw epsilon circle for current point
            if (idx === currentPointIndex && point.cluster === -1) {
              const circle = document.createElement("div");
              circle.className = "epsilon-circle";
              circle.style.left = `${point.x}px`;
              circle.style.top = `${point.y}px`;
              circle.style.width = `${parseInt(epsilonInput.value) * 2}px`;
              circle.style.height = `${parseInt(epsilonInput.value) * 2}px`;
              vizContainer.appendChild(circle);

              // Draw lines to neighbors
              const neighbors = findNeighbors(idx);
              neighbors.forEach((neighborIdx) => {
                const neighbor = dataPoints[neighborIdx];
                const line = document.createElement("div");
                line.className = "cluster-line";

                const dx = neighbor.x - point.x;
                const dy = neighbor.y - point.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = (Math.atan2(dy, dx) * 180) / Math.PI;

                line.style.width = `${length}px`;
                line.style.left = `${point.x}px`;
                line.style.top = `${point.y}px`;
                line.style.transform = `rotate(${angle}deg)`;
                vizContainer.appendChild(line);
              });
            }
          });
        }

        // Update iteration info
        function updateIterationInfo() {
          const clusterCount = clusters.length;
          iterationInfo.textContent = `Iteration: ${currentPointIndex} | Clusters: ${clusterCount}`;
        }

        // Run animation
        function runAnimation() {
          if (animationId) {
            clearTimeout(animationId);
          }

          function animate() {
            const continueRunning = performStep();

            if (continueRunning && currentPointIndex < dataPoints.length) {
              animationId = setTimeout(animate, 1500);
            } else {
              runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
              animationId = null;
            }
          }

          runBtn.innerHTML = '<i class="fas fa-stop"></i> Stop';
          animationId = setTimeout(animate, 1000);
        }

        // Event listeners
        runBtn.addEventListener("click", function () {
          if (this.textContent.includes("Run")) {
            runAnimation();
          } else {
            if (animationId) {
              clearTimeout(animationId);
              animationId = null;
            }
            this.innerHTML = '<i class="fas fa-play"></i> Run';
          }
        });

        stepBtn.addEventListener("click", function () {
          if (animationId) {
            clearTimeout(animationId);
            animationId = null;
            runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
          }
          performStep();
        });

        resetBtn.addEventListener("click", function () {
          if (animationId) {
            clearTimeout(animationId);
            animationId = null;
          }
          runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
          generateData();
        });

        generateBtn.addEventListener("click", function () {
          if (animationId) {
            clearTimeout(animationId);
            animationId = null;
          }
          runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
          generateData();
        });

        epsilonInput.addEventListener("change", function () {
          if (animationId) {
            clearTimeout(animationId);
            animationId = null;
            runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
          }
          generateData();
        });

        minPointsInput.addEventListener("change", function () {
          if (animationId) {
            clearTimeout(animationId);
            animationId = null;
            runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
          }
          generateData();
        });

        // Copy button functionality
        copyBtn.addEventListener("click", function () {
          const code = document.querySelector(".code-block code").innerText;
          navigator.clipboard.writeText(code);

          const originalText = this.innerHTML;
          this.innerHTML = '<i class="fas fa-check"></i> Copied!';

          setTimeout(() => {
            this.innerHTML = originalText;
          }, 2000);
        });

        // Initialize visualization
        generateData();
      });
    </script>
</body>
</html>
