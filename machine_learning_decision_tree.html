<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Decision Tree | AlgoViz Hub</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      :root {
        --primary: #0f172a;
        --secondary: #1e293b;
        --accent: #6366f1;
        --accent-light: #818cf8;
        --accent-glow: rgba(99, 102, 241, 0.2);
        --text: #e2e8f0;
        --text-secondary: #94a3b8;
        --card-bg: rgba(30, 41, 59, 0.7);
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --transition: all 0.3s ease;
        --radius: 12px;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        --glow: 0 0 15px var(--accent-glow);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: var(--text);
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        min-height: 100vh;
        padding: 0;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 10% 20%,
            rgba(99, 102, 241, 0.1) 0%,
            transparent 20%
          ),
          radial-gradient(
            circle at 90% 80%,
            rgba(129, 140, 248, 0.1) 0%,
            transparent 20%
          );
        z-index: -1;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      /* Header Styles */
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 0;
        position: relative;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .logo-icon {
        width: 50px;
        height: 50px;
        background: var(--accent);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--glow);
      }

      .logo-icon i {
        font-size: 24px;
        color: white;
      }

      .logo-text h1 {
        font-family: "Roboto Mono", monospace;
        font-weight: 700;
        font-size: 28px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .logo-text p {
        font-size: 14px;
        color: var(--text-secondary);
        letter-spacing: 1.5px;
      }

      .breadcrumb {
        font-size: 14px;
        color: var(--text-secondary);
        margin-top: 10px;
      }

      .breadcrumb a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .breadcrumb a:hover {
        text-decoration: underline;
      }

      /* Algorithm Header */
      .algorithm-header {
        margin: 40px 0;
        text-align: center;
        padding: 20px;
        background: var(--card-bg);
        border-radius: var(--radius);
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .algorithm-header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .algorithm-header h1 {
        font-size: 42px;
        margin-bottom: 15px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 800;
      }

      .algorithm-header .category {
        font-size: 18px;
        color: var(--accent-light);
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .complexity-badge {
        display: inline-block;
        background: rgba(129, 140, 248, 0.2);
        color: var(--accent-light);
        padding: 6px 15px;
        border-radius: 20px;
        font-size: 16px;
        font-weight: 600;
        font-family: "Roboto Mono", monospace;
        margin-top: 15px;
      }

      /* Main Content Layout */
      .main-content {
        display: grid;
        grid-template-columns: 1fr 350px;
        gap: 30px;
        margin-bottom: 40px;
      }

      @media (max-width: 900px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }

      /* Algorithm Detail Sections */
      .section {
        background: var(--card-bg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 30px;
        margin-bottom: 30px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .section::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .section h2 {
        font-size: 26px;
        margin-bottom: 20px;
        color: var(--accent-light);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .section h2 i {
        color: var(--accent);
        width: 36px;
        height: 36px;
        background: rgba(99, 102, 241, 0.2);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .section p {
        color: var(--text-secondary);
        font-size: 17px;
        line-height: 1.8;
        margin-bottom: 20px;
      }

      .key-points {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin: 25px 0;
      }

      .point-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
      }

      .point-card h3 {
        color: var(--accent-light);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .point-card h3 i {
        color: var(--accent);
      }

      .point-card p {
        margin-bottom: 0;
        font-size: 15px;
      }

      /* Visualization Console */
      .visualization-console {
        background: rgba(15, 23, 42, 0.8);
        border-radius: var(--radius);
        padding: 25px;
        margin: 30px 0;
        border: 1px solid rgba(99, 102, 241, 0.3);
        box-shadow: var(--glow);
      }

      .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .console-header h3 {
        color: var(--accent-light);
        font-size: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .console-controls {
        display: flex;
        gap: 10px;
      }

      .console-btn {
        background: var(--accent);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .console-btn:hover {
        background: var(--accent-light);
      }

      .console-btn.secondary {
        background: rgba(148, 163, 184, 0.2);
      }

      .visualization-area {
        height: 300px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      .console-input {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      .console-input input {
        flex: 1;
        padding: 12px 15px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 5px;
        color: var(--text);
        font-family: "Roboto Mono", monospace;
      }

      .console-input input:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Algorithm Properties */
      .properties-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .property-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        text-align: center;
      }

      .property-card h4 {
        color: var(--text-secondary);
        font-size: 14px;
        margin-bottom: 8px;
        font-weight: 400;
      }

      .property-card .value {
        font-size: 20px;
        font-weight: 700;
        color: var(--accent-light);
        font-family: "Roboto Mono", monospace;
      }

      /* Footer */
      footer {
        text-align: center;
        padding: 40px 0 30px;
        color: var(--text-secondary);
        font-size: 14px;
        border-top: 1px solid rgba(148, 163, 184, 0.1);
        margin-top: 40px;
      }

      footer p {
        margin: 10px 0;
      }

      .footer-links {
        display: flex;
        justify-content: center;
        gap: 25px;
        margin-top: 15px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .footer-links a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .footer-links a:hover {
        color: var(--accent);
      }

      /* Animations */
      @keyframes float {
        0% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
        100% {
          transform: translateY(0px);
        }
      }

      .floating {
        animation: float 6s ease-in-out infinite;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        header {
          flex-direction: column;
          gap: 25px;
          text-align: center;
        }

        .algorithm-header h1 {
          font-size: 32px;
        }

        .key-points {
          grid-template-columns: 1fr;
        }
      }

      /* Code Block Styling */
      .code-block {
        background: #0d1117;
        border-radius: 8px;
        padding: 20px;
        margin: 25px 0;
        overflow-x: auto;
        font-family: "Roboto Mono", monospace;
        font-size: 15px;
        border: 1px solid rgba(99, 102, 241, 0.3);
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        color: var(--text-secondary);
      }

      .copy-btn {
        background: rgba(99, 102, 241, 0.2);
        color: var(--accent-light);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-block pre {
        margin: 0;
      }

      .code-block code {
        color: #c9d1d9;
        line-height: 1.5;
      }

      .keyword {
        color: #ff7b72;
      }
      .function {
        color: #d2a8ff;
      }
      .comment {
        color: #8b949e;
      }
      .string {
        color: #a5d6ff;
      }
      .number {
        color: #79c0ff;
      }

      /* Decision Tree Visualization */
      .chart-container {
        width: 100%;
        height: 100%;
        position: relative;
      }

      .tree-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        padding: 10px;
      }

      .tree-node {
        position: absolute;
        background: rgba(15, 23, 42, 0.8);
        border: 1px solid var(--accent);
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        min-width: 100px;
        font-family: "Roboto Mono", monospace;
        font-size: 13px;
        color: var(--accent-light);
        transition: var(--transition);
        cursor: pointer;
      }

      .tree-node:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .tree-node.leaf {
        border-color: var(--success);
        color: var(--success);
      }

      .tree-node.highlight {
        box-shadow: 0 0 10px var(--warning);
        z-index: 10;
      }

      .tree-line {
        position: absolute;
        background: var(--accent-light);
        transform-origin: 0 0;
        z-index: -1;
      }

      .split-line {
        position: absolute;
        background: rgba(16, 185, 129, 0.5);
        z-index: 5;
      }

      .split-label {
        position: absolute;
        font-family: "Roboto Mono", monospace;
        font-size: 12px;
        color: var(--success);
        background: rgba(15, 23, 42, 0.8);
        padding: 2px 5px;
        border-radius: 4px;
      }

      .slider-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 15px;
      }

      .slider-label {
        display: flex;
        justify-content: space-between;
        font-size: 14px;
        color: var(--text-secondary);
      }

      .slider {
        width: 100%;
        height: 10px;
        border-radius: 5px;
        background: rgba(148, 163, 184, 0.2);
        outline: none;
        -webkit-appearance: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--accent);
        cursor: pointer;
      }

      .slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--accent);
        cursor: pointer;
      }

      .data-point {
        position: absolute;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
      }

      .class-0 {
        background: var(--accent-light);
      }

      .class-1 {
        background: var(--warning);
      }

      .class-2 {
        background: var(--success);
      }

      .tree-info {
        position: absolute;
        top: 15px;
        left: 15px;
        background: rgba(15, 23, 42, 0.8);
        padding: 10px 15px;
        border-radius: 8px;
        font-family: "Roboto Mono", monospace;
        border: 1px solid var(--accent);
        color: var(--accent-light);
        z-index: 20;
      }

      .feature-space {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <header>
        <div class="logo">
          <div class="logo-icon floating">
            <i class="fas fa-project-diagram"></i>
          </div>
          <div class="logo-text">
            <h1>AlgoViz Hub</h1>
            <p>ALGORITHM VISUALIZATION REPOSITORY</p>
            <div class="breadcrumb">
              <a href="#"><i class="fas fa-home"></i> Home</a> >
              <a href="#">Machine Learning</a> >
              <span>Decision Tree</span>
            </div>
          </div>
        </div>
      </header>

      <!-- Algorithm Header -->
      <div class="algorithm-header">
        <h1>Decision Tree</h1>
        <div class="category">
          <i class="fas fa-sitemap"></i> Supervised Learning Algorithm
        </div>
        <div class="complexity-badge">Type: Classification & Regression</div>
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <!-- Left Column: Algorithm Details -->
        <div class="left-column">
          <!-- Description Section -->
          <div class="section">
            <h2><i class="fas fa-file-alt"></i> Algorithm Overview</h2>
            <p>
              Decision Trees are versatile supervised learning algorithms used
              for both classification and regression tasks. They model decisions
              and their possible consequences as a tree structure, where each
              internal node represents a feature test, each branch represents an
              outcome, and each leaf node represents a class label or continuous
              value.
            </p>
            <p>
              Decision Trees work by recursively partitioning the feature space
              into regions, with each partition chosen to maximize information
              gain or minimize impurity. This results in a model that is easy to
              interpret and visualize.
            </p>

            <div class="key-points">
              <div class="point-card">
                <h3><i class="fas fa-project-diagram"></i> Structure</h3>
                <p>
                  Tree with root, internal nodes (decisions), and leaf nodes
                  (outcomes)
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-cogs"></i> Splitting Criteria</h3>
                <p>Gini impurity, entropy, or variance reduction for splits</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-eye"></i> Interpretability</h3>
                <p>Highly interpretable with clear decision rules</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-forest"></i> Extensions</h3>
                <p>
                  Random Forests and Gradient Boosting for improved performance
                </p>
              </div>
            </div>
          </div>

          <!-- Visualization Console -->
          <div class="section">
            <h2>
              <i class="fas fa-laptop-code"></i> Interactive Visualization
            </h2>
            <p>
              Use the interactive visualization below to understand how decision
              trees work. Add data points for different classes, train the tree,
              and explore how splits partition the feature space. Click on tree
              nodes to see the corresponding decision boundaries.
            </p>

            <div class="visualization-console">
              <div class="console-header">
                <h3>
                  <i class="fas fa-sitemap"></i> Decision Tree Visualization
                </h3>
                <div class="console-controls">
                  <button class="console-btn" id="add-points-btn">
                    <i class="fas fa-plus-circle"></i> Add Points
                  </button>
                  <button class="console-btn" id="train-btn">
                    <i class="fas fa-bolt"></i> Train Tree
                  </button>
                  <button class="console-btn secondary" id="reset-btn">
                    <i class="fas fa-redo"></i> Reset
                  </button>
                </div>
              </div>

              <div class="visualization-area">
                <div class="chart-container">
                  <canvas id="feature-space"></canvas>
                  <div class="tree-container" id="tree-container"></div>
                  <div class="tree-info" id="tree-info">
                    Depth: 0 | Nodes: 0
                  </div>
                </div>
              </div>

              <div class="slider-container">
                <div class="slider-label">
                  <span>Max Depth:</span>
                  <span id="depth-value">3</span>
                </div>
                <input
                  type="range"
                  min="1"
                  max="5"
                  step="1"
                  value="3"
                  class="slider"
                  id="depth-slider"
                />

                <div class="slider-label">
                  <span>Min Samples per Leaf:</span>
                  <span id="samples-value">3</span>
                </div>
                <input
                  type="range"
                  min="1"
                  max="10"
                  step="1"
                  value="3"
                  class="slider"
                  id="samples-slider"
                />
              </div>
            </div>
          </div>

          <!-- Algorithm Steps -->
          <div class="section">
            <h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
            <p>Decision Tree construction involves the following steps:</p>

            <div class="key-points">
              <div class="point-card">
                <h3><i class="fas fa-database"></i> 1. Data Preparation</h3>
                <p>Prepare labeled dataset with features and target variable</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-ruler"></i> 2. Select Best Split</h3>
                <p>Find feature and threshold that best separates the data</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-code-branch"></i> 3. Partition Data</h3>
                <p>Split dataset into subsets based on selected feature</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-redo"></i> 4. Recursion</h3>
                <p>Repeat process recursively for each subset</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-leaf"></i> 5. Stopping Criteria</h3>
                <p>Stop when max depth reached or node is pure enough</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-tag"></i> 6. Assign Leaf Node</h3>
                <p>Assign most common class or mean value to leaf</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Right Column: Additional Info -->
        <div class="right-column">
          <!-- Properties Section -->
          <div class="section">
            <h2><i class="fas fa-info-circle"></i> Algorithm Properties</h2>
            <div class="properties-grid">
              <div class="property-card">
                <h4>Category</h4>
                <div class="value">Supervised</div>
              </div>
              <div class="property-card">
                <h4>Type</h4>
                <div class="value">Classification/Regression</div>
              </div>
              <div class="property-card">
                <h4>Interpretability</h4>
                <div class="value">High</div>
              </div>
              <div class="property-card">
                <h4>Non-Parametric</h4>
                <div class="value">Yes</div>
              </div>
              <div class="property-card">
                <h4>Feature Types</h4>
                <div class="value">Numeric/Categorical</div>
              </div>
              <div class="property-card">
                <h4>Splitting Criteria</h4>
                <div class="value">Gini, Entropy, MSE</div>
              </div>
              <div class="property-card">
                <h4>Prone to</h4>
                <div class="value">Overfitting</div>
              </div>
              <div class="property-card">
                <h4>Ensemble Methods</h4>
                <div class="value">Random Forest</div>
              </div>
            </div>
          </div>

          <!-- Applications Section -->
          <div class="section">
            <h2><i class="fas fa-lightbulb"></i> Applications</h2>
            <p>Decision Trees are widely used across various domains:</p>
            <ul
              style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              "
            >
              <li style="margin-bottom: 10px">
                Healthcare: Medical diagnosis and treatment decisions
              </li>
              <li style="margin-bottom: 10px">
                Finance: Credit scoring and risk assessment
              </li>
              <li style="margin-bottom: 10px">
                Marketing: Customer segmentation and targeting
              </li>
              <li style="margin-bottom: 10px">
                Manufacturing: Quality control and fault detection
              </li>
              <li>Ecology: Species classification and habitat analysis</li>
              <li style="margin-top: 10px">
                Business: Decision support systems
              </li>
            </ul>
          </div>

          <!-- Pseudocode Section -->
          <div class="section">
            <h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
            <div class="code-block">
              <pre><code><span class="keyword">function</span> <span class="function">build_tree</span>(data, depth, max_depth, min_samples):
    <span class="keyword">if</span> depth == max_depth <span class="keyword">or</span> len(data) < min_samples:
        leaf_value = calculate_leaf_value(data)
        <span class="keyword">return</span> LeafNode(leaf_value)
    
    best_split = find_best_split(data)
    <span class="keyword">if</span> best_split.gain <= 0:
        leaf_value = calculate_leaf_value(data)
        <span class="keyword">return</span> LeafNode(leaf_value)
    
    left_data = data[data[best_split.feature] <= best_split.threshold]
    right_data = data[data[best_split.feature] > best_split.threshold]
    
    left_subtree = build_tree(left_data, depth+1, max_depth, min_samples)
    right_subtree = build_tree(right_data, depth+1, max_depth, min_samples)
    
    <span class="keyword">return</span> DecisionNode(best_split.feature, best_split.threshold, 
                        left_subtree, right_subtree)

<span class="keyword">function</span> <span class="function">find_best_split</span>(data):
    best_gain = -Infinity
    best_feature = None
    best_threshold = None
    
    <span class="keyword">for</span> feature <span class="keyword">in</span> features:
        <span class="keyword">for</span> threshold <span class="keyword">in</span> possible_thresholds(feature):
            left, right = split_data(data, feature, threshold)
            gain = calculate_gain(left, right)
            
            <span class="keyword">if</span> gain > best_gain:
                best_gain = gain
                best_feature = feature
                best_threshold = threshold
    
    <span class="keyword">return</span> {feature: best_feature, threshold: best_threshold, gain: best_gain}</code></pre>
            </div>
          </div>

          <!-- Evaluation Metrics -->
          <div class="section">
            <h2><i class="fas fa-ruler"></i> Splitting Criteria</h2>
            <p>
              Decision Trees use various criteria to determine the best split:
            </p>
            <ul
              style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              "
            >
              <li style="margin-bottom: 10px">
                <strong>Gini Impurity</strong>: Measures probability of
                misclassification
              </li>
              <li style="margin-bottom: 10px">
                <strong>Entropy/Information Gain</strong>: Measures reduction in
                uncertainty
              </li>
              <li style="margin-bottom: 10px">
                <strong>Variance Reduction</strong>: For regression trees
                (minimize MSE)
              </li>
              <li>
                <strong>Chi-Square</strong>: Statistical test for independence
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Footer -->
      <footer>
        <div class="footer-links">
          <a href="#"><i class="fas fa-book"></i> Documentation</a>
          <a href="#"><i class="fas fa-code-branch"></i> Contribute</a>
          <a href="#"><i class="fas fa-chalkboard-teacher"></i> Tutorials</a>
          <a href="#"><i class="fas fa-bug"></i> Report Issue</a>
          <a href="#"><i class="fas fa-envelope"></i> Contact</a>
        </div>
        <p>AlgoViz Hub - Interactive Algorithm Visualization Platform</p>
        <p>&copy; 2023 AlgoViz Hub. All rights reserved.</p>
      </footer>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize Chart
        const ctx = document.getElementById("feature-space").getContext("2d");
        let featureChart;

        // Sample data
        let dataPoints = [
          { x: 1, y: 2, class: 0 },
          { x: 2, y: 3, class: 0 },
          { x: 3, y: 1.5, class: 0 },
          { x: 4, y: 4, class: 0 },
          { x: 1.5, y: 5, class: 0 },
          { x: 7, y: 2, class: 1 },
          { x: 8, y: 3, class: 1 },
          { x: 9, y: 4, class: 1 },
          { x: 7.5, y: 5, class: 1 },
          { x: 8.5, y: 1, class: 1 },
          { x: 5, y: 1, class: 2 },
          { x: 5, y: 5, class: 2 },
          { x: 4.5, y: 3, class: 2 },
          { x: 5.5, y: 3, class: 2 },
          { x: 5, y: 2.5, class: 2 },
        ];

        // Decision tree state
        let decisionTree = null;
        let maxDepth = 3;
        let minSamples = 3;

        // Initialize chart
        function initChart() {
          if (featureChart) {
            featureChart.destroy();
          }

          featureChart = new Chart(ctx, {
            type: "scatter",
            data: {
              datasets: [
                {
                  label: "Class 0",
                  data: dataPoints.filter((p) => p.class === 0),
                  backgroundColor: "rgba(129, 140, 248, 0.8)",
                  borderColor: "rgba(99, 102, 241, 1)",
                  borderWidth: 1,
                  pointRadius: 6,
                },
                {
                  label: "Class 1",
                  data: dataPoints.filter((p) => p.class === 1),
                  backgroundColor: "rgba(245, 158, 11, 0.8)",
                  borderColor: "rgba(217, 119, 6, 1)",
                  borderWidth: 1,
                  pointRadius: 6,
                },
                {
                  label: "Class 2",
                  data: dataPoints.filter((p) => p.class === 2),
                  backgroundColor: "rgba(16, 185, 129, 0.8)",
                  borderColor: "rgba(5, 150, 105, 1)",
                  borderWidth: 1,
                  pointRadius: 6,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  type: "linear",
                  position: "bottom",
                  min: 0,
                  max: 10,
                  grid: {
                    color: "rgba(148, 163, 184, 0.1)",
                  },
                  ticks: {
                    color: "rgba(148, 163, 184, 0.8)",
                  },
                },
                y: {
                  min: 0,
                  max: 6,
                  grid: {
                    color: "rgba(148, 163, 184, 0.1)",
                  },
                  ticks: {
                    color: "rgba(148, 163, 184, 0.8)",
                  },
                },
              },
              plugins: {
                legend: {
                  labels: {
                    color: "rgba(148, 163, 184, 0.8)",
                  },
                },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      return `(${context.parsed.x.toFixed(
                        2
                      )}, ${context.parsed.y.toFixed(2)})`;
                    },
                  },
                },
              },
            },
          });
        }

        // Simple decision tree node class
        class TreeNode {
          constructor(feature, threshold, left, right, depth, isLeaf, value) {
            this.feature = feature;
            this.threshold = threshold;
            this.left = left;
            this.right = right;
            this.depth = depth;
            this.isLeaf = isLeaf;
            this.value = value; // Class for leaf nodes
          }
        }

        // Calculate Gini impurity
        function giniImpurity(labels) {
          const counts = {};
          labels.forEach((label) => {
            counts[label] = (counts[label] || 0) + 1;
          });

          let impurity = 1;
          for (let key in counts) {
            const prob = counts[key] / labels.length;
            impurity -= prob * prob;
          }
          return impurity;
        }

        // Build a simple decision tree
        function buildTree(data, depth = 0) {
          // Check stopping criteria
          if (depth >= maxDepth || data.length <= minSamples) {
            const classCounts = {};
            data.forEach((point) => {
              classCounts[point.class] = (classCounts[point.class] || 0) + 1;
            });

            // Find most common class
            let maxClass = 0;
            let maxCount = 0;
            for (let cls in classCounts) {
              if (classCounts[cls] > maxCount) {
                maxCount = classCounts[cls];
                maxClass = parseInt(cls);
              }
            }

            return new TreeNode(null, null, null, null, depth, true, maxClass);
          }

          // Find best split
          let bestGain = -Infinity;
          let bestFeature = null;
          let bestThreshold = null;
          let bestLeft = [];
          let bestRight = [];

          // Try both x and y features
          ["x", "y"].forEach((feature) => {
            // Try different thresholds
            for (let threshold = 1; threshold < 10; threshold += 0.5) {
              const left = data.filter((p) => p[feature] <= threshold);
              const right = data.filter((p) => p[feature] > threshold);

              if (left.length === 0 || right.length === 0) continue;

              // Calculate information gain
              const parentImpurity = giniImpurity(data.map((p) => p.class));
              const leftImpurity = giniImpurity(left.map((p) => p.class));
              const rightImpurity = giniImpurity(right.map((p) => p.class));

              const weightedImpurity =
                (left.length * leftImpurity + right.length * rightImpurity) /
                data.length;

              const gain = parentImpurity - weightedImpurity;

              if (gain > bestGain) {
                bestGain = gain;
                bestFeature = feature;
                bestThreshold = threshold;
                bestLeft = left;
                bestRight = right;
              }
            }
          });

          // If no good split found, create leaf node
          if (bestGain <= 0) {
            const classCounts = {};
            data.forEach((point) => {
              classCounts[point.class] = (classCounts[point.class] || 0) + 1;
            });

            // Find most common class
            let maxClass = 0;
            let maxCount = 0;
            for (let cls in classCounts) {
              if (classCounts[cls] > maxCount) {
                maxCount = classCounts[cls];
                maxClass = parseInt(cls);
              }
            }

            return new TreeNode(null, null, null, null, depth, true, maxClass);
          }

          // Recursively build subtrees
          const leftNode = buildTree(bestLeft, depth + 1);
          const rightNode = buildTree(bestRight, depth + 1);

          return new TreeNode(
            bestFeature,
            bestThreshold,
            leftNode,
            rightNode,
            depth,
            false,
            null
          );
        }

        // Visualize the decision tree
        function visualizeTree(tree) {
          const container = document.getElementById("tree-container");
          container.innerHTML = "";
          document.querySelectorAll(".split-line").forEach((el) => el.remove());
          document
            .querySelectorAll(".split-label")
            .forEach((el) => el.remove());

          if (!tree) return;

          // Count nodes for layout
          const nodeCount = countNodes(tree);

          // Draw tree recursively
          drawNode(container, tree, 50, 50, 300, 100);

          // Update tree info
          document.getElementById(
            "tree-info"
          ).textContent = `Depth: ${maxDepth} | Nodes: ${nodeCount}`;
        }

        // Count nodes in tree
        function countNodes(node) {
          if (node.isLeaf) return 1;
          return 1 + countNodes(node.left) + countNodes(node.right);
        }

        // Draw a tree node recursively
        function drawNode(container, node, x, y, hGap, vGap) {
          const nodeEl = document.createElement("div");
          nodeEl.className = "tree-node" + (node.isLeaf ? " leaf" : "");
          nodeEl.style.left = x + "px";
          nodeEl.style.top = y + "px";

          if (node.isLeaf) {
            nodeEl.innerHTML = `Class ${node.value}`;
          } else {
            nodeEl.innerHTML = `${node.feature} ≤ ${node.threshold.toFixed(1)}`;
          }

          container.appendChild(nodeEl);

          // Draw lines to children
          if (!node.isLeaf) {
            // Left child
            const leftX = x - hGap;
            const leftY = y + vGap;

            // Draw line
            const line = document.createElement("div");
            line.className = "tree-line";
            const length = Math.sqrt(
              Math.pow(leftX - x, 2) + Math.pow(leftY - y, 2)
            );
            const angle = (Math.atan2(leftY - y, leftX - x) * 180) / Math.PI;

            line.style.width = length + "px";
            line.style.left = x + "px";
            line.style.top = y + "px";
            line.style.transform = `rotate(${angle}deg)`;
            container.appendChild(line);

            // Draw node
            drawNode(container, node.left, leftX, leftY, hGap * 0.7, vGap);

            // Right child
            const rightX = x + hGap;
            const rightY = y + vGap;

            // Draw line
            const line2 = document.createElement("div");
            line2.className = "tree-line";
            const length2 = Math.sqrt(
              Math.pow(rightX - x, 2) + Math.pow(rightY - y, 2)
            );
            const angle2 = (Math.atan2(rightY - y, rightX - x) * 180) / Math.PI;

            line2.style.width = length2 + "px";
            line2.style.left = x + "px";
            line2.style.top = y + "px";
            line2.style.transform = `rotate(${angle2}deg)`;
            container.appendChild(line2);

            // Draw node
            drawNode(container, node.right, rightX, rightY, hGap * 0.7, vGap);
          }
        }

        // Draw decision boundaries
        function drawDecisionBoundaries(tree) {
          // Clear previous boundaries
          document.querySelectorAll(".split-line").forEach((el) => el.remove());
          document
            .querySelectorAll(".split-label")
            .forEach((el) => el.remove());

          if (!tree) return;

          // Recursively draw boundaries
          drawBoundary(tree, 0, 10, 0, 6);
        }

        // Recursively draw decision boundaries
        function drawBoundary(node, xMin, xMax, yMin, yMax) {
          if (node.isLeaf) {
            // Draw region
            const region = document.createElement("div");
            region.className = "split-line";
            region.style.left = xMin + "px";
            region.style.top = yMin + "px";
            region.style.width = xMax - xMin + "px";
            region.style.height = yMax - yMin + "px";

            // Color by class
            let color;
            switch (node.value) {
              case 0:
                color = "rgba(129, 140, 248, 0.1)";
                break;
              case 1:
                color = "rgba(245, 158, 11, 0.1)";
                break;
              case 2:
                color = "rgba(16, 185, 129, 0.1)";
                break;
              default:
                color = "rgba(148, 163, 184, 0.1)";
            }

            region.style.backgroundColor = color;
            document.getElementById("tree-container").appendChild(region);
            return;
          }

          if (node.feature === "x") {
            // Draw vertical split line
            const line = document.createElement("div");
            line.className = "split-line";
            line.style.left = node.threshold * 30 + "px";
            line.style.top = yMin * 50 + "px";
            line.style.width = "2px";
            line.style.height = (yMax - yMin) * 50 + "px";
            line.style.backgroundColor = "rgba(16, 185, 129, 0.5)";
            document.getElementById("tree-container").appendChild(line);

            // Add label
            const label = document.createElement("div");
            label.className = "split-label";
            label.textContent = `x ≤ ${node.threshold.toFixed(1)}`;
            label.style.left = node.threshold * 30 - 30 + "px";
            label.style.top = yMin * 50 + 10 + "px";
            document.getElementById("tree-container").appendChild(label);

            // Recurse on both sides
            drawBoundary(node.left, xMin, node.threshold, yMin, yMax);
            drawBoundary(node.right, node.threshold, xMax, yMin, yMax);
          } else {
            // y feature
            // Draw horizontal split line
            const line = document.createElement("div");
            line.className = "split-line";
            line.style.left = xMin * 30 + "px";
            line.style.top = node.threshold * 50 + "px";
            line.style.width = (xMax - xMin) * 30 + "px";
            line.style.height = "2px";
            line.style.backgroundColor = "rgba(16, 185, 129, 0.5)";
            document.getElementById("tree-container").appendChild(line);

            // Add label
            const label = document.createElement("div");
            label.className = "split-label";
            label.textContent = `y ≤ ${node.threshold.toFixed(1)}`;
            label.style.left = xMin * 30 + 10 + "px";
            label.style.top = node.threshold * 50 - 20 + "px";
            document.getElementById("tree-container").appendChild(label);

            // Recurse on both sides
            drawBoundary(node.left, xMin, xMax, yMin, node.threshold);
            drawBoundary(node.right, xMin, xMax, node.threshold, yMax);
          }
        }

        // Train the decision tree
        function trainTree() {
          decisionTree = buildTree(dataPoints);
          visualizeTree(decisionTree);
          drawDecisionBoundaries(decisionTree);
        }

        // Add random data points
        function addRandomPoints(count = 3) {
          for (let i = 0; i < count; i++) {
            const x = Math.random() * 8 + 1;
            const y = Math.random() * 4 + 1;
            const cls = Math.floor(Math.random() * 3);
            dataPoints.push({ x, y, class: cls });
          }
          updateDataPoints();
        }

        // Reset data points
        function resetDataPoints() {
          dataPoints = [];
          decisionTree = null;
          document.getElementById("depth-slider").value = 3;
          document.getElementById("samples-slider").value = 3;
          document.getElementById("depth-value").textContent = "3";
          document.getElementById("samples-value").textContent = "3";

          maxDepth = 3;
          minSamples = 3;

          updateDataPoints();
          document.getElementById("tree-container").innerHTML = "";
          document.getElementById("tree-info").textContent =
            "Depth: 0 | Nodes: 0";
        }

        // Update data points in chart
        function updateDataPoints() {
          if (!featureChart) return;

          featureChart.data.datasets[0].data = dataPoints.filter(
            (p) => p.class === 0
          );
          featureChart.data.datasets[1].data = dataPoints.filter(
            (p) => p.class === 1
          );
          featureChart.data.datasets[2].data = dataPoints.filter(
            (p) => p.class === 2
          );
          featureChart.update();
        }

        // Event listeners
        document
          .getElementById("depth-slider")
          .addEventListener("input", function () {
            maxDepth = parseInt(this.value);
            document.getElementById("depth-value").textContent = maxDepth;
          });

        document
          .getElementById("samples-slider")
          .addEventListener("input", function () {
            minSamples = parseInt(this.value);
            document.getElementById("samples-value").textContent = minSamples;
          });

        document
          .getElementById("add-points-btn")
          .addEventListener("click", function () {
            addRandomPoints(3);
          });

        document
          .getElementById("train-btn")
          .addEventListener("click", trainTree);

        document
          .getElementById("reset-btn")
          .addEventListener("click", resetDataPoints);

        // Add click event to chart for adding points
        document
          .getElementById("feature-space")
          .addEventListener("click", function (evt) {
            const rect = this.getBoundingClientRect();
            const x = ((evt.clientX - rect.left) / rect.width) * 10;
            const y = 6 - ((evt.clientY - rect.top) / rect.height) * 6;

            if (x >= 0 && x <= 10 && y >= 0 && y <= 6) {
              // Class determined by number of clicks
              const cls = Math.floor(Math.random() * 3);
              dataPoints.push({ x, y, class: cls });
              updateDataPoints();
            }
          });

        // Initialize
        initChart();
      });
    </script>
  </body>
</html>
