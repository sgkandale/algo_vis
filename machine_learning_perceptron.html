<!DOCTYPE html>

<html lang="en">
<head><meta content="Interactive Perceptron Learning Algorithm visualization for machine learning education" name="description"/><meta content="perceptron, machine learning, algorithm, visualization, linear classification, neural network" name="keywords"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Perceptron Learning Algorithm | AlgoViz Hub</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&amp;family=Roboto:wght@300;400;500;700&amp;display=swap" rel="stylesheet"/>
<style>
      :root {
        --primary: #0f172a;
        --secondary: #1e293b;
        --accent: #6366f1;
        --accent-light: #818cf8;
        --accent-glow: rgba(99, 102, 241, 0.2);
        --text: #e2e8f0;
        --text-secondary: #94a3b8;
        --card-bg: rgba(30, 41, 59, 0.7);
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --transition: all 0.3s ease;
        --radius: 12px;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        --glow: 0 0 15px var(--accent-glow);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: var(--text);
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        min-height: 100vh;
        padding: 0;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 10% 20%,
            rgba(99, 102, 241, 0.1) 0%,
            transparent 20%
          ),
          radial-gradient(
            circle at 90% 80%,
            rgba(129, 140, 248, 0.1) 0%,
            transparent 20%
          );
        z-index: -1;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      /* Header Styles */
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 0;
        position: relative;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .logo-icon {
        width: 50px;
        height: 50px;
        background: var(--accent);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--glow);
      }

      .logo-icon i {
        font-size: 24px;
        color: white;
      }

      .logo-text h1 {
        font-family: "Roboto Mono", monospace;
        font-weight: 700;
        font-size: 28px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .logo-text p {
        font-size: 14px;
        color: var(--text-secondary);
        letter-spacing: 1.5px;
      }

      .breadcrumb {
        font-size: 14px;
        color: var(--text-secondary);
        margin-top: 10px;
      }

      .breadcrumb a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .breadcrumb a:hover {
        text-decoration: underline;
      }

      /* Algorithm Header */
      .algorithm-header {
        margin: 40px 0;
        text-align: center;
        padding: 20px;
        background: var(--card-bg);
        border-radius: var(--radius);
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .algorithm-header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .algorithm-header h1 {
        font-size: 42px;
        margin-bottom: 15px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 800;
      }

      .algorithm-header .category {
        font-size: 18px;
        color: var(--accent-light);
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .complexity-badge {
        display: inline-block;
        background: rgba(129, 140, 248, 0.2);
        color: var(--accent-light);
        padding: 6px 15px;
        border-radius: 20px;
        font-size: 16px;
        font-weight: 600;
        font-family: "Roboto Mono", monospace;
        margin-top: 15px;
      }

      /* Main Content Layout */
      .main-content {
        display: grid;
        grid-template-columns: 1fr 350px;
        gap: 30px;
        margin-bottom: 40px;
      }

      @media (max-width: 900px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }

      /* Algorithm Detail Sections */
      .section {
        background: var(--card-bg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 30px;
        margin-bottom: 30px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .section::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .section h2 {
        font-size: 26px;
        margin-bottom: 20px;
        color: var(--accent-light);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .section h2 i {
        color: var(--accent);
        width: 36px;
        height: 36px;
        background: rgba(99, 102, 241, 0.2);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .section p {
        color: var(--text-secondary);
        font-size: 17px;
        line-height: 1.8;
        margin-bottom: 20px;
      }

      .key-points {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin: 25px 0;
      }

      .point-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
      }

      .point-card h3 {
        color: var(--accent-light);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .point-card h3 i {
        color: var(--accent);
      }

      .point-card p {
        margin-bottom: 0;
        font-size: 15px;
      }

      /* Visualization Console */
      .visualization-console {
        background: rgba(15, 23, 42, 0.8);
        border-radius: var(--radius);
        padding: 25px;
        margin: 30px 0;
        border: 1px solid rgba(99, 102, 241, 0.3);
        box-shadow: var(--glow);
      }

      .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .console-header h3 {
        color: var(--accent-light);
        font-size: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .console-controls {
        display: flex;
        gap: 10px;
      }

      .console-btn {
        background: var(--accent);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .console-btn:hover {
        background: var(--accent-light);
      }

      .console-btn.secondary {
        background: rgba(148, 163, 184, 0.2);
      }

      .visualization-area {
        min-height: 500px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }
      
      .canvas-container {
        width: 100%;
        height: 400px;
        position: relative;
        margin-bottom: 20px;
      }
      
      canvas {
        width: 100%;
        height: 100%;
        border-radius: 8px;
        background: #1e293b;
      }

      .console-input {
        display: flex;
        gap: 10px;
        margin-top: 20px;
        flex-wrap: wrap;
      }

      .console-input input, .console-input select {
        padding: 12px 15px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 5px;
        color: var(--text);
        font-family: "Roboto Mono", monospace;
        margin-bottom: 10px;
      }

      .console-input input:focus, .console-input select:focus {
        outline: none;
        border-color: var(--accent);
      }

      .console-input input {
        flex: 1;
        min-width: 150px;
      }

      .console-input select {
        min-width: 150px;
      }

      /* Algorithm Properties */
      .properties-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .property-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        text-align: center;
      }

      .property-card h4 {
        color: var(--text-secondary);
        font-size: 14px;
        margin-bottom: 8px;
        font-weight: 400;
      }

      .property-card .value {
        font-size: 20px;
        font-weight: 700;
        color: var(--accent-light);
        font-family: "Roboto Mono", monospace;
      }

      /* Footer */
      footer {
        text-align: center;
        padding: 40px 0 30px;
        color: var(--text-secondary);
        font-size: 14px;
        border-top: 1px solid rgba(148, 163, 184, 0.1);
        margin-top: 40px;
      }

      footer p {
        margin: 10px 0;
      }

      .footer-links {
        display: flex;
        justify-content: center;
        gap: 25px;
        margin-top: 15px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .footer-links a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .footer-links a:hover {
        color: var(--accent);
      }

      /* Animations */
      @keyframes float {
        0% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
        100% {
          transform: translateY(0px);
        }
      }

      .floating {
        animation: float 6s ease-in-out infinite;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        header {
          flex-direction: column;
          gap: 25px;
          text-align: center;
        }

        .algorithm-header h1 {
          font-size: 32px;
        }

        .key-points {
          grid-template-columns: 1fr;
        }
      }

      /* Code Block Styling */
      .code-block {
        background: #0d1117;
        border-radius: 8px;
        padding: 20px;
        margin: 25px 0;
        overflow-x: auto;
        font-family: "Roboto Mono", monospace;
        font-size: 15px;
        border: 1px solid rgba(99, 102, 241, 0.3);
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        color: var(--text-secondary);
      }

      .copy-btn {
        background: rgba(99, 102, 241, 0.2);
        color: var(--accent-light);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-block pre {
        margin: 0;
      }

      .code-block code {
        color: #c9d1d9;
        line-height: 1.5;
      }

      .keyword {
        color: #ff7b72;
      }
      .function {
        color: #d2a8ff;
      }
      .comment {
        color: #8b949e;
      }
      .string {
        color: #a5d6ff;
      }
      .number {
        color: #79c0ff;
      }
      
      /* Perceptron Specific Styles */
      .iteration-display {
        font-size: 18px;
        color: var(--accent-light);
        font-family: "Roboto Mono", monospace;
        margin: 10px 0;
        text-align: center;
      }
      
      .weights-display {
        font-size: 16px;
        color: var(--text);
        font-family: "Roboto Mono", monospace;
        margin: 10px 0;
        text-align: center;
        background: rgba(0, 0, 0, 0.3);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }
      
      .controls-row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        width: 100%;
        margin-top: 10px;
      }
      
      .legend {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 10px;
        flex-wrap: wrap;
      }
      
      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 14px;
        color: var(--text-secondary);
      }
      
      .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 50%;
      }
      
      .legend-red {
        background-color: #ef4444; /* red-500 */
      }
      
      .legend-blue {
        background-color: #3b82f6; /* blue-500 */
      }
      
      .legend-line {
        background-color: #10b981; /* green-500 */
      }
</style>
<meta content="Perceptron Learning Algorithm | AlgoViz Hub" property="og:title"/><meta content="Interactive Perceptron Learning Algorithm visualization for machine learning education" property="og:description"/><meta content="article" property="og:type"/><meta content="https://sgkandale.github.io/machine_learning_perceptron.html" property="og:url"/><meta content="AlgoViz Hub" property="og:site_name"/><meta content="summary" name="twitter:card"/><meta content="Perceptron Learning Algorithm | AlgoViz Hub" name="twitter:title"/><meta content="Interactive Perceptron Learning Algorithm visualization for machine learning education" name="twitter:description"/><meta content="@sgkandale" name="twitter:site"/><link href="https://sgkandale.github.io/machine_learning_perceptron.html" rel="canonical"/><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Perceptron Learning Algorithm | AlgoViz Hub",
  "description": "Interactive Perceptron Learning Algorithm visualization for machine learning education",
  "author": {
    "@type": "Person",
    "name": "Shantanu Kandale"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AlgoViz Hub",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sgkandale.github.io/favicon.ico"
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sgkandale.github.io/machine_learning_perceptron.html"
  }
}</script></head>
<body>
<div class="container">
<!-- Header -->
<header>
<div class="logo">
<div class="logo-icon floating">
<i class="fas fa-project-diagram"></i>
</div>
<div class="logo-text">
<h1>AlgoViz Hub</h1>
<p>ALGORITHM VISUALIZATION REPOSITORY</p>
<div class="breadcrumb">
<a href="index.html"><i class="fas fa-home"></i> Home</a> &gt;
              <a href="#">Machine Learning</a> &gt;
              <span>Perceptron Learning Algorithm</span>
</div>
</div>
</div>
</header>
<!-- Algorithm Header -->
<div class="algorithm-header">
<h1>Perceptron Learning Algorithm</h1>
<div class="category">
<i class="fas fa-brain"></i> Machine Learning
</div>
<div class="complexity-badge">Learning Algorithm</div>
</div>
<!-- Main Content -->
<div class="main-content">
<!-- Left Column: Algorithm Details -->
<div class="left-column">
<!-- Description Section -->
<div class="section">
<h2><i class="fas fa-file-alt"></i> Algorithm Overview</h2>
<p>
              The Perceptron Learning Algorithm is a simple supervised learning algorithm for binary classification tasks. It's a fundamental building block of neural networks and was introduced by Frank Rosenblatt in 1958. The algorithm learns a linear decision boundary that separates two classes of data points.
            </p>
<p>
              The perceptron is a single-layer neural network that adjusts its weights based on training examples. It makes predictions by taking a weighted sum of input features and applying a step function to determine the class label.
            </p>
<div class="key-points">
<div class="point-card">
<h3><i class="fas fa-check-circle"></i> Key Feature</h3>
<p>
                  Linear classifier that learns a decision boundary
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-bolt"></i> Learning Method</h3>
<p>
                  Iterative adjustment of weights based on classification errors
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-memory"></i> Convergence</h3>
<p>
                  Guaranteed to converge if data is linearly separable
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-project-diagram"></i> Foundation</h3>
<p>
                  Basis for more complex neural network architectures
                </p>
</div>
</div>
</div>
<!-- Visualization Console -->
<div class="section">
<h2>
<i class="fas fa-laptop-code"></i> Interactive Perceptron Visualization
</h2>
<p>
              Use the interactive console below to visualize how the Perceptron Learning Algorithm works. You can generate random linearly separable data points, adjust learning parameters, and step through the learning process to see how the decision boundary is updated after each misclassified point.
            </p>
<div class="visualization-console">
<div class="console-header">
<h3>
<i class="fas fa-brain"></i> Perceptron Learning Visualization
                </h3>
</div>
<div class="canvas-container">
  <canvas id="perceptronCanvas"></canvas>
</div>
<div class="iteration-display">
  Iteration: <span id="iterationCount">0</span> | Mistakes: <span id="mistakeCount">0</span>
</div>
<div class="weights-display">
  Weights: w0=<span id="w0Value">0.00</span>, w1=<span id="w1Value">0.00</span>, w2=<span id="w2Value">0.00</span>
</div>
<div class="legend">
  <div class="legend-item">
    <div class="legend-color legend-red"></div>
    <span>Class -1</span>
  </div>
  <div class="legend-item">
    <div class="legend-color legend-blue"></div>
    <span>Class +1</span>
  </div>
  <div class="legend-item">
    <div class="legend-color legend-line" style="width: 30px; height: 4px;"></div>
    <span>Decision Boundary</span>
  </div>
</div>
<div class="controls-row">
<button class="console-btn secondary" id="resetBtn">
<i class="fas fa-redo"></i> Reset
</button>
<button class="console-btn" id="stepBtn">
<i class="fas fa-step-forward"></i> Step
</button>
<button class="console-btn" id="runBtn">
<i class="fas fa-play"></i> Run
</button>
<button class="console-btn" id="pauseBtn">
<i class="fas fa-pause"></i> Pause
</button>
</div>
<div class="console-input">
<input id="learningRate" placeholder="Learning Rate" type="number" value="0.1" step="0.01" min="0.01" max="1"/>
<input id="dataSize" placeholder="Data Size" type="number" value="50" min="10" max="200"/>
<select id="dataDistribution">
  <option value="linear">Linearly Separable</option>
  <option value="random">Random Distribution</option>
  <option value="xor">XOR (Not Separable)</option>
</select>
</div>
</div>
</div>
<!-- Algorithm Steps -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Perceptron Learning Steps</h2>
<p>
              The Perceptron algorithm follows these steps to learn the optimal decision boundary:
            </p>
<div class="key-points">
<div class="point-card">
<h3><i class="fas fa-key"></i> 1. Initialize Weights</h3>
<p>
                  Set initial weights w0, w1, w2 to small random values or zeros
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-share-alt"></i> 2. For Each Training Example</h3>
<p>
                  Present (xi, yi) where xi is the input vector and yi is the target output
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-lock"></i> 3. Compute Output</h3>
<p>
                  Calculate ŷ = sign(w0 + w1*xi1 + w2*xi2) using current weights
                </p>
</div>
<div class="point-card">
<h3>
<i class="fas fa-paper-plane"></i> 4. Update Weights if Misclassified
                </h3>
<p>
                  If ŷ ≠ yi, update: w = w + η * yi * xi (where η is learning rate)
                </p>
</div>
<div class="point-card">
<h3><i class="fas fa-unlock"></i> 5. Repeat Until Convergence</h3>
<p>
                  Continue until all examples are correctly classified (or max iterations reached)
                </p>
</div>
</div>
</div>
<!-- Pseudocode Section -->
<div class="section">
<h2><i class="fas fa-list-ol"></i> Perceptron Algorithm</h2>
<div class="code-block">
<pre><code>initialize weights w = [w0, w1, w2] to small random values or zeros
learning_rate η

for each training example (x, y):
    ŷ = sign(w0 + w1*x1 + w2*x2)      // prediction
    if ŷ != y:                          // misclassified
        w = w + η * y * x               // update weights
        mistakes += 1

repeat until no mistakes or max iterations</code></pre>
</div>
</div>
<!-- Implementation Section -->
<div class="section">
<h2><i class="fas fa-code"></i> Implementation</h2>
<p>
              Below is a Python implementation of the Perceptron Learning Algorithm. The implementation includes visualization of the decision boundary changing over time as the algorithm learns.
            </p>
<div class="code-block">
<div class="code-header">
<span>Python Implementation</span>
<button class="copy-btn">
<i class="fas fa-copy"></i> Copy Code
                </button>
</div>
<pre><code><span class="keyword">class</span> <span class="function">Perceptron</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, learning_rate=<span class="number">0.1</span>):
        <span class="keyword">self</span>.learning_rate = learning_rate
        <span class="keyword">self</span>.weights = <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">fit</span>(<span class="keyword">self</span>, X, y, max_iterations=<span class="number">1000</span>):
        <span class="comment"># Add bias term to features</span>
        X_with_bias = np.c_[np.ones((X.shape[<span class="number">0</span>], <span class="number">1</span>)), X]
        
        <span class="comment"># Initialize weights</span>
        <span class="keyword">self</span>.weights = np.zeros(X_with_bias.shape[<span class="number">1</span>])
        
        <span class="keyword">for</span> iteration <span class="keyword">in</span> range(max_iterations):
            mistakes = <span class="number">0</span>
            
            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X_with_bias)):
                <span class="comment"># Compute prediction</span>
                prediction = <span class="function">np.dot</span>(<span class="keyword">self</span>.weights, X_with_bias[i])
                predicted_class = <span class="number">1</span> <span class="keyword">if</span> prediction >= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span>
                
                <span class="comment"># Update weights if misclassified</span>
                <span class="keyword">if</span> predicted_class != y[i]:
                    <span class="keyword">self</span>.weights += <span class="keyword">self</span>.learning_rate * y[i] * X_with_bias[i]
                    mistakes += <span class="number">1</span>
            
            <span class="keyword">if</span> mistakes == <span class="number">0</span>:
                <span class="keyword">break</span>  <span class="comment"># Converged</span>
        
        <span class="keyword">return</span> iteration + <span class="number">1</span>  <span class="comment"># Return number of iterations</span>

    <span class="keyword">def</span> <span class="function">predict</span>(<span class="keyword">self</span>, X):
        X_with_bias = np.c_[np.ones((X.shape[<span class="number">0</span>], <span class="number">1</span>)), X]
        predictions = np.dot(X_with_bias, <span class="keyword">self</span>.weights)
        <span class="keyword">return</span> np.where(predictions >= <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>)</code></pre>
</div>
</div>
</div>
</div>
<!-- Right Column: Additional Info -->
<div class="right-column">
<!-- Properties Section -->
<div class="section">
<h2><i class="fas fa-info-circle"></i> Algorithm Properties</h2>
<div class="properties-grid">
<div class="property-card">
<h4>Category</h4>
<div class="value">Linear Classification</div>
</div>
<div class="property-card">
<h4>Type</h4>
<div class="value">Supervised Learning</div>
</div>
<div class="property-card">
<h4>Model Type</h4>
<div class="value">Linear Classifier</div>
</div>
<div class="property-card">
<h4>Memory</h4>
<div class="value">O(n)</div>
</div>
<div class="property-card">
<h4>Per Iteration</h4>
<div class="value">O(n)</div>
</div>
<div class="property-card">
<h4>Assumption</h4>
<div class="value">Linearly Separable</div>
</div>
<div class="property-card">
<h4>Convergence</h4>
<div class="value">If Separable</div>
</div>
<div class="property-card">
<h4>Applications</h4>
<div class="value">Binary Classification</div>
</div>
</div>
</div>
<!-- Applications Section -->
<div class="section">
<h2><i class="fas fa-lightbulb"></i> Applications</h2>
<p>
              Perceptron Learning Algorithm has applications in various domains:
            </p>
<ul style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              ">
<li style="margin-bottom: 10px">
                Binary document classification
              </li>
<li style="margin-bottom: 10px">
                Handwritten digit recognition (early stages)
              </li>
<li style="margin-bottom: 10px">Sentiment analysis</li>
<li style="margin-bottom: 10px">
                Medical diagnosis systems
              </li>
<li style="margin-bottom: 10px">
                Credit scoring and loan approval
              </li>
<li style="margin-bottom: 10px">Pattern recognition</li>
</ul>
</div>
</div>
</div>
<!-- Footer -->
<footer>
<div class="footer-links">
<a href="https://www.linkedin.com/in/sgkandale/" target="_blank"><i class="fa-brands fa-linkedin"></i> LinkedIN</a>
<a href="mailto:me@sgkandale.com"><i class="fa-solid fa-at"></i> E-Mail</a>
<a href="https://buymeacoffee.com/sgkandale" target="_blank"><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a>
</div>
<p>AlgoViz Hub - Interactive Algorithm Visualization Platform</p>
<p>© 2025 AlgoViz Hub. All rights reserved.</p>
</footer>
</div>
<script>
      // Simple copy button functionality
      document
        .querySelector(".copy-btn")
        .addEventListener("click", function () {
          const code = document.querySelector(".code-block code").innerText;
          navigator.clipboard.writeText(code);

          // Show feedback
          const originalText = this.innerHTML;
          this.innerHTML = '<i class="fas fa-check"></i> Copied!';

          setTimeout(() => {
            this.innerHTML = originalText;
          }, 2000);
        });

      // Canvas initialization
      document.addEventListener("DOMContentLoaded", function() {
        const canvas = document.getElementById('perceptronCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to match its container
        function resizeCanvas() {
          const container = canvas.parentElement;
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        const iterationCount = document.getElementById('iterationCount');
        const mistakeCount = document.getElementById('mistakeCount');
        const w0Value = document.getElementById('w0Value');
        const w1Value = document.getElementById('w1Value');
        const w2Value = document.getElementById('w2Value');
        
        // Perceptron algorithm variables
        let weights = [0, 0, 0]; // [bias, w1, w2]
        let learningRate = parseFloat(document.getElementById('learningRate').value);
        let dataPoints = [];
        let running = false;
        let animationId = null;
        let totalMistakes = 0;
        let currentIteration = 0;
        let dataDistribution = document.getElementById('dataDistribution').value;
        
        // Initialize the algorithm
        resetAlgorithm();
        
        // Event listeners
        document.getElementById('resetBtn').addEventListener('click', resetAlgorithm);
        document.getElementById('stepBtn').addEventListener('click', stepAlgorithm);
        document.getElementById('runBtn').addEventListener('click', runAlgorithm);
        document.getElementById('pauseBtn').addEventListener('click', pauseAlgorithm);
        document.getElementById('learningRate').addEventListener('change', function() {
          learningRate = parseFloat(this.value);
        });
        document.getElementById('dataSize').addEventListener('change', function() {
          resetAlgorithm();
        });
        document.getElementById('dataDistribution').addEventListener('change', function() {
          dataDistribution = this.value;
          resetAlgorithm();
        });
        
        function resetAlgorithm() {
          // Clear any running animation
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          running = false;
          
          // Reset variables
          weights = [0, 0, 0]; // Reset weights
          totalMistakes = 0;
          currentIteration = 0;
          iterationCount.textContent = '0';
          mistakeCount.textContent = '0';
          w0Value.textContent = '0.00';
          w1Value.textContent = '0.00';
          w2Value.textContent = '0.00';
          
          // Generate new data points based on selected distribution
          const dataSize = parseInt(document.getElementById('dataSize').value);
          dataPoints = generateDataPoints(dataSize, dataDistribution);
          
          // Draw initial state
          drawVisualization();
        }
        
        function generateDataPoints(count, distribution) {
          const points = [];
          
          for (let i = 0; i < count; i++) {
            // Generate random point in canvas coordinates
            const x1 = Math.random();
            const x2 = Math.random();
            
            let label = 1; // Default positive class
            
            // Different distributions
            switch(distribution) {
              case 'linear':
                // Create linearly separable data
                if (x1 + x2 < 1) {
                  label = -1; // Negative class
                }
                break;
              case 'random':
                // Random assignment
                label = Math.random() > 0.5 ? 1 : -1;
                break;
              case 'xor':
                // XOR-like distribution (not linearly separable)
                if ((x1 < 0.5 && x2 < 0.5) || (x1 > 0.5 && x2 > 0.5)) {
                  label = -1; // Negative class
                }
                break;
            }
            
            points.push({x1: x1, x2: x2, label: label});
          }
          
          return points;
        }
        
        function stepAlgorithm() {
          if (dataPoints.length === 0) return;
          
          // Find the next misclassified point
          let misclassifiedIndex = -1;
          for (let i = 0; i < dataPoints.length; i++) {
            const point = dataPoints[i];
            const prediction = predictPoint(point);
            
            if (prediction !== point.label) {
              misclassifiedIndex = i;
              break;
            }
          }
          
          // If we found a misclassified point, update weights
          if (misclassifiedIndex !== -1) {
            const point = dataPoints[misclassifiedIndex];
            // Update weights: w = w + η * y * x
            weights[0] += learningRate * point.label; // bias update
            weights[1] += learningRate * point.label * point.x1; // w1 update
            weights[2] += learningRate * point.label * point.x2; // w2 update
            totalMistakes++;
          } else {
            // If no misclassified points, the algorithm has converged
            console.log("Algorithm converged at iteration: " + currentIteration);
          }
          
          currentIteration++;
          updateDisplay();
          drawVisualization();
        }
        
        function predictPoint(point) {
          const z = weights[0] + weights[1] * point.x1 + weights[2] * point.x2;
          return z >= 0 ? 1 : -1;
        }
        
        function runAlgorithm() {
          if (running) return;
          running = true;
          step();
        }
        
        function step() {
          if (!running) return;
          
          // Perform one step of the algorithm
          stepAlgorithm();
          
          // Schedule the next step
          setTimeout(() => {
            if (running) {
              animationId = requestAnimationFrame(step);
            }
          }, 200); // Slow down for visualization
        }
        
        function pauseAlgorithm() {
          running = false;
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
        }
        
        function updateDisplay() {
          iterationCount.textContent = currentIteration;
          mistakeCount.textContent = totalMistakes;
          w0Value.textContent = weights[0].toFixed(2);
          w1Value.textContent = weights[1].toFixed(2);
          w2Value.textContent = weights[2].toFixed(2);
        }
        
        function drawVisualization() {
          const width = canvas.width;
          const height = canvas.height;
          
          // Clear canvas
          ctx.fillStyle = '#1e293b';
          ctx.fillRect(0, 0, width, height);
          
          // Draw data points
          dataPoints.forEach(point => {
            const x = point.x1 * width;
            const y = (1 - point.x2) * height; // Flip Y coordinate
            const prediction = predictPoint(point);
            const isCorrect = (prediction === point.label);
            
            // Color based on actual class
            if (point.label === 1) {
              ctx.fillStyle = isCorrect ? '#3b82f6' : '#22c55e'; // Blue for correct, green for misclassified
            } else {
              ctx.fillStyle = isCorrect ? '#ef4444' : '#f97316'; // Red for correct, orange for misclassified
            }
            
            // Draw point
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw border for misclassified points
            if (!isCorrect) {
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          });
          
          // Draw decision boundary if weights are not all zero
          if (!(weights[1] === 0 && weights[2] === 0)) {
            ctx.beginPath();
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            
            // Calculate boundary: w0 + w1*x1 + w2*x2 = 0
            // So x2 = -(w0 + w1*x1) / w2
            const x1_start = 0;
            const x1_end = 1;
            
            const x2_start = -(weights[0] + weights[1] * x1_start) / weights[2];
            const x2_end = -(weights[0] + weights[1] * x1_end) / weights[2];
            
            ctx.moveTo(x1_start * width, (1 - x2_start) * height);
            ctx.lineTo(x1_end * width, (1 - x2_end) * height);
            ctx.stroke();
          }
        }
        
        // Initial draw
        drawVisualization();
      });
    </script>
</body>
</html>