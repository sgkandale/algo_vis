<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NRU Page Replacement Algorithm</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        color: #ecf0f1;
        min-height: 100vh;
        padding: 20px;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        padding: 30px 0;
        margin-bottom: 20px;
      }

      h1 {
        font-size: 3.2rem;
        margin-bottom: 15px;
        background: linear-gradient(to right, #00b09b, #96c93d);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .subtitle {
        font-size: 1.3rem;
        color: #bdc3c7;
        max-width: 800px;
        margin: 0 auto 25px;
      }

      .card {
        background: rgba(25, 40, 65, 0.8);
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .card-title {
        font-size: 1.8rem;
        margin-bottom: 20px;
        color: #00b09b;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .card-title i {
        background: linear-gradient(45deg, #00b09b, #96c93d);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 25px;
        align-items: center;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 1;
        min-width: 200px;
      }

      label {
        font-weight: 600;
        color: #96c93d;
      }

      input,
      select {
        padding: 12px 15px;
        border-radius: 8px;
        border: 2px solid #3a506b;
        background: rgba(30, 50, 80, 0.7);
        color: white;
        font-size: 1rem;
        transition: all 0.3s ease;
      }

      input:focus,
      select:focus {
        outline: none;
        border-color: #00b09b;
        box-shadow: 0 0 10px rgba(0, 176, 155, 0.5);
      }

      .btn {
        background: linear-gradient(45deg, #00b09b, #96c93d);
        color: white;
        border: none;
        padding: 14px 25px;
        border-radius: 50px;
        cursor: pointer;
        font-size: 1.1rem;
        font-weight: 600;
        transition: all 0.3s ease;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 8px;
      }

      .btn:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      }

      .btn:active {
        transform: translateY(2px);
      }

      .btn-outline {
        background: transparent;
        border: 2px solid #00b09b;
        color: #00b09b;
      }

      .btn-outline:hover {
        background: rgba(0, 176, 155, 0.15);
      }

      .visualization-container {
        display: flex;
        flex-direction: column;
        gap: 30px;
        margin-top: 20px;
      }

      .frames-container {
        display: flex;
        justify-content: center;
        gap: 25px;
        flex-wrap: wrap;
        margin: 20px 0;
      }

      .frame {
        width: 160px;
        height: 160px;
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
        border: 3px solid #3a506b;
        background: rgba(40, 65, 100, 0.8);
      }

      .frame::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.15),
          transparent
        );
      }

      .frame-label {
        position: absolute;
        top: 8px;
        left: 8px;
        font-size: 0.9rem;
        color: #96c93d;
      }

      .frame-content {
        font-size: 2.5rem;
        font-weight: bold;
        margin-top: 10px;
      }

      .frame-bits {
        display: flex;
        gap: 15px;
        margin-top: 15px;
      }

      .bit {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        background: rgba(30, 50, 80, 0.7);
        border: 2px solid #3a506b;
      }

      .bit.active {
        background: linear-gradient(45deg, #00b09b, #96c93d);
      }

      .bit-label {
        position: absolute;
        bottom: 5px;
        font-size: 0.7rem;
      }

      .r-bit .bit-label {
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
      }

      .m-bit .bit-label {
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
      }

      .frame-info {
        position: absolute;
        bottom: 8px;
        font-size: 0.9rem;
        color: #a0d2eb;
        text-align: center;
        width: 100%;
        padding: 0 5px;
      }

      .reference-string {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 15px;
        margin: 30px 0;
      }

      .ref-item {
        width: 70px;
        height: 70px;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 1.2rem;
        font-weight: bold;
        background: rgba(40, 65, 100, 0.8);
        border: 2px solid #3a506b;
        transition: all 0.3s ease;
      }

      .ref-op {
        font-size: 0.8rem;
        margin-top: 3px;
        color: #96c93d;
      }

      .ref-item.active {
        transform: scale(1.2);
        background: linear-gradient(45deg, #00b09b, #96c93d);
        box-shadow: 0 0 20px rgba(0, 176, 155, 0.7);
        z-index: 10;
      }

      .ref-item.hit {
        background: linear-gradient(45deg, #2ecc71, #27ae60);
      }

      .ref-item.fault {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
      }

      .stats-container {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 30px;
        margin: 30px 0;
      }

      .stat-card {
        background: rgba(40, 65, 100, 0.8);
        border-radius: 12px;
        padding: 20px;
        min-width: 200px;
        text-align: center;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      }

      .stat-value {
        font-size: 2.5rem;
        font-weight: bold;
        margin: 10px 0;
        color: #00b09b;
      }

      .stat-label {
        font-size: 1.1rem;
        color: #a0d2eb;
      }

      .history-container {
        margin-top: 20px;
      }

      .history-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
      }

      .history-table th {
        background: rgba(0, 176, 155, 0.3);
        padding: 12px;
        text-align: center;
      }

      .history-table td {
        padding: 12px;
        text-align: center;
        border-bottom: 1px solid #3a506b;
      }

      .history-table tr:nth-child(even) {
        background: rgba(30, 50, 80, 0.5);
      }

      .explanation {
        margin-top: 40px;
      }

      .explanation-content {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 25px;
        margin-top: 20px;
      }

      .explanation-card {
        background: rgba(40, 65, 100, 0.6);
        border-radius: 12px;
        padding: 20px;
      }

      .card-heading {
        font-size: 1.4rem;
        margin-bottom: 15px;
        color: #00b09b;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .nru-classes {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
        margin-top: 20px;
      }

      .class-card {
        background: rgba(30, 50, 80, 0.7);
        border-radius: 10px;
        padding: 15px;
        text-align: center;
      }

      .class-title {
        font-weight: bold;
        margin-bottom: 10px;
        color: #96c93d;
      }

      .class-desc {
        font-size: 0.9rem;
      }

      .class-card.priority {
        border: 2px solid #00b09b;
        box-shadow: 0 0 15px rgba(0, 176, 155, 0.5);
      }

      footer {
        text-align: center;
        padding: 30px 20px 20px;
        color: #7f8c8d;
        font-size: 1rem;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        margin-top: 20px;
      }

      /* Animation classes */
      .highlight {
        animation: highlight 1.5s ease;
      }

      @keyframes highlight {
        0% {
          box-shadow: 0 0 0 0 rgba(0, 176, 155, 0.7);
        }
        70% {
          box-shadow: 0 0 0 20px rgba(0, 176, 155, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 176, 155, 0);
        }
      }

      .pulse {
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .replaced {
        animation: replaced 0.5s ease;
      }

      @keyframes replaced {
        0% {
          background: #e74c3c;
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      @media (max-width: 768px) {
        h1 {
          font-size: 2.5rem;
        }

        .subtitle {
          font-size: 1.1rem;
        }

        .frame {
          width: 140px;
          height: 140px;
        }

        .ref-item {
          width: 60px;
          height: 60px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>NRU Page Replacement Algorithm</h1>
        <p class="subtitle">
          Visualization of the Not Recently Used (NRU) page replacement
          algorithm
        </p>
      </header>

      <section class="card">
        <h2 class="card-title">
          <i class="fas fa-sliders-h"></i> Simulation Controls
        </h2>
        <div class="controls">
          <div class="control-group">
            <label for="referenceInput"
              ><i class="fas fa-list-ol"></i> Reference String</label
            >
            <input
              type="text"
              id="referenceInput"
              value="1r,2w,3r,4w,1r,2w,5r,1r,2w,3r,4w,5r"
            />
          </div>

          <div class="control-group">
            <label for="frameCount"
              ><i class="fas fa-border-all"></i> Number of Frames</label
            >
            <select id="frameCount">
              <option value="3" selected>3 Frames</option>
              <option value="4">4 Frames</option>
              <option value="5">5 Frames</option>
            </select>
          </div>

          <div class="control-group">
            <label for="speedControl"
              ><i class="fas fa-tachometer-alt"></i> Animation Speed</label
            >
            <select id="speedControl">
              <option value="1500">Slow</option>
              <option value="1000" selected>Medium</option>
              <option value="500">Fast</option>
            </select>
          </div>

          <div class="control-group">
            <button class="btn" id="startBtn">
              <i class="fas fa-play"></i> Start Simulation
            </button>
            <button class="btn btn-outline" id="resetBtn">
              <i class="fas fa-undo"></i> Reset
            </button>
          </div>
        </div>

        <div class="controls">
          <button class="btn" id="prevBtn">
            <i class="fas fa-step-backward"></i> Previous
          </button>
          <button class="btn" id="nextBtn">
            <i class="fas fa-step-forward"></i> Next
          </button>
          <button class="btn" id="autoBtn">
            <i class="fas fa-sync-alt"></i> Auto Run
          </button>
        </div>
      </section>

      <section class="card">
        <h2 class="card-title"><i class="fas fa-tv"></i> Visualization</h2>

        <div class="visualization-container">
          <h3>
            <i class="fas fa-list"></i> Reference String (r=read, w=write)
          </h3>
          <div class="reference-string" id="refStringContainer">
            <!-- Reference items will be generated here -->
          </div>

          <h3><i class="fas fa-memory"></i> Page Frames</h3>
          <div class="frames-container" id="framesContainer">
            <!-- Page frames will be generated here -->
          </div>

          <h3><i class="fas fa-layer-group"></i> NRU Classification</h3>
          <div class="nru-classes">
            <div class="class-card priority" id="class0">
              <div class="class-title">Class 0 (Highest Priority)</div>
              <div class="class-desc">
                R=0, M=0<br />Not referenced, not modified
              </div>
            </div>
            <div class="class-card" id="class1">
              <div class="class-title">Class 1</div>
              <div class="class-desc">
                R=0, M=1<br />Not referenced, modified
              </div>
            </div>
            <div class="class-card" id="class2">
              <div class="class-title">Class 2</div>
              <div class="class-desc">
                R=1, M=0<br />Referenced, not modified
              </div>
            </div>
            <div class="class-card" id="class3">
              <div class="class-title">Class 3 (Lowest Priority)</div>
              <div class="class-desc">R=1, M=1<br />Referenced, modified</div>
            </div>
          </div>

          <h3><i class="fas fa-chart-line"></i> Statistics</h3>
          <div class="stats-container">
            <div class="stat-card">
              <div class="stat-label">Page Faults</div>
              <div class="stat-value" id="faultCount">0</div>
              <div>Misses when page not in memory</div>
            </div>

            <div class="stat-card">
              <div class="stat-label">Page Hits</div>
              <div class="stat-value" id="hitCount">0</div>
              <div>Successes when page found</div>
            </div>

            <div class="stat-card">
              <div class="stat-label">Fault Rate</div>
              <div class="stat-value" id="faultRate">0%</div>
              <div>Faults / Total References</div>
            </div>
          </div>

          <div class="history-container">
            <h3><i class="fas fa-history"></i> Replacement History</h3>
            <table class="history-table">
              <thead>
                <tr>
                  <th>Step</th>
                  <th>Page</th>
                  <th>Op</th>
                  <th>Status</th>
                  <th>Frames</th>
                  <th>Replaced</th>
                  <th>Class</th>
                </tr>
              </thead>
              <tbody id="historyBody">
                <!-- History rows will be added here -->
              </tbody>
            </table>
          </div>
        </div>
      </section>

      <section class="card explanation">
        <h2 class="card-title">
          <i class="fas fa-lightbulb"></i> How NRU Works
        </h2>
        <div class="explanation-content">
          <div class="explanation-card">
            <h3 class="card-heading"><i class="fas fa-1"></i> Concept</h3>
            <p>
              The Not Recently Used (NRU) page replacement algorithm classifies
              pages into four categories based on two hardware bits:
            </p>
            <ul>
              <li>
                <strong>R (Referenced)</strong>: Set when page is accessed
              </li>
              <li>
                <strong>M (Modified)</strong>: Set when page is written to
              </li>
            </ul>
            <p>
              NRU periodically clears the R bit (simulated by clock interrupts)
              and selects a page from the lowest non-empty class.
            </p>
          </div>

          <div class="explanation-card">
            <h3 class="card-heading">
              <i class="fas fa-2"></i> Classification
            </h3>
            <p>Pages are classified into four categories:</p>
            <ul>
              <li><strong>Class 0</strong>: R=0, M=0 (highest priority)</li>
              <li><strong>Class 1</strong>: R=0, M=1</li>
              <li><strong>Class 2</strong>: R=1, M=0</li>
              <li><strong>Class 3</strong>: R=1, M=1 (lowest priority)</li>
            </ul>
            <p>
              The algorithm selects a victim page from the lowest non-empty
              class, with random selection within a class.
            </p>
          </div>

          <div class="explanation-card">
            <h3 class="card-heading"><i class="fas fa-3"></i> Advantages</h3>
            <ul>
              <li>Simple to implement</li>
              <li>Low overhead</li>
              <li>Performs reasonably well</li>
              <li>Approximates LRU with less complexity</li>
              <li>Periodic R-bit clearing provides aging effect</li>
            </ul>
          </div>

          <div class="explanation-card">
            <h3 class="card-heading"><i class="fas fa-4"></i> Disadvantages</h3>
            <ul>
              <li>Not optimal - may replace useful pages</li>
              <li>Performance depends on clearing interval</li>
              <li>Random selection within classes can be suboptimal</li>
              <li>Less efficient than LRU in many cases</li>
            </ul>
          </div>
        </div>
      </section>

      <footer>
        <p>
          NRU Page Replacement Algorithm Visualization | Created for Educational
          Purposes
        </p>
        <p>
          Note: This visualization demonstrates the algorithm behavior and does
          not interact with actual system memory
        </p>
      </footer>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // DOM elements
        const refInput = document.getElementById("referenceInput");
        const frameCount = document.getElementById("frameCount");
        const speedControl = document.getElementById("speedControl");
        const startBtn = document.getElementById("startBtn");
        const resetBtn = document.getElementById("resetBtn");
        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");
        const autoBtn = document.getElementById("autoBtn");
        const refStringContainer =
          document.getElementById("refStringContainer");
        const framesContainer = document.getElementById("framesContainer");
        const faultCount = document.getElementById("faultCount");
        const hitCount = document.getElementById("hitCount");
        const faultRate = document.getElementById("faultRate");
        const historyBody = document.getElementById("historyBody");
        const class0 = document.getElementById("class0");
        const class1 = document.getElementById("class1");
        const class2 = document.getElementById("class2");
        const class3 = document.getElementById("class3");

        // Algorithm variables
        let referenceString = [];
        let frames = [];
        let rBits = {};
        let mBits = {};
        let currentStep = 0;
        let pageFaults = 0;
        let pageHits = 0;
        let history = [];
        let animationInterval;
        let clearCounter = 0;
        const clearInterval = 4; // Clear R bits every 4 steps

        // Initialize visualization
        function initializeVisualization() {
          // Parse reference string
          const refString = refInput.value.split(",");
          referenceString = refString.map((item) => {
            const parts = item.trim().match(/(\d+)([rw])/);
            if (parts && parts.length === 3) {
              return { page: parts[1], op: parts[2] };
            }
            return { page: item.trim(), op: "r" }; // Default to read
          });

          // Clear previous state
          frames = Array(parseInt(frameCount.value)).fill(null);
          rBits = {};
          mBits = {};
          currentStep = 0;
          pageFaults = 0;
          pageHits = 0;
          history = [];
          clearCounter = 0;

          // Initialize R and M bits for all pages
          referenceString.forEach((ref) => {
            rBits[ref.page] = 0;
            mBits[ref.page] = 0;
          });

          // Reset class highlighting
          [class0, class1, class2, class3].forEach((c) =>
            c.classList.remove("priority")
          );
          class0.classList.add("priority");

          // Update UI
          updateRefStringDisplay();
          createFrames();
          updateStats();
          updateHistory();

          // Highlight first reference
          highlightCurrentStep();
        }

        // Create reference string display
        function updateRefStringDisplay() {
          refStringContainer.innerHTML = "";
          referenceString.forEach((ref, index) => {
            const refItem = document.createElement("div");
            refItem.className = "ref-item";

            const pageEl = document.createElement("div");
            pageEl.textContent = ref.page;

            const opEl = document.createElement("div");
            opEl.className = "ref-op";
            opEl.textContent = ref.op === "w" ? "write" : "read";
            opEl.style.color = ref.op === "w" ? "#ff6b6b" : "#4facfe";

            refItem.appendChild(pageEl);
            refItem.appendChild(opEl);
            refItem.dataset.index = index;
            refStringContainer.appendChild(refItem);
          });
        }

        // Create frame elements
        function createFrames() {
          framesContainer.innerHTML = "";
          for (let i = 0; i < frames.length; i++) {
            const frame = document.createElement("div");
            frame.className = "frame";
            frame.dataset.index = i;

            const label = document.createElement("div");
            label.className = "frame-label";
            label.textContent = `Frame ${i + 1}`;

            const content = document.createElement("div");
            content.className = "frame-content";
            content.textContent = frames[i] || "-";

            const bitsContainer = document.createElement("div");
            bitsContainer.className = "frame-bits";

            const rBit = document.createElement("div");
            rBit.className = "bit r-bit";
            rBit.textContent = "R";

            const rLabel = document.createElement("div");
            rLabel.className = "bit-label";
            rLabel.textContent = "0";

            const mBit = document.createElement("div");
            mBit.className = "bit m-bit";
            mBit.textContent = "M";

            const mLabel = document.createElement("div");
            mLabel.className = "bit-label";
            mLabel.textContent = "0";

            rBit.appendChild(rLabel);
            mBit.appendChild(mLabel);
            bitsContainer.appendChild(rBit);
            bitsContainer.appendChild(mBit);

            const info = document.createElement("div");
            info.className = "frame-info";
            info.textContent = "Class: -";

            frame.appendChild(label);
            frame.appendChild(content);
            frame.appendChild(bitsContainer);
            frame.appendChild(info);
            framesContainer.appendChild(frame);
          }
        }

        // Update frame display
        function updateFrames() {
          const frameElements = framesContainer.querySelectorAll(".frame");
          frameElements.forEach((frameEl, index) => {
            const content = frameEl.querySelector(".frame-content");
            const rBit = frameEl.querySelector(".r-bit");
            const rLabel = frameEl.querySelector(".r-bit .bit-label");
            const mBit = frameEl.querySelector(".m-bit");
            const mLabel = frameEl.querySelector(".m-bit .bit-label");
            const info = frameEl.querySelector(".frame-info");

            if (frames[index]) {
              const page = frames[index];
              content.textContent = page;

              // Update R bit display
              rLabel.textContent = rBits[page] || "0";
              rBit.classList.toggle("active", rBits[page] === 1);

              // Update M bit display
              mLabel.textContent = mBits[page] || "0";
              mBit.classList.toggle("active", mBits[page] === 1);

              // Update class
              const pageClass = getPageClass(page);
              info.textContent = `Class: ${pageClass}`;
            } else {
              content.textContent = "-";
              rLabel.textContent = "0";
              mLabel.textContent = "0";
              rBit.classList.remove("active");
              mBit.classList.remove("active");
              info.textContent = "Class: -";
            }
          });
        }

        // Get the class of a page
        function getPageClass(page) {
          if (rBits[page] === 0 && mBits[page] === 0) return 0;
          if (rBits[page] === 0 && mBits[page] === 1) return 1;
          if (rBits[page] === 1 && mBits[page] === 0) return 2;
          if (rBits[page] === 1 && mBits[page] === 1) return 3;
          return -1;
        }

        // Update statistics
        function updateStats() {
          faultCount.textContent = pageFaults;
          hitCount.textContent = pageHits;

          const total = pageFaults + pageHits;
          const rate = total > 0 ? Math.round((pageFaults / total) * 100) : 0;
          faultRate.textContent = `${rate}%`;
        }

        // Update history table
        function updateHistory() {
          historyBody.innerHTML = "";
          history.forEach((entry, index) => {
            const row = document.createElement("tr");

            const stepCell = document.createElement("td");
            stepCell.textContent = index + 1;

            const pageCell = document.createElement("td");
            pageCell.textContent = entry.page;

            const opCell = document.createElement("td");
            opCell.textContent = entry.op;
            opCell.style.color = entry.op === "w" ? "#ff6b6b" : "#4facfe";
            opCell.style.fontWeight = "bold";

            const statusCell = document.createElement("td");
            statusCell.textContent = entry.status;
            statusCell.style.color =
              entry.status === "Hit" ? "#2ecc71" : "#e74c3c";
            statusCell.style.fontWeight = "bold";

            const framesCell = document.createElement("td");
            framesCell.textContent = entry.frames.join(", ") || "Empty";

            const replacedCell = document.createElement("td");
            replacedCell.textContent = entry.replaced || "-";

            const classCell = document.createElement("td");
            classCell.textContent = entry.class || "-";

            row.appendChild(stepCell);
            row.appendChild(pageCell);
            row.appendChild(opCell);
            row.appendChild(statusCell);
            row.appendChild(framesCell);
            row.appendChild(replacedCell);
            row.appendChild(classCell);

            historyBody.appendChild(row);
          });
        }

        // Highlight current step in reference string
        function highlightCurrentStep() {
          const refItems = refStringContainer.querySelectorAll(".ref-item");
          refItems.forEach((item, index) => {
            item.classList.remove("active", "hit", "fault");

            if (index === currentStep) {
              item.classList.add("active");
            }

            // Add hit/fault class for previous steps
            if (index < currentStep) {
              const historyEntry = history[index];
              if (historyEntry) {
                item.classList.add(
                  historyEntry.status === "Hit" ? "hit" : "fault"
                );
              }
            }
          });
        }

        // Clear R bits periodically
        function clearRBits() {
          clearCounter++;
          if (clearCounter >= clearInterval) {
            // Clear all R bits
            Object.keys(rBits).forEach((page) => {
              rBits[page] = 0;
            });
            clearCounter = 0;
            return true;
          }
          return false;
        }

        // Process a step
        function processStep() {
          if (currentStep >= referenceString.length) return;

          const ref = referenceString[currentStep];
          const page = ref.page;
          const op = ref.op;
          let status = "Hit";
          let replacedPage = null;
          let victimClass = null;

          // Check if page is already in a frame
          const pageIndex = frames.indexOf(page);

          if (pageIndex !== -1) {
            // Page is already in memory (hit)
            pageHits++;
            status = "Hit";

            // Set R bit
            rBits[page] = 1;

            // If write operation, set M bit
            if (op === "w") {
              mBits[page] = 1;
            }
          } else {
            // Page fault
            pageFaults++;
            status = "Fault";

            // Check for empty frame
            const emptyIndex = frames.indexOf(null);

            if (emptyIndex !== -1) {
              // There's an empty frame
              frames[emptyIndex] = page;

              // Set R bit and M bit if write
              rBits[page] = 1;
              mBits[page] = op === "w" ? 1 : 0;
            } else {
              // Need to find a victim
              const classes = {
                0: [],
                1: [],
                2: [],
                3: [],
              };

              // Classify all pages in frames
              frames.forEach((framePage) => {
                const pageClass = getPageClass(framePage);
                classes[pageClass].push(framePage);
              });

              // Find the lowest non-empty class
              let victimClassFound = false;
              for (let i = 0; i <= 3; i++) {
                if (classes[i].length > 0) {
                  victimClass = i;
                  victimClassFound = true;
                  break;
                }
              }

              if (victimClassFound) {
                // Select a random page from the victim class
                const victimPool = classes[victimClass];
                const randomIndex = Math.floor(
                  Math.random() * victimPool.length
                );
                const victimPage = victimPool[randomIndex];
                const victimIndex = frames.indexOf(victimPage);

                // Replace the victim page
                replacedPage = victimPage;
                frames[victimIndex] = page;

                // Set R bit and M bit for new page
                rBits[page] = 1;
                mBits[page] = op === "w" ? 1 : 0;

                // Animate the replaced frame
                const frameToReplace = framesContainer.querySelector(
                  `.frame[data-index="${victimIndex}"]`
                );
                frameToReplace.classList.add("replaced");
                setTimeout(() => {
                  frameToReplace.classList.remove("replaced");
                }, 500);
              }
            }
          }

          // Clear R bits periodically
          const cleared = clearRBits();

          // Add to history
          history.push({
            step: currentStep + 1,
            page: page,
            op: op,
            status: status,
            frames: [...frames],
            replaced: replacedPage,
            class: victimClass !== null ? victimClass : undefined,
            cleared: cleared,
          });

          // Update UI
          updateFrames();
          updateStats();
          updateHistory();
          highlightCurrentStep();

          currentStep++;
        }

        // Start simulation
        function startSimulation() {
          clearInterval(animationInterval);
          const speed = parseInt(speedControl.value);

          // Reset if we're at the end
          if (currentStep >= referenceString.length) {
            initializeVisualization();
          }

          animationInterval = setInterval(() => {
            processStep();
            if (currentStep >= referenceString.length) {
              clearInterval(animationInterval);
            }
          }, speed);
        }

        // Initialize
        initializeVisualization();

        // Event listeners
        startBtn.addEventListener("click", function () {
          startSimulation();
        });

        resetBtn.addEventListener("click", function () {
          clearInterval(animationInterval);
          initializeVisualization();
        });

        prevBtn.addEventListener("click", function () {
          clearInterval(animationInterval);
          if (currentStep > 0) {
            // Move back one step
            currentStep--;
            const lastHistory = history.pop();

            // Reset stats
            pageFaults = history.filter(
              (entry) => entry.status === "Fault"
            ).length;
            pageHits = history.filter((entry) => entry.status === "Hit").length;

            if (history.length > 0) {
              const lastEntry = history[history.length - 1];
              frames = [...lastEntry.frames];

              // Restore R and M bits from history
              // (This would require storing bit history, but for simplicity we'll reset)
              // In a full implementation, we'd need to store the bit history
            } else {
              frames = Array(parseInt(frameCount.value)).fill(null);
              // Reset bits
              Object.keys(rBits).forEach((page) => {
                rBits[page] = 0;
                mBits[page] = 0;
              });
            }

            // Update UI
            updateFrames();
            updateStats();
            updateHistory();
            highlightCurrentStep();
          }
        });

        nextBtn.addEventListener("click", function () {
          clearInterval(animationInterval);
          if (currentStep < referenceString.length) {
            processStep();
          }
        });

        autoBtn.addEventListener("click", function () {
          startSimulation();
        });

        frameCount.addEventListener("change", function () {
          initializeVisualization();
        });
      });
    </script>
  </body>
</html>
