<!DOCTYPE html>

<html lang="en">
<head><meta content="Study page replacement algorithms used in operating systems memory management" name="description"/><meta content="page replacement algorithm, fifo, lru, lfu, mru, nru, second chance" name="keywords"/>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Second-Chance Page Replacement Algorithm</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        color: #ecf0f1;
        min-height: 100vh;
        padding: 20px;
        line-height: 1.6;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        padding: 30px 0;
        margin-bottom: 20px;
      }

      h1 {
        font-size: 3.2rem;
        margin-bottom: 15px;
        background: linear-gradient(to right, #ff9a9e, #fad0c4);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .subtitle {
        font-size: 1.3rem;
        color: #bdc3c7;
        max-width: 800px;
        margin: 0 auto 25px;
      }

      .card {
        background: rgba(25, 40, 65, 0.8);
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .card-title {
        font-size: 1.8rem;
        margin-bottom: 20px;
        color: #ff9a9e;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .card-title i {
        background: linear-gradient(45deg, #ff9a9e, #fad0c4);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 25px;
        align-items: center;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 1;
        min-width: 200px;
      }

      label {
        font-weight: 600;
        color: #fad0c4;
      }

      input,
      select {
        padding: 12px 15px;
        border-radius: 8px;
        border: 2px solid #3a506b;
        background: rgba(30, 50, 80, 0.7);
        color: white;
        font-size: 1rem;
        transition: all 0.3s ease;
      }

      input:focus,
      select:focus {
        outline: none;
        border-color: #ff9a9e;
        box-shadow: 0 0 10px rgba(255, 154, 158, 0.5);
      }

      .btn {
        background: linear-gradient(45deg, #ff9a9e, #fad0c4);
        color: white;
        border: none;
        padding: 14px 25px;
        border-radius: 50px;
        cursor: pointer;
        font-size: 1.1rem;
        font-weight: 600;
        transition: all 0.3s ease;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        gap: 8px;
        margin-top: 8px;
      }

      .btn:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      }

      .btn:active {
        transform: translateY(2px);
      }

      .btn-outline {
        background: transparent;
        border: 2px solid #ff9a9e;
        color: #ff9a9e;
      }

      .btn-outline:hover {
        background: rgba(255, 154, 158, 0.15);
      }

      .visualization-container {
        display: flex;
        flex-direction: column;
        gap: 30px;
        margin-top: 20px;
      }

      .queue-container {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
        margin: 20px 0;
        min-height: 120px;
        background: rgba(30, 50, 80, 0.5);
        border-radius: 12px;
        padding: 20px;
        position: relative;
      }

      .queue-item {
        width: 80px;
        height: 100px;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        background: rgba(40, 65, 100, 0.8);
        border: 2px solid #3a506b;
        transition: all 0.3s ease;
        position: relative;
      }

      .queue-page {
        font-size: 2rem;
        margin-bottom: 5px;
      }

      .queue-rbit {
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background: #555;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.8rem;
        margin-top: 5px;
      }

      .queue-rbit.active {
        background: linear-gradient(45deg, #ff9a9e, #fad0c4);
      }

      .pointer {
        position: absolute;
        top: -30px;
        font-size: 2rem;
        color: #ff9a9e;
        transform: translateX(-50%);
        transition: left 0.5s ease;
        z-index: 10;
      }

      .reference-string {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 15px;
        margin: 30px 0;
      }

      .ref-item {
        width: 60px;
        height: 60px;
        border-radius: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.5rem;
        font-weight: bold;
        background: rgba(40, 65, 100, 0.8);
        border: 2px solid #3a506b;
        transition: all 0.3s ease;
      }

      .ref-item.active {
        transform: scale(1.2);
        background: linear-gradient(45deg, #ff9a9e, #fad0c4);
        box-shadow: 0 0 20px rgba(255, 154, 158, 0.7);
        z-index: 10;
      }

      .ref-item.hit {
        background: linear-gradient(45deg, #2ecc71, #27ae60);
      }

      .ref-item.fault {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
      }

      .stats-container {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 30px;
        margin: 30px 0;
      }

      .stat-card {
        background: rgba(40, 65, 100, 0.8);
        border-radius: 12px;
        padding: 20px;
        min-width: 200px;
        text-align: center;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      }

      .stat-value {
        font-size: 2.5rem;
        font-weight: bold;
        margin: 10px 0;
        color: #ff9a9e;
      }

      .stat-label {
        font-size: 1.1rem;
        color: #a0d2eb;
      }

      .history-container {
        margin-top: 20px;
      }

      .history-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
      }

      .history-table th {
        background: rgba(255, 154, 158, 0.3);
        padding: 12px;
        text-align: center;
      }

      .history-table td {
        padding: 12px;
        text-align: center;
        border-bottom: 1px solid #3a506b;
      }

      .history-table tr:nth-child(even) {
        background: rgba(30, 50, 80, 0.5);
      }

      .explanation {
        margin-top: 40px;
      }

      .explanation-content {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 25px;
        margin-top: 20px;
      }

      .explanation-card {
        background: rgba(40, 65, 100, 0.6);
        border-radius: 12px;
        padding: 20px;
      }

      .card-heading {
        font-size: 1.4rem;
        margin-bottom: 15px;
        color: #ff9a9e;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      footer {
        text-align: center;
        padding: 30px 20px 20px;
        color: #7f8c8d;
        font-size: 1rem;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        margin-top: 20px;
      }

      .algorithm-steps {
        margin-top: 20px;
        padding: 20px;
        background: rgba(30, 50, 80, 0.5);
        border-radius: 12px;
      }

      .step {
        display: flex;
        margin-bottom: 15px;
        align-items: flex-start;
      }

      .step-number {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background: linear-gradient(45deg, #ff9a9e, #fad0c4);
        display: flex;
        justify-content: center;
        align-items: center;
        margin-right: 15px;
        flex-shrink: 0;
      }

      /* Animation classes */
      .highlight {
        animation: highlight 1.5s ease;
      }

      @keyframes highlight {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 154, 158, 0.7);
        }
        70% {
          box-shadow: 0 0 0 20px rgba(255, 154, 158, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 154, 158, 0);
        }
      }

      .pulse {
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .replaced {
        animation: replaced 0.5s ease;
      }

      @keyframes replaced {
        0% {
          background: #e74c3c;
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }

      .second-chance {
        animation: secondChance 1s ease;
      }

      @keyframes secondChance {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
          background: #ff9a9e;
        }
        100% {
          transform: scale(1);
        }
      }

      @media (max-width: 768px) {
        h1 {
          font-size: 2.5rem;
        }

        .subtitle {
          font-size: 1.1rem;
        }

        .queue-item {
          width: 70px;
          height: 90px;
        }

        .ref-item {
          width: 50px;
          height: 50px;
        }
      }
    </style>
<meta content="Second-Chance Page Replacement Algorithm" property="og:title"/><meta content="Study page replacement algorithms used in operating systems memory management" property="og:description"/><meta content="article" property="og:type"/><meta content="https://sgkandale.github.io/page_replacement_second_chance.html" property="og:url"/><meta content="AlgoViz Hub" property="og:site_name"/><meta content="summary" name="twitter:card"/><meta content="Second-Chance Page Replacement Algorithm" name="twitter:title"/><meta content="Study page replacement algorithms used in operating systems memory management" name="twitter:description"/><meta content="@sgkandale" name="twitter:site"/><link href="https://sgkandale.github.io/page_replacement_second_chance.html" rel="canonical"/><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Second-Chance Page Replacement Algorithm",
  "description": "Study page replacement algorithms used in operating systems memory management",
  "author": {
    "@type": "Person",
    "name": "Shantanu Kandale"
  },
  "publisher": {
    "@type": "Organization",
    "name": "AlgoViz Hub",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sgkandale.github.io/favicon.ico"
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sgkandale.github.io/page_replacement_second_chance.html"
  }
}</script></head>
<body>
<div class="container">
<header>
<h1>Second-Chance Page Replacement</h1>
<p class="subtitle">
          Visualization of the Second-Chance page replacement algorithm
        </p>
</header>
<section class="card">
<h2 class="card-title">
<i class="fas fa-sliders-h"></i> Simulation Controls
        </h2>
<div class="controls">
<div class="control-group">
<label for="referenceInput"><i class="fas fa-list-ol"></i> Reference String</label>
<input id="referenceInput" type="text" value="1,2,3,4,1,2,5,1,2,3,4,5"/>
</div>
<div class="control-group">
<label for="frameCount"><i class="fas fa-border-all"></i> Number of Frames</label>
<select id="frameCount">
<option selected="" value="3">3 Frames</option>
<option value="4">4 Frames</option>
<option value="5">5 Frames</option>
</select>
</div>
<div class="control-group">
<label for="speedControl"><i class="fas fa-tachometer-alt"></i> Animation Speed</label>
<select id="speedControl">
<option value="1500">Slow</option>
<option selected="" value="1000">Medium</option>
<option value="500">Fast</option>
</select>
</div>
<div class="control-group">
<button class="btn" id="startBtn">
<i class="fas fa-play"></i> Start Simulation
            </button>
<button class="btn btn-outline" id="resetBtn">
<i class="fas fa-undo"></i> Reset
            </button>
</div>
</div>
<div class="controls">
<button class="btn" id="prevBtn">
<i class="fas fa-step-backward"></i> Previous
          </button>
<button class="btn" id="nextBtn">
<i class="fas fa-step-forward"></i> Next
          </button>
<button class="btn" id="autoBtn">
<i class="fas fa-sync-alt"></i> Auto Run
          </button>
</div>
</section>
<section class="card">
<h2 class="card-title"><i class="fas fa-tv"></i> Visualization</h2>
<div class="visualization-container">
<h3><i class="fas fa-list"></i> Reference String</h3>
<div class="reference-string" id="refStringContainer">
<!-- Reference items will be generated here -->
</div>
<h3>
<i class="fas fa-redo-alt"></i> Page Queue with Reference Bits
          </h3>
<div class="queue-container" id="queueContainer">
<!-- Queue items will be generated here -->
<div class="pointer" id="queuePointer">â†“</div>
</div>
<h3><i class="fas fa-chart-line"></i> Statistics</h3>
<div class="stats-container">
<div class="stat-card">
<div class="stat-label">Page Faults</div>
<div class="stat-value" id="faultCount">0</div>
<div>Misses when page not in memory</div>
</div>
<div class="stat-card">
<div class="stat-label">Page Hits</div>
<div class="stat-value" id="hitCount">0</div>
<div>Successes when page found</div>
</div>
<div class="stat-card">
<div class="stat-label">Fault Rate</div>
<div class="stat-value" id="faultRate">0%</div>
<div>Faults / Total References</div>
</div>
</div>
<div class="history-container">
<h3><i class="fas fa-history"></i> Replacement History</h3>
<table class="history-table">
<thead>
<tr>
<th>Step</th>
<th>Page</th>
<th>Status</th>
<th>Frames</th>
<th>Replaced</th>
<th>Second Chance</th>
</tr>
</thead>
<tbody id="historyBody">
<!-- History rows will be added here -->
</tbody>
</table>
</div>
</div>
</section>
<section class="card explanation">
<h2 class="card-title">
<i class="fas fa-lightbulb"></i> How Second-Chance Works
        </h2>
<div class="explanation-content">
<div class="explanation-card">
<h3 class="card-heading"><i class="fas fa-1"></i> Concept</h3>
<p>
              The Second-Chance algorithm is an enhancement of FIFO that avoids
              replacing frequently used pages.
            </p>
<p>
              It uses a reference bit (R-bit) to give pages a "second chance"
              before being replaced.
            </p>
</div>
<div class="explanation-card">
<h3 class="card-heading">
<i class="fas fa-2"></i> Implementation
            </h3>
<p>Second-Chance maintains:</p>
<ul>
<li>A circular queue of pages (like FIFO)</li>
<li>A reference bit (R-bit) for each page</li>
<li>A pointer that moves through the queue</li>
</ul>
<p>When a page is accessed, its R-bit is set to 1.</p>
</div>
<div class="explanation-card">
<h3 class="card-heading">
<i class="fas fa-3"></i> Page Replacement
            </h3>
<p>When a page fault occurs:</p>
<ol>
<li>Check the page at the pointer</li>
<li>If R-bit is 0, replace the page</li>
<li>
                If R-bit is 1, give a second chance:
                <ul>
<li>Set R-bit to 0</li>
<li>Move pointer to next page</li>
</ul>
</li>
<li>Repeat until a page with R-bit=0 is found</li>
</ol>
</div>
<div class="explanation-card">
<h3 class="card-heading"><i class="fas fa-4"></i> Advantages</h3>
<ul>
<li>Better performance than FIFO</li>
<li>Simple to implement</li>
<li>Prevents frequently used pages from being replaced</li>
<li>Low overhead compared to LRU</li>
<li>More efficient than pure FIFO</li>
</ul>
</div>
</div>
<div class="algorithm-steps">
<h3 class="card-heading">
<i class="fas fa-list-ol"></i> Algorithm Steps
          </h3>
<div class="step">
<div class="step-number">1</div>
<div>
              When a page is referenced, it's added to the queue with R-bit set
              to 1
            </div>
</div>
<div class="step">
<div class="step-number">2</div>
<div>
              On page fault, start at the pointer and check the current page
            </div>
</div>
<div class="step">
<div class="step-number">3</div>
<div>If the page's R-bit is 0, replace it with the new page</div>
</div>
<div class="step">
<div class="step-number">4</div>
<div>
              If R-bit is 1, give it a second chance: set R-bit to 0 and move
              pointer
            </div>
</div>
<div class="step">
<div class="step-number">5</div>
<div>Continue searching until a page with R-bit=0 is found</div>
</div>
</div>
</section>
<footer>
<p>
          Second-Chance Page Replacement Algorithm Visualization | Created for
          Educational Purposes
        </p>
<p>
          Note: This visualization demonstrates the algorithm behavior and does
          not interact with actual system memory
        </p>
</footer>
</div>
<script>
      document.addEventListener("DOMContentLoaded", function () {
        // DOM elements
        const refInput = document.getElementById("referenceInput");
        const frameCount = document.getElementById("frameCount");
        const speedControl = document.getElementById("speedControl");
        const startBtn = document.getElementById("startBtn");
        const resetBtn = document.getElementById("resetBtn");
        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");
        const autoBtn = document.getElementById("autoBtn");
        const refStringContainer =
          document.getElementById("refStringContainer");
        const queueContainer = document.getElementById("queueContainer");
        const queuePointer = document.getElementById("queuePointer");
        const faultCount = document.getElementById("faultCount");
        const hitCount = document.getElementById("hitCount");
        const faultRate = document.getElementById("faultRate");
        const historyBody = document.getElementById("historyBody");

        // Algorithm variables
        let referenceString = [];
        let queue = [];
        let rBits = {};
        let pointer = 0;
        let currentStep = 0;
        let pageFaults = 0;
        let pageHits = 0;
        let history = [];
        let animationInterval;

        // Initialize visualization
        function initializeVisualization() {
          // Parse reference string
          referenceString = refInput.value
            .split(",")
            .map((item) => item.trim());

          // Clear previous state
          queue = [];
          rBits = {};
          pointer = 0;
          currentStep = 0;
          pageFaults = 0;
          pageHits = 0;
          history = [];

          // Update UI
          updateRefStringDisplay();
          updateQueueDisplay();
          updatePointerPosition();
          updateStats();
          updateHistory();

          // Highlight first reference
          highlightCurrentStep();
        }

        // Create reference string display
        function updateRefStringDisplay() {
          refStringContainer.innerHTML = "";
          referenceString.forEach((ref, index) => {
            const refItem = document.createElement("div");
            refItem.className = "ref-item";
            refItem.textContent = ref;
            refItem.dataset.index = index;
            refStringContainer.appendChild(refItem);
          });
        }

        // Update queue display
        function updateQueueDisplay() {
          queueContainer.innerHTML = "";
          queueContainer.appendChild(queuePointer);

          queue.forEach((page, index) => {
            const queueItem = document.createElement("div");
            queueItem.className = "queue-item";
            queueItem.dataset.index = index;

            const pageEl = document.createElement("div");
            pageEl.className = "queue-page";
            pageEl.textContent = page;

            const rBit = document.createElement("div");
            rBit.className = `queue-rbit ${rBits[page] === 1 ? "active" : ""}`;
            rBit.textContent = "R";

            queueItem.appendChild(pageEl);
            queueItem.appendChild(rBit);
            queueContainer.appendChild(queueItem);
          });

          updatePointerPosition();
        }

        // Update pointer position
        function updatePointerPosition() {
          if (queue.length === 0) {
            queuePointer.style.display = "none";
            return;
          }

          queuePointer.style.display = "block";
          const queueItems = queueContainer.querySelectorAll(".queue-item");

          if (queueItems.length > pointer) {
            const item = queueItems[pointer];
            const rect = item.getBoundingClientRect();
            const containerRect = queueContainer.getBoundingClientRect();

            const leftPos = rect.left - containerRect.left + rect.width / 2;
            queuePointer.style.left = `${leftPos}px`;
          }
        }

        // Update statistics
        function updateStats() {
          faultCount.textContent = pageFaults;
          hitCount.textContent = pageHits;

          const total = pageFaults + pageHits;
          const rate = total > 0 ? Math.round((pageFaults / total) * 100) : 0;
          faultRate.textContent = `${rate}%`;
        }

        // Update history table
        function updateHistory() {
          historyBody.innerHTML = "";
          history.forEach((entry, index) => {
            const row = document.createElement("tr");

            const stepCell = document.createElement("td");
            stepCell.textContent = index + 1;

            const pageCell = document.createElement("td");
            pageCell.textContent = entry.page;

            const statusCell = document.createElement("td");
            statusCell.textContent = entry.status;
            statusCell.style.color =
              entry.status === "Hit" ? "#2ecc71" : "#e74c3c";
            statusCell.style.fontWeight = "bold";

            const framesCell = document.createElement("td");
            framesCell.textContent = entry.queue.join(", ") || "Empty";

            const replacedCell = document.createElement("td");
            replacedCell.textContent = entry.replaced || "-";

            const chanceCell = document.createElement("td");
            chanceCell.textContent = entry.secondChance || "-";

            row.appendChild(stepCell);
            row.appendChild(pageCell);
            row.appendChild(statusCell);
            row.appendChild(framesCell);
            row.appendChild(replacedCell);
            row.appendChild(chanceCell);

            historyBody.appendChild(row);
          });
        }

        // Highlight current step in reference string
        function highlightCurrentStep() {
          const refItems = refStringContainer.querySelectorAll(".ref-item");
          refItems.forEach((item, index) => {
            item.classList.remove("active", "hit", "fault");

            if (index === currentStep) {
              item.classList.add("active");
            }

            // Add hit/fault class for previous steps
            if (index < currentStep) {
              const historyEntry = history[index];
              if (historyEntry) {
                item.classList.add(
                  historyEntry.status === "Hit" ? "hit" : "fault"
                );
              }
            }
          });
        }

        // Process a step
        function processStep() {
          if (currentStep >= referenceString.length) return;

          const page = referenceString[currentStep];
          let status = "Hit";
          let replacedPage = null;
          let secondChance = null;

          // Check if page is already in queue
          const pageIndex = queue.indexOf(page);

          if (pageIndex !== -1) {
            // Page is already in memory (hit)
            pageHits++;
            status = "Hit";

            // Set R-bit to 1
            rBits[page] = 1;

            // Highlight the R-bit
            const queueItems = queueContainer.querySelectorAll(".queue-item");
            if (queueItems[pageIndex]) {
              const rBit = queueItems[pageIndex].querySelector(".queue-rbit");
              rBit.classList.add("second-chance");
              setTimeout(() => {
                rBit.classList.remove("second-chance");
              }, 1000);
            }
          } else {
            // Page fault
            pageFaults++;
            status = "Fault";

            if (queue.length < parseInt(frameCount.value)) {
              // There's space, just add the page
              queue.push(page);
              rBits[page] = 1;
            } else {
              // Need to replace a page
              let replaced = false;
              let searchCount = 0;
              const maxSearches = queue.length * 2; // Prevent infinite loops

              while (!replaced && searchCount < maxSearches) {
                if (rBits[queue[pointer]] === 0) {
                  // Replace this page
                  replacedPage = queue[pointer];
                  queue[pointer] = page;
                  rBits[page] = 1;
                  delete rBits[replacedPage];
                  replaced = true;

                  // Animate the replacement
                  const queueItems =
                    queueContainer.querySelectorAll(".queue-item");
                  if (queueItems[pointer]) {
                    queueItems[pointer].classList.add("replaced");
                    setTimeout(() => {
                      queueItems[pointer].classList.remove("replaced");
                    }, 500);
                  }
                } else {
                  // Give a second chance
                  rBits[queue[pointer]] = 0;
                  secondChance = queue[pointer];

                  // Animate the second chance
                  const queueItems =
                    queueContainer.querySelectorAll(".queue-item");
                  if (queueItems[pointer]) {
                    const rBit =
                      queueItems[pointer].querySelector(".queue-rbit");
                    rBit.classList.add("second-chance");
                    setTimeout(() => {
                      rBit.classList.remove("second-chance");
                    }, 500);
                  }
                }

                // Move pointer to next position
                pointer = (pointer + 1) % queue.length;
                searchCount++;
              }

              if (!replaced) {
                // If we didn't find any page to replace (shouldn't happen), replace the current one
                replacedPage = queue[pointer];
                queue[pointer] = page;
                rBits[page] = 1;
                delete rBits[replacedPage];
              }
            }
          }

          // Add to history
          history.push({
            step: currentStep + 1,
            page: page,
            status: status,
            queue: [...queue],
            replaced: replacedPage,
            secondChance: secondChance,
          });

          // Update UI
          updateQueueDisplay();
          updateStats();
          updateHistory();
          highlightCurrentStep();

          currentStep++;
        }

        // Start simulation
        function startSimulation() {
          clearInterval(animationInterval);
          const speed = parseInt(speedControl.value);

          // Reset if we're at the end
          if (currentStep >= referenceString.length) {
            initializeVisualization();
          }

          animationInterval = setInterval(() => {
            processStep();
            if (currentStep >= referenceString.length) {
              clearInterval(animationInterval);
            }
          }, speed);
        }

        // Initialize
        initializeVisualization();

        // Event listeners
        startBtn.addEventListener("click", function () {
          startSimulation();
        });

        resetBtn.addEventListener("click", function () {
          clearInterval(animationInterval);
          initializeVisualization();
        });

        prevBtn.addEventListener("click", function () {
          clearInterval(animationInterval);
          if (currentStep > 0) {
            // Move back one step
            currentStep--;
            const lastHistory = history.pop();

            // Reset stats
            pageFaults = history.filter(
              (entry) => entry.status === "Fault"
            ).length;
            pageHits = history.filter((entry) => entry.status === "Hit").length;

            if (history.length > 0) {
              const lastEntry = history[history.length - 1];
              queue = [...lastEntry.queue];
              pointer = lastEntry.pointer || 0;
            } else {
              queue = [];
              pointer = 0;
            }

            // Update UI
            updateQueueDisplay();
            updateStats();
            updateHistory();
            highlightCurrentStep();
          }
        });

        nextBtn.addEventListener("click", function () {
          clearInterval(animationInterval);
          if (currentStep < referenceString.length) {
            processStep();
          }
        });

        autoBtn.addEventListener("click", function () {
          startSimulation();
        });

        frameCount.addEventListener("change", function () {
          initializeVisualization();
        });

        // Update pointer position on window resize
        window.addEventListener("resize", updatePointerPosition);
      });
    </script>
</body>
</html>
