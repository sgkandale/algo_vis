<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LogLog Algorithm Visualization</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      }

      h1 {
        text-align: center;
        color: #2c3e50;
        margin-bottom: 20px;
        font-size: 2.5rem;
        background: linear-gradient(45deg, #667eea, #764ba2);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .intro {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 15px;
        margin-bottom: 30px;
        border-left: 5px solid #667eea;
      }

      .algorithm-comparison {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
      }

      .algo-card {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      }

      .algo-card.loglog {
        border-top: 5px solid #e74c3c;
      }

      .algo-card.hyperloglog {
        border-top: 5px solid #27ae60;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 30px;
        flex-wrap: wrap;
      }

      .btn {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s ease;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      }

      .btn.danger {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
      }

      .btn.success {
        background: linear-gradient(45deg, #00b894, #00cec9);
      }

      .main-content {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 30px;
      }

      .input-section {
        background: white;
        border-radius: 15px;
        padding: 25px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      }

      .input-section h3 {
        color: #2c3e50;
        margin-bottom: 15px;
        font-size: 1.3rem;
      }

      input[type="text"] {
        width: 100%;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 10px;
        font-size: 1rem;
        margin-bottom: 15px;
        transition: border-color 0.3s ease;
      }

      input[type="text"]:focus {
        outline: none;
        border-color: #667eea;
      }

      .hash-display {
        background: #2c3e50;
        color: #ecf0f1;
        padding: 15px;
        border-radius: 10px;
        font-family: "Courier New", monospace;
        margin: 10px 0;
        word-break: break-all;
      }

      .buckets-section {
        background: white;
        border-radius: 15px;
        padding: 25px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      }

      .buckets-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        margin: 20px 0;
      }

      .bucket {
        background: #ecf0f1;
        border: 2px solid #bdc3c7;
        border-radius: 10px;
        padding: 15px;
        text-align: center;
        transition: all 0.3s ease;
        position: relative;
      }

      .bucket.active {
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
        border-color: #e74c3c;
        transform: scale(1.05);
        box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
      }

      .bucket-header {
        font-size: 0.8rem;
        font-weight: bold;
        margin-bottom: 5px;
        opacity: 0.7;
      }

      .bucket.active .bucket-header {
        opacity: 1;
      }

      .bucket-value {
        font-size: 1.2rem;
        font-weight: bold;
        color: #e74c3c;
      }

      .bucket.active .bucket-value {
        color: white;
      }

      .step-by-step {
        background: white;
        border-radius: 15px;
        padding: 25px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }

      .step {
        background: #f8f9fa;
        border-left: 4px solid #e74c3c;
        padding: 15px;
        margin: 10px 0;
        border-radius: 0 10px 10px 0;
      }

      .step.highlight {
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
        animation: pulse 1s ease;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.02);
        }
        100% {
          transform: scale(1);
        }
      }

      .binary-display {
        font-family: "Courier New", monospace;
        background: #2c3e50;
        color: #ecf0f1;
        padding: 10px;
        border-radius: 5px;
        margin: 5px 0;
        word-spacing: 4px;
      }

      .highlight-bits {
        background: #e74c3c;
        color: white;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .leading-zeros {
        background: #f39c12;
        color: white;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 30px;
      }

      .stat-card {
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
        padding: 20px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
      }

      .stat-value {
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 5px;
      }

      .stat-label {
        font-size: 0.9rem;
        opacity: 0.9;
      }

      .explanation {
        background: linear-gradient(135deg, #ffeaa7, #fab1a0);
        padding: 20px;
        border-radius: 15px;
        margin: 20px 0;
      }

      .explanation h4 {
        color: #2c3e50;
        margin-bottom: 10px;
      }

      .formula {
        background: #2c3e50;
        color: #ecf0f1;
        padding: 15px;
        border-radius: 10px;
        font-family: "Courier New", monospace;
        text-align: center;
        margin: 15px 0;
        font-size: 1.1rem;
      }

      .dataset-examples {
        display: flex;
        gap: 10px;
        margin: 15px 0;
        flex-wrap: wrap;
      }

      .dataset-btn {
        background: #e74c3c;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 20px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: transform 0.2s ease;
      }

      .dataset-btn:hover {
        transform: translateY(-2px);
        background: #c0392b;
      }

      .max-tracker {
        background: linear-gradient(135deg, #f39c12, #e67e22);
        color: white;
        padding: 20px;
        border-radius: 15px;
        margin: 20px 0;
        text-align: center;
      }

      .max-value {
        font-size: 3rem;
        font-weight: bold;
        margin: 10px 0;
      }

      .elements-processed {
        background: #ecf0f1;
        border-radius: 10px;
        padding: 15px;
        margin: 15px 0;
        max-height: 200px;
        overflow-y: auto;
      }

      .element-entry {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        border-bottom: 1px solid #bdc3c7;
      }

      .element-entry:last-child {
        border-bottom: none;
      }

      @media (max-width: 768px) {
        .main-content,
        .algorithm-comparison {
          grid-template-columns: 1fr;
        }

        .buckets-grid {
          grid-template-columns: repeat(2, 1fr);
        }

        h1 {
          font-size: 2rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üìä LogLog Algorithm</h1>

      <div class="intro">
        <p>
          <strong>LogLog</strong> is the simpler predecessor to HyperLogLog that
          estimates cardinality by tracking the maximum number of leading zeros
          in hash values. It's the foundation that led to the more advanced
          HyperLogLog algorithm!
        </p>
      </div>

      <div class="algorithm-comparison">
        <div class="algo-card loglog">
          <h3>üî¥ LogLog (This Demo)</h3>
          <p>
            <strong>Method:</strong> Use maximum leading zeros across ALL
            elements
          </p>
          <p><strong>Buckets:</strong> Optional for better accuracy</p>
          <p><strong>Estimation:</strong> 2^(max_zeros) √ó constant</p>
          <p><strong>Accuracy:</strong> ~20% error (good for its simplicity)</p>
        </div>
        <div class="algo-card hyperloglog">
          <h3>üü¢ HyperLogLog (Advanced)</h3>
          <p><strong>Method:</strong> Harmonic mean of bucket maximums</p>
          <p><strong>Buckets:</strong> Always uses multiple buckets</p>
          <p><strong>Estimation:</strong> Complex harmonic mean formula</p>
          <p><strong>Accuracy:</strong> ~2% error (much more accurate)</p>
        </div>
      </div>

      <div class="controls">
        <button class="btn success" onclick="addElement()">
          ‚ûï Add Element
        </button>
        <button class="btn" onclick="addRandomElement()">üé≤ Add Random</button>
        <button class="btn danger" onclick="reset()">üîÑ Reset</button>
        <button class="btn" onclick="showComparison()">
          ‚öñÔ∏è vs HyperLogLog
        </button>
      </div>

      <div class="dataset-examples">
        <button
          class="dataset-btn"
          onclick="loadDataset(['apple', 'banana', 'cherry', 'date', 'elderberry'])"
        >
          üçé Fruits
        </button>
        <button
          class="dataset-btn"
          onclick="loadDataset(['user123', 'user456', 'user789', 'user101', 'user202'])"
        >
          üë• Users
        </button>
        <button
          class="dataset-btn"
          onclick="loadDataset(['192.168.1.1', '10.0.0.1', '172.16.0.1', '8.8.8.8'])"
        >
          üåê IPs
        </button>
        <button class="dataset-btn" onclick="generateLargeDataset()">
          üìà Large Dataset (1000 items)
        </button>
      </div>

      <div class="max-tracker">
        <h3>üéØ Maximum Leading Zeros Found</h3>
        <div class="max-value" id="maxZeros">0</div>
        <p>This is the key value LogLog uses for estimation!</p>
      </div>

      <div class="main-content">
        <div class="input-section">
          <h3>üî§ Add New Element</h3>
          <input
            type="text"
            id="elementInput"
            placeholder="Enter any string (e.g., user123, apple, 192.168.1.1)"
            onkeypress="handleKeyPress(event)"
          />

          <div id="currentElement" style="display: none">
            <h4>Current Element Processing:</h4>
            <div class="hash-display" id="elementHash"></div>
            <div class="binary-display" id="binaryHash"></div>
          </div>

          <div class="elements-processed">
            <h4>Elements Processed:</h4>
            <div id="elementsList"></div>
          </div>
        </div>

        <div class="buckets-section">
          <h3>ü™£ LogLog Buckets (Optional Enhancement)</h3>
          <p style="font-size: 0.9rem; color: #7f8c8d; margin-bottom: 15px">
            Basic LogLog uses one value, but buckets improve accuracy
          </p>
          <div class="buckets-grid" id="bucketsGrid"></div>
        </div>
      </div>

      <div class="step-by-step">
        <h3>üîç Step-by-Step LogLog Process</h3>
        <div id="steps">
          <div class="explanation">
            <h4>How LogLog Works (Simplified):</h4>
            <p><strong>1. Hash:</strong> Convert each element to binary hash</p>
            <p>
              <strong>2. Count Zeros:</strong> Count leading zeros in the hash
            </p>
            <p>
              <strong>3. Track Maximum:</strong> Keep the highest zero count
              seen
            </p>
            <p><strong>4. Estimate:</strong> Cardinality ‚âà 2^(max_zeros) √ó œÜ</p>
            <br />
            <p>
              <em
                >The insight: If you see k leading zeros, there are likely ~2^k
                unique elements</em
              >
            </p>
          </div>
        </div>
      </div>

      <div class="stats">
        <div class="stat-card">
          <div class="stat-value" id="actualCount">0</div>
          <div class="stat-label">Actual Unique Count</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="basicEstimate">0</div>
          <div class="stat-label">Basic LogLog Estimate</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="bucketEstimate">0</div>
          <div class="stat-label">Bucket-Enhanced Estimate</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="errorRate">0%</div>
          <div class="stat-label">Basic LogLog Error</div>
        </div>
      </div>

      <div class="explanation">
        <h4>üßÆ LogLog Estimation Formulas:</h4>
        <div class="formula">
          Basic: Cardinality ‚âà 2^(L_max) √ó œÜ
          <br /><small>where L_max = maximum leading zeros, œÜ ‚âà 0.77351</small>
        </div>
        <div class="formula">
          With Buckets: Average the estimates from each bucket
          <br /><small>Reduces variance and improves accuracy</small>
        </div>
      </div>

      <div class="explanation">
        <h4>üéØ Key Insight:</h4>
        <p>
          LogLog exploits a simple probability fact: if you flip a coin and get
          k heads in a row, you probably flipped about 2^k times total.
          Similarly, k leading zeros in a hash suggests about 2^k unique
          elements!
        </p>
      </div>
    </div>

    <script>
      // LogLog implementation
      const b = 4; // bucket bits for enhanced version
      const m = 16; // number of buckets
      const phi = 0.77351; // LogLog bias correction constant

      let maxLeadingZeros = 0;
      let buckets = new Array(m).fill(0);
      let uniqueElements = new Set();
      let processedElements = [];

      // Simple hash function (for demonstration)
      function simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash; // Convert to 32-bit integer
        }
        return Math.abs(hash);
      }

      function toBinary(num, bits = 32) {
        return num.toString(2).padStart(bits, "0");
      }

      function countLeadingZeros(binaryStr) {
        let count = 0;
        for (let i = 0; i < binaryStr.length; i++) {
          if (binaryStr[i] === "0") {
            count++;
          } else {
            break;
          }
        }
        return count;
      }

      function addElementToLogLog(element) {
        // Hash the element
        const hash = simpleHash(element);
        const binaryHash = toBinary(hash, 32);

        // Count leading zeros in the full hash for basic LogLog
        const leadingZeros = countLeadingZeros(binaryHash);

        // Update maximum for basic LogLog
        maxLeadingZeros = Math.max(maxLeadingZeros, leadingZeros);

        // For bucket-enhanced version
        const bucketIndex = parseInt(binaryHash.substring(0, b), 2);
        const remainingBits = binaryHash.substring(b);
        const bucketLeadingZeros = countLeadingZeros(remainingBits);
        buckets[bucketIndex] = Math.max(
          buckets[bucketIndex],
          bucketLeadingZeros
        );

        // Track processed elements
        processedElements.push({
          element: element,
          hash: hash,
          leadingZeros: leadingZeros,
          bucketIndex: bucketIndex,
        });

        // Show the process
        showProcessing(element, hash, binaryHash, leadingZeros, bucketIndex);

        // Update display
        updateDisplay();
      }

      function showProcessing(
        element,
        hash,
        binaryHash,
        leadingZeros,
        bucketIndex
      ) {
        const elementHashDiv = document.getElementById("elementHash");
        const binaryHashDiv = document.getElementById("binaryHash");
        const currentElementDiv = document.getElementById("currentElement");

        elementHashDiv.innerHTML = `"${element}" ‚Üí Hash: ${hash}`;

        // Highlight leading zeros
        let highlightedBinary = "";
        let zeroCount = 0;
        for (let i = 0; i < binaryHash.length; i++) {
          if (binaryHash[i] === "0" && zeroCount === i) {
            highlightedBinary += `<span class="leading-zeros">${binaryHash[i]}</span>`;
            zeroCount++;
          } else {
            highlightedBinary += binaryHash[i];
            break;
          }
        }
        highlightedBinary += binaryHash.substring(zeroCount);

        const bucketBits = binaryHash.substring(0, b);
        const remainingBits = binaryHash.substring(b);

        binaryHashDiv.innerHTML = `
                ${highlightedBinary}
                <br><small>Leading zeros: ${leadingZeros} | Bucket: ${bucketIndex}</small>
                <br><small><span class="highlight-bits">${bucketBits}</span>${remainingBits}</small>
            `;

        currentElementDiv.style.display = "block";

        // Highlight the active bucket
        document.querySelectorAll(".bucket").forEach((bucket, index) => {
          bucket.classList.remove("active");
          if (index === bucketIndex) {
            bucket.classList.add("active");
            setTimeout(() => bucket.classList.remove("active"), 2000);
          }
        });

        // Show step-by-step
        showSteps(element, leadingZeros, bucketIndex);
      }

      function showSteps(element, leadingZeros, bucketIndex) {
        const stepsDiv = document.getElementById("steps");
        const wasMaxUpdated = leadingZeros >= maxLeadingZeros;

        stepsDiv.innerHTML = `
                <div class="step highlight">
                    <strong>Step 1:</strong> Hash "${element}" ‚Üí ${simpleHash(
          element
        )}
                </div>
                <div class="step highlight">
                    <strong>Step 2:</strong> Count leading zeros: ${leadingZeros}
                </div>
                <div class="step ${wasMaxUpdated ? "highlight" : ""}">
                    <strong>Step 3:</strong> Max zeros: ${maxLeadingZeros} ${
          wasMaxUpdated ? "(UPDATED!)" : "(unchanged)"
        }
                </div>
                <div class="step highlight">
                    <strong>Step 4:</strong> Current estimate: ~${Math.round(
                      Math.pow(2, maxLeadingZeros) * phi
                    )} unique elements
                </div>
            `;
      }

      function estimateBasicLogLog() {
        return Math.round(Math.pow(2, maxLeadingZeros) * phi);
      }

      function estimateBucketLogLog() {
        if (buckets.every((b) => b === 0)) return 0;

        let sum = 0;
        let activeBuckets = 0;
        for (let i = 0; i < m; i++) {
          if (buckets[i] > 0) {
            sum += Math.pow(2, buckets[i]) * phi;
            activeBuckets++;
          }
        }
        return activeBuckets > 0 ? Math.round(sum / activeBuckets) : 0;
      }

      function updateDisplay() {
        // Update max zeros display
        document.getElementById("maxZeros").textContent = maxLeadingZeros;

        // Update buckets display
        const bucketsGrid = document.getElementById("bucketsGrid");
        bucketsGrid.innerHTML = "";

        for (let i = 0; i < m; i++) {
          const bucket = document.createElement("div");
          bucket.className = "bucket";
          bucket.innerHTML = `
                    <div class="bucket-header">Bucket ${i}</div>
                    <div class="bucket-value">${buckets[i]}</div>
                `;
          bucketsGrid.appendChild(bucket);
        }

        // Update elements list
        const elementsList = document.getElementById("elementsList");
        elementsList.innerHTML = processedElements
          .slice(-10)
          .map(
            (item) => `
                <div class="element-entry">
                    <span>${item.element}</span>
                    <span>${item.leadingZeros} zeros</span>
                </div>
            `
          )
          .join("");

        // Update statistics
        const actualCount = uniqueElements.size;
        const basicEstimate = estimateBasicLogLog();
        const bucketEstimate = estimateBucketLogLog();
        const errorRate =
          actualCount > 0
            ? Math.abs(
                ((basicEstimate - actualCount) / actualCount) * 100
              ).toFixed(1)
            : 0;

        document.getElementById("actualCount").textContent = actualCount;
        document.getElementById("basicEstimate").textContent = basicEstimate;
        document.getElementById("bucketEstimate").textContent = bucketEstimate;
        document.getElementById("errorRate").textContent = errorRate + "%";
      }

      function addElement() {
        const input = document.getElementById("elementInput");
        const element = input.value.trim();

        if (element) {
          uniqueElements.add(element);
          addElementToLogLog(element);
          input.value = "";
        }
      }

      function addRandomElement() {
        const randomElements = [
          "user" + Math.floor(Math.random() * 1000),
          "item" + Math.floor(Math.random() * 1000),
          "session" + Math.floor(Math.random() * 1000),
          "page" + Math.floor(Math.random() * 100),
          "product" + Math.floor(Math.random() * 500),
        ];

        const element =
          randomElements[Math.floor(Math.random() * randomElements.length)];
        uniqueElements.add(element);
        addElementToLogLog(element);
      }

      function reset() {
        maxLeadingZeros = 0;
        buckets = new Array(m).fill(0);
        uniqueElements.clear();
        processedElements = [];
        document.getElementById("currentElement").style.display = "none";
        document.getElementById("steps").innerHTML = `
                <div class="explanation">
                    <h4>How LogLog Works (Simplified):</h4>
                    <p><strong>1. Hash:</strong> Convert each element to binary hash</p>
                    <p><strong>2. Count Zeros:</strong> Count leading zeros in the hash</p>
                    <p><strong>3. Track Maximum:</strong> Keep the highest zero count seen</p>
                    <p><strong>4. Estimate:</strong> Cardinality ‚âà 2^(max_zeros) √ó œÜ</p>
                    <br>
                    <p><em>The insight: If you see k leading zeros, there are likely ~2^k unique elements</em></p>
                </div>
            `;
        updateDisplay();
      }

      function loadDataset(elements) {
        reset();
        elements.forEach((element, index) => {
          setTimeout(() => {
            uniqueElements.add(element);
            addElementToLogLog(element);
          }, index * 800);
        });
      }

      function generateLargeDataset() {
        reset();
        const batchSize = 50;
        let processed = 0;

        const processBatch = () => {
          for (let i = 0; i < batchSize && processed < 1000; i++) {
            const element = "item" + Math.floor(Math.random() * 800);
            uniqueElements.add(element);

            // Process without detailed visualization for performance
            const hash = simpleHash(element);
            const binaryHash = toBinary(hash, 32);
            const leadingZeros = countLeadingZeros(binaryHash);
            maxLeadingZeros = Math.max(maxLeadingZeros, leadingZeros);

            const bucketIndex = parseInt(binaryHash.substring(0, b), 2);
            const remainingBits = binaryHash.substring(b);
            const bucketLeadingZeros = countLeadingZeros(remainingBits);
            buckets[bucketIndex] = Math.max(
              buckets[bucketIndex],
              bucketLeadingZeros
            );

            processed++;
          }

          updateDisplay();

          if (processed < 1000) {
            setTimeout(processBatch, 50);
          }
        };

        processBatch();
      }

      function showComparison() {
        alert(`LogLog vs HyperLogLog Comparison ü•ä

LogLog (1984):
‚úÖ Simple and intuitive
‚úÖ Easy to understand and implement  
‚úÖ Foundation for better algorithms
‚ùå ~20% error rate (high variance)
‚ùå Single point of failure (one max value)

HyperLogLog (2007):
‚úÖ Much better accuracy (~2% error)
‚úÖ Uses harmonic mean (reduces variance)
‚úÖ Industry standard for big data
‚ùå More complex mathematics
‚ùå Harder to understand intuitively

LogLog was the breakthrough that showed leading zeros could estimate cardinality. HyperLogLog improved it by using multiple buckets and harmonic mean instead of arithmetic mean.`);
      }

      function handleKeyPress(event) {
        if (event.key === "Enter") {
          addElement();
        }
      }

      // Initialize display
      updateDisplay();

      // Auto-focus input
      document.getElementById("elementInput").focus();
    </script>
  </body>
</html>
