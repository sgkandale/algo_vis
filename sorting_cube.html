<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cubesort | AlgoViz Hub</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary: #0f172a;
        --secondary: #1e293b;
        --accent: #6366f1;
        --accent-light: #818cf8;
        --accent-glow: rgba(99, 102, 241, 0.2);
        --text: #e2e8f0;
        --text-secondary: #94a3b8;
        --card-bg: rgba(30, 41, 59, 0.7);
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --transition: all 0.3s ease;
        --radius: 12px;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        --glow: 0 0 15px var(--accent-glow);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: var(--text);
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        min-height: 100vh;
        padding: 0;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 10% 20%,
            rgba(99, 102, 241, 0.1) 0%,
            transparent 20%
          ),
          radial-gradient(
            circle at 90% 80%,
            rgba(129, 140, 248, 0.1) 0%,
            transparent 20%
          );
        z-index: -1;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      /* Header Styles */
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 0;
        position: relative;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .logo-icon {
        width: 50px;
        height: 50px;
        background: var(--accent);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--glow);
      }

      .logo-icon i {
        font-size: 24px;
        color: white;
      }

      .logo-text h1 {
        font-family: "Roboto Mono", monospace;
        font-weight: 700;
        font-size: 28px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .logo-text p {
        font-size: 14px;
        color: var(--text-secondary);
        letter-spacing: 1.5px;
      }

      .breadcrumb {
        font-size: 14px;
        color: var(--text-secondary);
        margin-top: 10px;
      }

      .breadcrumb a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .breadcrumb a:hover {
        text-decoration: underline;
      }

      /* Algorithm Header */
      .algorithm-header {
        margin: 40px 0;
        text-align: center;
        padding: 20px;
        background: var(--card-bg);
        border-radius: var(--radius);
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .algorithm-header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .algorithm-header h1 {
        font-size: 42px;
        margin-bottom: 15px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 800;
      }

      .algorithm-header .category {
        font-size: 18px;
        color: var(--accent-light);
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .complexity-badge {
        display: inline-block;
        background: rgba(129, 140, 248, 0.2);
        color: var(--accent-light);
        padding: 6px 15px;
        border-radius: 20px;
        font-size: 16px;
        font-weight: 600;
        font-family: "Roboto Mono", monospace;
        margin-top: 15px;
      }

      /* Main Content Layout */
      .main-content {
        display: grid;
        grid-template-columns: 1fr 350px;
        gap: 30px;
        margin-bottom: 40px;
      }

      @media (max-width: 900px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }

      /* Algorithm Detail Sections */
      .section {
        background: var(--card-bg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 30px;
        margin-bottom: 30px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .section::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .section h2 {
        font-size: 26px;
        margin-bottom: 20px;
        color: var(--accent-light);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .section h2 i {
        color: var(--accent);
        width: 36px;
        height: 36px;
        background: rgba(99, 102, 241, 0.2);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .section p {
        color: var(--text-secondary);
        font-size: 17px;
        line-height: 1.8;
        margin-bottom: 20px;
      }

      .key-points {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin: 25px 0;
      }

      .point-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
      }

      .point-card h3 {
        color: var(--accent-light);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .point-card h3 i {
        color: var(--accent);
      }

      .point-card p {
        margin-bottom: 0;
        font-size: 15px;
      }

      /* Visualization Console */
      .visualization-console {
        background: rgba(15, 23, 42, 0.8);
        border-radius: var(--radius);
        padding: 25px;
        margin: 30px 0;
        border: 1px solid rgba(99, 102, 241, 0.3);
        box-shadow: var(--glow);
      }

      .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .console-header h3 {
        color: var(--accent-light);
        font-size: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .console-controls {
        display: flex;
        gap: 10px;
      }

      .console-btn {
        background: var(--accent);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .console-btn:hover {
        background: var(--accent-light);
      }

      .console-btn.secondary {
        background: rgba(148, 163, 184, 0.2);
      }

      .visualization-area {
        height: 300px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      .console-input {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      .console-input input {
        flex: 1;
        padding: 12px 15px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 5px;
        color: var(--text);
        font-family: "Roboto Mono", monospace;
      }

      .console-input input:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Algorithm Properties */
      .properties-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .property-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        text-align: center;
      }

      .property-card h4 {
        color: var(--text-secondary);
        font-size: 14px;
        margin-bottom: 8px;
        font-weight: 400;
      }

      .property-card .value {
        font-size: 20px;
        font-weight: 700;
        color: var(--accent-light);
        font-family: "Roboto Mono", monospace;
      }

      /* Footer */
      footer {
        text-align: center;
        padding: 40px 0 30px;
        color: var(--text-secondary);
        font-size: 14px;
        border-top: 1px solid rgba(148, 163, 184, 0.1);
        margin-top: 40px;
      }

      footer p {
        margin: 10px 0;
      }

      .footer-links {
        display: flex;
        justify-content: center;
        gap: 25px;
        margin-top: 15px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .footer-links a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .footer-links a:hover {
        color: var(--accent);
      }

      /* Animations */
      @keyframes float {
        0% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
        100% {
          transform: translateY(0px);
        }
      }

      .floating {
        animation: float 6s ease-in-out infinite;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        header {
          flex-direction: column;
          gap: 25px;
          text-align: center;
        }

        .algorithm-header h1 {
          font-size: 32px;
        }

        .key-points {
          grid-template-columns: 1fr;
        }
      }

      /* Code Block Styling */
      .code-block {
        background: #0d1117;
        border-radius: 8px;
        padding: 20px;
        margin: 25px 0;
        overflow-x: auto;
        font-family: "Roboto Mono", monospace;
        font-size: 15px;
        border: 1px solid rgba(99, 102, 241, 0.3);
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        color: var(--text-secondary);
      }

      .copy-btn {
        background: rgba(99, 102, 241, 0.2);
        color: var(--accent-light);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-block pre {
        margin: 0;
      }

      .code-block code {
        color: #c9d1d9;
        line-height: 1.5;
      }

      .keyword {
        color: #ff7b72;
      }
      .function {
        color: #d2a8ff;
      }
      .comment {
        color: #8b949e;
      }
      .string {
        color: #a5d6ff;
      }
      .number {
        color: #79c0ff;
      }

      /* Cubesort Visualization Styles */
      .visualization-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
        padding: 10px;
      }

      .cubes-container {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        justify-content: center;
        height: 70%;
        margin-bottom: 10px;
        overflow-y: auto;
      }

      .cube {
        width: 100px;
        height: 100px;
        background: rgba(30, 41, 59, 0.5);
        border: 2px solid var(--accent);
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 5px;
        position: relative;
      }

      .cube-label {
        position: absolute;
        top: -20px;
        background: var(--secondary);
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 12px;
        color: var(--accent-light);
      }

      .cube-element {
        width: 25px;
        height: 25px;
        background: linear-gradient(135deg, var(--accent), var(--accent-light));
        border-radius: 4px;
        margin: 2px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Roboto Mono", monospace;
        font-size: 12px;
        font-weight: 700;
        color: white;
      }

      .sorted-list {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 30%;
        padding: 10px;
        background: rgba(30, 41, 59, 0.5);
        border-radius: 8px;
        border: 1px solid var(--success);
      }

      .sorted-item {
        width: 40px;
        height: 30px;
        background: var(--success);
        border-radius: 6px;
        margin: 0 3px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Roboto Mono", monospace;
        font-weight: 700;
        font-size: 14px;
        color: white;
      }

      .status-bar {
        margin-top: 15px;
        font-family: "Roboto Mono", monospace;
        color: var(--accent-light);
        text-align: center;
        min-height: 40px;
        padding: 10px;
        background: rgba(15, 23, 42, 0.5);
        border-radius: 5px;
      }

      .highlighted {
        box-shadow: 0 0 10px var(--warning);
        transform: scale(1.05);
        z-index: 10;
        transition: all 0.3s ease;
      }

      .sorted {
        background: var(--success);
      }

      .merging {
        background: var(--warning);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <header>
        <div class="logo">
          <div class="logo-icon floating">
            <i class="fas fa-cube"></i>
          </div>
          <div class="logo-text">
            <h1>AlgoViz Hub</h1>
            <p>ALGORITHM VISUALIZATION REPOSITORY</p>
            <div class="breadcrumb">
              <a href="#"><i class="fas fa-home"></i> Home</a> >
              <a href="#">Sorting Algorithms</a> >
              <span>Cubesort</span>
            </div>
          </div>
        </div>
      </header>

      <!-- Algorithm Header -->
      <div class="algorithm-header">
        <h1>Cubesort</h1>
        <div class="category">
          <i class="fas fa-sort-amount-down"></i> Parallel Sorting Algorithm
        </div>
        <div class="complexity-badge">Time Complexity: O(n log n)</div>
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <!-- Left Column: Algorithm Details -->
        <div class="left-column">
          <!-- Description Section -->
          <div class="section">
            <h2><i class="fas fa-file-alt"></i> Algorithm Overview</h2>
            <p>
              Cubesort is a parallel sorting algorithm that divides the input
              data into smaller "cubes" (sub-arrays), sorts each cube
              independently (often in parallel), and then merges the sorted
              cubes into a final sorted array. It's particularly efficient in
              distributed systems and parallel computing environments.
            </p>
            <p>
              The algorithm leverages the divide-and-conquer paradigm and is
              well-suited for modern multi-core processors. By sorting cubes in
              parallel and then merging the results, Cubesort can achieve
              significant performance improvements over traditional sequential
              algorithms.
            </p>

            <div class="key-points">
              <div class="point-card">
                <h3><i class="fas fa-cube"></i> Key Feature</h3>
                <p>Parallel processing of data cubes for efficient sorting</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-bolt"></i> Performance</h3>
                <p>O(n log n) worst-case, efficient in parallel environments</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-memory"></i> Space</h3>
                <p>O(n) - requires space for cubes and merging</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-project-diagram"></i> Applications</h3>
                <p>Distributed systems, GPU computing, big data processing</p>
              </div>
            </div>
          </div>

          <!-- Visualization Console -->
          <div class="section">
            <h2>
              <i class="fas fa-laptop-code"></i> Interactive Visualization
            </h2>
            <p>
              Use the interactive console below to visualize how Cubesort works.
              Enter comma-separated numbers and step through the algorithm to
              see how elements are divided into cubes, sorted, and then merged.
            </p>

            <div class="visualization-console">
              <div class="console-header">
                <h3>
                  <i class="fas fa-play-circle"></i> Cubesort Visualization
                </h3>
                <div class="console-controls">
                  <button id="step-btn" class="console-btn secondary">
                    <i class="fas fa-step-forward"></i> Step
                  </button>
                  <button id="run-btn" class="console-btn">
                    <i class="fas fa-play"></i> Run
                  </button>
                  <button id="reset-btn" class="console-btn secondary">
                    <i class="fas fa-redo"></i> Reset
                  </button>
                </div>
              </div>

              <div class="visualization-area">
                <div
                  class="visualization-container"
                  id="visualization-container"
                >
                  <div class="cubes-container" id="cubes-container">
                    <!-- Cubes will be generated here -->
                  </div>
                  <div class="sorted-list" id="sorted-list">
                    <span>Sorted Array: </span>
                    <!-- Sorted items will appear here -->
                  </div>
                </div>
              </div>

              <div class="console-input">
                <input
                  id="array-input"
                  type="text"
                  placeholder="Enter numbers (e.g., 5, 3, 8, 1, 2, 7, 4, 6)"
                  value="7, 3, 5, 1, 9, 4, 8, 2, 6"
                />
                <button id="random-btn" class="console-btn">
                  <i class="fas fa-random"></i> Random
                </button>
              </div>

              <div id="status" class="status-bar">
                Enter numbers and click Run or Step
              </div>
            </div>
          </div>

          <!-- Algorithm Steps -->
          <div class="section">
            <h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
            <p>Cubesort processes the array in three distinct phases:</p>

            <div class="key-points">
              <div class="point-card">
                <h3><i class="fas fa-dice"></i> 1. Cube Creation</h3>
                <p>
                  Divide the input array into smaller cubes (sub-arrays) based
                  on cube size
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-sort"></i> 2. Cube Sorting</h3>
                <p>Sort each cube independently (can be done in parallel)</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-merge"></i> 3. Cube Merging</h3>
                <p>Merge the sorted cubes using a k-way merge algorithm</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-sync-alt"></i> 4. Parallel Processing</h3>
                <p>In parallel systems, cubes are sorted simultaneously</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-check-circle"></i> 5. Final Output</h3>
                <p>The merged result forms the final sorted array</p>
              </div>
            </div>
          </div>

          <!-- Pseudocode Section -->
          <div class="section">
            <h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
            <div class="code-block">
              <pre><code>function cubesort(arr, cube_size):
    n = length(arr)
    cubes = []
    
    // Phase 1: Create cubes
    for i from 0 to n-1 step cube_size:
        cube = arr[i : min(i+cube_size, n)]
        cubes.append(cube)
    
    // Phase 2: Sort cubes (in parallel)
    for each cube in cubes:
        sort(cube)  // Using any sorting algorithm
    
    // Phase 3: Merge cubes
    while number of cubes > 1:
        new_cubes = []
        for i from 0 to len(cubes)-1 step 2:
            if i+1 < len(cubes):
                merged = merge(cubes[i], cubes[i+1])
                new_cubes.append(merged)
            else:
                new_cubes.append(cubes[i])
        cubes = new_cubes
    
    return cubes[0]  // Final sorted array

function merge(cube1, cube2):
    result = []
    i = 0, j = 0
    while i < len(cube1) and j < len(cube2):
        if cube1[i] <= cube2[j]:
            result.append(cube1[i])
            i += 1
        else:
            result.append(cube2[j])
            j += 1
    
    // Append remaining elements
    result.extend(cube1[i:])
    result.extend(cube2[j:])
    return result</code></pre>
            </div>
          </div>

          <!-- Implementation Section -->
          <div class="section">
            <h2><i class="fas fa-code"></i> Implementation</h2>
            <p>
              Below is a Python implementation of Cubesort. The algorithm uses
              parallel processing capabilities when available:
            </p>

            <div class="code-block">
              <div class="code-header">
                <span>Python Implementation</span>
                <button class="copy-btn">
                  <i class="fas fa-copy"></i> Copy Code
                </button>
              </div>
              <pre><code><span class="keyword">import</span> math
<span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor

<span class="keyword">def</span> <span class="function">cubesort</span>(arr, cube_size=None):
    n = len(arr)
    <span class="keyword">if</span> n <= 1:
        <span class="keyword">return</span> arr
        
    <span class="comment"># Determine cube size if not provided</span>
    <span class="keyword">if</span> cube_size <span class="keyword">is</span> None:
        cube_size = max(1, int(math.isqrt(n)))  <span class="comment"># Square root of n</span>
    
    <span class="comment"># Create cubes</span>
    cubes = []
    <span class="keyword">for</span> i <span class="keyword">in</span> range(0, n, cube_size):
        cube = arr[i:i + cube_size]
        cubes.append(cube)
    
    <span class="comment"># Sort cubes in parallel</span>
    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> executor:
        cubes = list(executor.map(sorted, cubes))
    
    <span class="comment"># Merge cubes</span>
    <span class="keyword">while</span> len(cubes) > 1:
        new_cubes = []
        <span class="keyword">for</span> i <span class="keyword">in</span> range(0, len(cubes), 2):
            <span class="keyword">if</span> i + 1 < len(cubes):
                merged = merge(cubes[i], cubes[i + 1])
                new_cubes.append(merged)
            <span class="keyword">else</span>:
                new_cubes.append(cubes[i])
        cubes = new_cubes
    
    <span class="keyword">return</span> cubes[0]

<span class="keyword">def</span> <span class="function">merge</span>(left, right):
    result = []
    i = j = 0
    <span class="keyword">while</span> i < len(left) <span class="keyword">and</span> j < len(right):
        <span class="keyword">if</span> left[i] <= right[j]:
            result.append(left[i])
            i += 1
        <span class="keyword">else</span>:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    <span class="keyword">return</span> result

<span class="comment"># Example usage</span>
arr = [7, 3, 5, 1, 9, 4, 8, 2, 6]
sorted_arr = cubesort(arr.copy())
print(<span class="string">"Original array:"</span>, arr)
print(<span class="string">"Sorted array:"</span>, sorted_arr)</code></pre>
            </div>
          </div>
        </div>

        <!-- Right Column: Additional Info -->
        <div class="right-column">
          <!-- Properties Section -->
          <div class="section">
            <h2><i class="fas fa-info-circle"></i> Algorithm Properties</h2>
            <div class="properties-grid">
              <div class="property-card">
                <h4>Category</h4>
                <div class="value">Sorting</div>
              </div>
              <div class="property-card">
                <h4>Type</h4>
                <div class="value">Comparison</div>
              </div>
              <div class="property-card">
                <h4>Stable</h4>
                <div class="value">Yes</div>
              </div>
              <div class="property-card">
                <h4>In-place</h4>
                <div class="value">No</div>
              </div>
              <div class="property-card">
                <h4>Best Case</h4>
                <div class="value">O(n log n)</div>
              </div>
              <div class="property-card">
                <h4>Worst Case</h4>
                <div class="value">O(n log n)</div>
              </div>
              <div class="property-card">
                <h4>Average Case</h4>
                <div class="value">O(n log n)</div>
              </div>
              <div class="property-card">
                <h4>Space</h4>
                <div class="value">O(n)</div>
              </div>
              <div class="property-card">
                <h4>Parallel</h4>
                <div class="value">Yes</div>
              </div>
            </div>
          </div>

          <!-- Applications Section -->
          <div class="section">
            <h2><i class="fas fa-lightbulb"></i> Applications</h2>
            <p>Cubesort is particularly useful in these scenarios:</p>
            <ul
              style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              "
            >
              <li style="margin-bottom: 10px">Distributed computing systems</li>
              <li style="margin-bottom: 10px">GPU-accelerated sorting</li>
              <li style="margin-bottom: 10px">
                Big data processing frameworks
              </li>
              <li style="margin-bottom: 10px">
                Multi-core processor environments
              </li>
              <li>Database management systems</li>
            </ul>
          </div>

          <!-- Performance Section -->
          <div class="section">
            <h2><i class="fas fa-tachometer-alt"></i> Performance</h2>
            <p>
              Cubesort offers significant advantages in parallel environments:
            </p>
            <div style="margin: 15px 0; color: var(--text-secondary)">
              <p><strong>Sequential Time:</strong> O(n log n)</p>
              <p>
                <strong>Parallel Time:</strong> O((n log n)/p) with p processors
              </p>
              <p><strong>Space Complexity:</strong> O(n)</p>
            </div>
            <div
              style="
                background: rgba(15, 23, 42, 0.5);
                border-radius: 8px;
                padding: 15px;
              "
            >
              <h4
                style="
                  color: var(--accent-light);
                  text-align: center;
                  margin-bottom: 10px;
                "
              >
                Parallel Speedup
              </h4>
              <div
                style="display: flex; justify-content: center; margin-top: 10px"
              >
                <div style="width: 100%; height: 150px; position: relative">
                  <div
                    style="
                      position: absolute;
                      bottom: 0;
                      width: 30px;
                      height: 30%;
                      background: var(--accent);
                      left: 10%;
                    "
                  >
                    1x
                  </div>
                  <div
                    style="
                      position: absolute;
                      bottom: 0;
                      width: 30px;
                      height: 50%;
                      background: var(--accent-light);
                      left: 30%;
                    "
                  >
                    2x
                  </div>
                  <div
                    style="
                      position: absolute;
                      bottom: 0;
                      width: 30px;
                      height: 70%;
                      background: var(--success);
                      left: 50%;
                    "
                  >
                    4x
                  </div>
                  <div
                    style="
                      position: absolute;
                      bottom: 0;
                      width: 30px;
                      height: 90%;
                      background: var(--warning);
                      left: 70%;
                    "
                  >
                    8x
                  </div>
                  <div
                    style="
                      position: absolute;
                      bottom: -25px;
                      width: 100%;
                      text-align: center;
                    "
                  >
                    Number of Processors
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Footer -->
      <footer>
        <div class="footer-links">
          <a href="#"><i class="fas fa-book"></i> Documentation</a>
          <a href="#"><i class="fas fa-code-branch"></i> Contribute</a>
          <a href="#"><i class="fas fa-chalkboard-teacher"></i> Tutorials</a>
          <a href="#"><i class="fas fa-bug"></i> Report Issue</a>
          <a href="#"><i class="fas fa-envelope"></i> Contact</a>
        </div>
        <p>AlgoViz Hub - Interactive Algorithm Visualization Platform</p>
        <p>&copy; 2025 AlgoViz Hub. All rights reserved.</p>
      </footer>
    </div>

    <script>
      // Cubesort Visualization
      let array = [7, 3, 5, 1, 9, 4, 8, 2, 6];
      let cubes = [];
      let sortedArray = [];
      let cubeSize = 3;
      let currentStep = 0;
      let currentCube = 0;
      let isRunning = false;
      let interval;
      let mergePhase = false;
      let mergeIndex = 0;
      let mergePairs = [];
      let sorted = false;

      // DOM elements
      const cubesContainer = document.getElementById("cubes-container");
      const sortedList = document.getElementById("sorted-list");
      const arrayInput = document.getElementById("array-input");
      const runBtn = document.getElementById("run-btn");
      const stepBtn = document.getElementById("step-btn");
      const resetBtn = document.getElementById("reset-btn");
      const randomBtn = document.getElementById("random-btn");
      const status = document.getElementById("status");

      // Initialize visualization
      function initVisualization() {
        array = arrayInput.value
          .split(",")
          .map(Number)
          .filter((n) => !isNaN(n));
        if (array.length === 0) {
          array = [7, 3, 5, 1, 9, 4, 8, 2, 6];
          arrayInput.value = array.join(", ");
        }

        // Calculate cube size based on array length
        cubeSize = Math.max(2, Math.floor(Math.sqrt(array.length)));

        cubes = [];
        sortedArray = [];
        currentStep = 0;
        currentCube = 0;
        mergePhase = false;
        mergeIndex = 0;
        mergePairs = [];
        sorted = false;

        // Create initial cubes
        for (let i = 0; i < array.length; i += cubeSize) {
          const cube = array.slice(i, i + cubeSize);
          cubes.push({ data: cube, sorted: false, merging: false });
        }

        renderVisualization();
        updateStatus("Ready. Click Step or Run to start sorting.");
      }

      // Render visualization
      function renderVisualization() {
        // Clear containers
        cubesContainer.innerHTML = "";
        sortedList.innerHTML = "Sorted Array: ";

        // Render cubes
        cubes.forEach((cube, index) => {
          const cubeElement = document.createElement("div");
          cubeElement.className = "cube";
          if (cube.merging) cubeElement.classList.add("merging");

          const cubeLabel = document.createElement("div");
          cubeLabel.className = "cube-label";
          cubeLabel.textContent = `Cube ${index + 1}`;
          cubeElement.appendChild(cubeLabel);

          cube.data.forEach((value) => {
            const element = document.createElement("div");
            element.className = "cube-element";
            if (cube.sorted) element.classList.add("sorted");
            if (currentCube === index && currentStep === 1)
              element.classList.add("highlighted");
            element.textContent = value;
            cubeElement.appendChild(element);
          });

          cubesContainer.appendChild(cubeElement);
        });

        // Render sorted array
        sortedArray.forEach((value) => {
          const item = document.createElement("div");
          item.className = "sorted-item";
          item.textContent = value;
          sortedList.appendChild(item);
        });
      }

      // Update status message
      function updateStatus(message) {
        status.textContent = message;
      }

      // Perform one step of Cubesort
      function stepCubesort() {
        if (sorted) {
          updateStatus("Sorting completed! Array is fully sorted.");
          return false;
        }

        if (!mergePhase) {
          // Sorting cubes phase
          if (currentStep === 0) {
            updateStatus(
              `Divided array into ${cubes.length} cubes of size ${cubeSize}`
            );
            currentStep = 1;
          } else if (currentStep === 1) {
            if (currentCube < cubes.length) {
              cubes[currentCube].data.sort((a, b) => a - b);
              cubes[currentCube].sorted = true;
              updateStatus(
                `Sorted cube ${currentCube + 1}: [${cubes[
                  currentCube
                ].data.join(", ")}]`
              );
              currentCube++;
            } else {
              mergePhase = true;
              currentStep = 0;
              updateStatus("All cubes sorted. Starting merge phase.");
            }
          }
        } else {
          // Merge phase
          if (cubes.length === 1) {
            sortedArray = [...cubes[0].data];
            sorted = true;
            updateStatus("Sorting completed! Array is fully sorted.");
          } else {
            if (currentStep === 0) {
              // Prepare merge pairs
              mergePairs = [];
              for (let i = 0; i < cubes.length; i += 2) {
                if (i + 1 < cubes.length) {
                  mergePairs.push([i, i + 1]);
                  cubes[i].merging = true;
                  cubes[i + 1].merging = true;
                }
              }
              currentStep = 1;
              mergeIndex = 0;
              updateStatus(
                `Preparing to merge ${mergePairs.length} pairs of cubes`
              );
            } else if (currentStep === 1) {
              if (mergeIndex < mergePairs.length) {
                const [idx1, idx2] = mergePairs[mergeIndex];
                const merged = [...cubes[idx1].data, ...cubes[idx2].data].sort(
                  (a, b) => a - b
                );

                // Replace the first cube with merged result
                cubes[idx1].data = merged;
                cubes[idx1].merging = false;
                cubes[idx1].sorted = true;

                // Remove the second cube
                cubes.splice(idx2, 1);

                // Update merging flags
                cubes.forEach((cube) => (cube.merging = false));

                updateStatus(
                  `Merged cubes ${idx1 + 1} and ${
                    idx2 + 1
                  } into new cube: [${merged.join(", ")}]`
                );
                mergeIndex++;
              } else {
                // Reset for next merge pass
                mergePairs = [];
                currentStep = 0;
                updateStatus("Merge pass completed. Preparing next pass.");
              }
            }
          }
        }

        renderVisualization();
        return true;
      }

      // Event Listeners
      runBtn.addEventListener("click", function () {
        if (isRunning) {
          clearInterval(interval);
          isRunning = false;
          runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
          updateStatus("Paused. Click Run to continue.");
        } else {
          isRunning = true;
          runBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';

          interval = setInterval(() => {
            if (!stepCubesort()) {
              clearInterval(interval);
              isRunning = false;
              runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
            }
          }, 1500);
        }
      });

      stepBtn.addEventListener("click", function () {
        if (isRunning) {
          clearInterval(interval);
          isRunning = false;
          runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
        }

        stepCubesort();
      });

      resetBtn.addEventListener("click", function () {
        if (isRunning) {
          clearInterval(interval);
          isRunning = false;
          runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
        }

        initVisualization();
      });

      randomBtn.addEventListener("click", function () {
        const length = Math.floor(Math.random() * 12) + 8; // 8-19 elements
        array = [];
        for (let i = 0; i < length; i++) {
          array.push(Math.floor(Math.random() * 50) + 1);
        }
        arrayInput.value = array.join(", ");
        initVisualization();
      });

      arrayInput.addEventListener("change", initVisualization);

      // Initialize
      initVisualization();
    </script>
  </body>
</html>
