<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tree Sort | AlgoViz Hub</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;700&family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary: #0f172a;
        --secondary: #1e293b;
        --accent: #6366f1;
        --accent-light: #818cf8;
        --accent-glow: rgba(99, 102, 241, 0.2);
        --text: #e2e8f0;
        --text-secondary: #94a3b8;
        --card-bg: rgba(30, 41, 59, 0.7);
        --success: #10b981;
        --warning: #f59e0b;
        --danger: #ef4444;
        --transition: all 0.3s ease;
        --radius: 12px;
        --shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        --glow: 0 0 15px var(--accent-glow);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        color: var(--text);
        font-family: "Roboto", sans-serif;
        line-height: 1.6;
        min-height: 100vh;
        padding: 0;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 10% 20%,
            rgba(99, 102, 241, 0.1) 0%,
            transparent 20%
          ),
          radial-gradient(
            circle at 90% 80%,
            rgba(129, 140, 248, 0.1) 0%,
            transparent 20%
          );
        z-index: -1;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }

      /* Header Styles */
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 0;
        position: relative;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      }

      .logo {
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .logo-icon {
        width: 50px;
        height: 50px;
        background: var(--accent);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--glow);
      }

      .logo-icon i {
        font-size: 24px;
        color: white;
      }

      .logo-text h1 {
        font-family: "Roboto Mono", monospace;
        font-weight: 700;
        font-size: 28px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .logo-text p {
        font-size: 14px;
        color: var(--text-secondary);
        letter-spacing: 1.5px;
      }

      .breadcrumb {
        font-size: 14px;
        color: var(--text-secondary);
        margin-top: 10px;
      }

      .breadcrumb a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .breadcrumb a:hover {
        text-decoration: underline;
      }

      /* Algorithm Header */
      .algorithm-header {
        margin: 40px 0;
        text-align: center;
        padding: 20px;
        background: var(--card-bg);
        border-radius: var(--radius);
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .algorithm-header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .algorithm-header h1 {
        font-size: 42px;
        margin-bottom: 15px;
        background: linear-gradient(
          to right,
          var(--accent-light),
          var(--accent)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 800;
      }

      .algorithm-header .category {
        font-size: 18px;
        color: var(--accent-light);
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .complexity-badge {
        display: inline-block;
        background: rgba(129, 140, 248, 0.2);
        color: var(--accent-light);
        padding: 6px 15px;
        border-radius: 20px;
        font-size: 16px;
        font-weight: 600;
        font-family: "Roboto Mono", monospace;
        margin-top: 15px;
      }

      /* Main Content Layout */
      .main-content {
        display: grid;
        grid-template-columns: 1fr 350px;
        gap: 30px;
        margin-bottom: 40px;
      }

      @media (max-width: 900px) {
        .main-content {
          grid-template-columns: 1fr;
        }
      }

      /* Algorithm Detail Sections */
      .section {
        background: var(--card-bg);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 30px;
        margin-bottom: 30px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
      }

      .section::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(
          to right,
          var(--accent),
          var(--accent-light)
        );
      }

      .section h2 {
        font-size: 26px;
        margin-bottom: 20px;
        color: var(--accent-light);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .section h2 i {
        color: var(--accent);
        width: 36px;
        height: 36px;
        background: rgba(99, 102, 241, 0.2);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .section p {
        color: var(--text-secondary);
        font-size: 17px;
        line-height: 1.8;
        margin-bottom: 20px;
      }

      .key-points {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin: 25px 0;
      }

      .point-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
      }

      .point-card h3 {
        color: var(--accent-light);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .point-card h3 i {
        color: var(--accent);
      }

      .point-card p {
        margin-bottom: 0;
        font-size: 15px;
      }

      /* Visualization Console */
      .visualization-console {
        background: rgba(15, 23, 42, 0.8);
        border-radius: var(--radius);
        padding: 25px;
        margin: 30px 0;
        border: 1px solid rgba(99, 102, 241, 0.3);
        box-shadow: var(--glow);
      }

      .console-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .console-header h3 {
        color: var(--accent-light);
        font-size: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .console-controls {
        display: flex;
        gap: 10px;
      }

      .console-btn {
        background: var(--accent);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .console-btn:hover {
        background: var(--accent-light);
      }

      .console-btn.secondary {
        background: rgba(148, 163, 184, 0.2);
      }

      .visualization-area {
        height: 300px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      .visualization-area::before {
        content: "Algorithm Visualization";
        position: absolute;
        color: rgba(148, 163, 184, 0.5);
        font-size: 20px;
      }

      .console-input {
        display: flex;
        gap: 10px;
        margin-top: 20px;
      }

      .console-input input {
        flex: 1;
        padding: 12px 15px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 5px;
        color: var(--text);
        font-family: "Roboto Mono", monospace;
      }

      .console-input input:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Algorithm Properties */
      .properties-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
      }

      .property-card {
        background: rgba(15, 23, 42, 0.5);
        border-radius: var(--radius);
        padding: 20px;
        border: 1px solid rgba(148, 163, 184, 0.1);
        text-align: center;
      }

      .property-card h4 {
        color: var(--text-secondary);
        font-size: 14px;
        margin-bottom: 8px;
        font-weight: 400;
      }

      .property-card .value {
        font-size: 20px;
        font-weight: 700;
        color: var(--accent-light);
        font-family: "Roboto Mono", monospace;
      }

      /* Footer */
      footer {
        text-align: center;
        padding: 40px 0 30px;
        color: var(--text-secondary);
        font-size: 14px;
        border-top: 1px solid rgba(148, 163, 184, 0.1);
        margin-top: 40px;
      }

      footer p {
        margin: 10px 0;
      }

      .footer-links {
        display: flex;
        justify-content: center;
        gap: 25px;
        margin-top: 15px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .footer-links a {
        color: var(--accent-light);
        text-decoration: none;
        transition: var(--transition);
      }

      .footer-links a:hover {
        color: var(--accent);
      }

      /* Animations */
      @keyframes float {
        0% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
        100% {
          transform: translateY(0px);
        }
      }

      .floating {
        animation: float 6s ease-in-out infinite;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        header {
          flex-direction: column;
          gap: 25px;
          text-align: center;
        }

        .algorithm-header h1 {
          font-size: 32px;
        }

        .key-points {
          grid-template-columns: 1fr;
        }
      }

      /* Code Block Styling */
      .code-block {
        background: #0d1117;
        border-radius: 8px;
        padding: 20px;
        margin: 25px 0;
        overflow-x: auto;
        font-family: "Roboto Mono", monospace;
        font-size: 15px;
        border: 1px solid rgba(99, 102, 241, 0.3);
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        color: var(--text-secondary);
      }

      .copy-btn {
        background: rgba(99, 102, 241, 0.2);
        color: var(--accent-light);
        border: none;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-family: "Roboto Mono", monospace;
        transition: var(--transition);
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-block pre {
        margin: 0;
      }

      .code-block code {
        color: #c9d1d9;
        line-height: 1.5;
      }

      .keyword {
        color: #ff7b72;
      }
      .function {
        color: #d2a8ff;
      }
      .comment {
        color: #8b949e;
      }
      .string {
        color: #a5d6ff;
      }
      .number {
        color: #79c0ff;
      }

      /* Tree Visualization */
      .tree-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        height: 100%;
        padding: 20px;
        position: relative;
      }

      .tree-level {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        margin: 25px 0;
      }

      .tree-node {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--accent);
        color: white;
        font-weight: bold;
        margin: 0 25px;
        position: relative;
        z-index: 2;
        box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        font-family: "Roboto Mono", monospace;
        font-size: 16px;
        transition: all 0.3s ease;
      }

      .tree-node.active {
        background: var(--warning);
        box-shadow: 0 0 15px var(--warning);
        transform: scale(1.15);
      }

      .tree-node.root {
        background: var(--success);
        box-shadow: 0 0 15px var(--success);
      }

      .tree-node.visited {
        background: var(--danger);
        box-shadow: 0 0 15px var(--danger);
      }

      .tree-line {
        position: absolute;
        height: 40px;
        width: 2px;
        background: var(--accent-light);
        z-index: 1;
      }

      .tree-horizontal-line {
        position: absolute;
        height: 2px;
        background: var(--accent-light);
        z-index: 1;
      }

      .tree-output {
        display: flex;
        margin-top: 20px;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .output-item {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(16, 185, 129, 0.3);
        color: var(--success);
        font-weight: bold;
        font-family: "Roboto Mono", monospace;
        font-size: 16px;
        transition: all 0.3s ease;
      }

      .output-item.active {
        background: rgba(245, 158, 11, 0.5);
        transform: scale(1.1);
      }

      .visualization-info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.5);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 14px;
        color: var(--accent-light);
        font-family: "Roboto Mono", monospace;
      }

      .progress-bar {
        position: absolute;
        bottom: 0;
        left: 0;
        height: 5px;
        background: var(--success);
        transition: width 0.3s ease;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Header -->
      <header>
        <div class="logo">
          <div class="logo-icon floating">
            <i class="fas fa-project-diagram"></i>
          </div>
          <div class="logo-text">
            <h1>AlgoViz Hub</h1>
            <p>ALGORITHM VISUALIZATION REPOSITORY</p>
            <div class="breadcrumb">
              <a href="#"><i class="fas fa-home"></i> Home</a> >
              <a href="#">Sorting Algorithms</a> >
              <span>Tree Sort</span>
            </div>
          </div>
        </div>
      </header>

      <!-- Algorithm Header -->
      <div class="algorithm-header">
        <h1>Tree Sort</h1>
        <div class="category">
          <i class="fas fa-sort-amount-down"></i> Tree-Based Sorting
        </div>
        <div class="complexity-badge">Time Complexity: O(n log n)</div>
      </div>

      <!-- Main Content -->
      <div class="main-content">
        <!-- Left Column: Algorithm Details -->
        <div class="left-column">
          <!-- Description Section -->
          <div class="section">
            <h2><i class="fas fa-file-alt"></i> Algorithm Overview</h2>
            <p>
              Tree Sort is a sorting algorithm that builds a binary search tree
              (BST) from the elements to be sorted, and then performs an
              in-order traversal of the BST to obtain the elements in sorted
              order. This algorithm is efficient for sorting elements and
              leverages the properties of BSTs.
            </p>
            <p>
              The algorithm consists of two main phases: building the BST by
              inserting each element one by one, and then traversing the BST
              in-order to collect the elements in ascending order. Tree Sort is
              particularly useful when the data is being received one element at
              a time.
            </p>

            <div class="key-points">
              <div class="point-card">
                <h3><i class="fas fa-check-circle"></i> Key Feature</h3>
                <p>Uses binary search tree properties for efficient sorting</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-bolt"></i> Performance</h3>
                <p>
                  O(n log n) average case, O(n²) worst-case (unbalanced tree)
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-memory"></i> Space</h3>
                <p>O(n) additional space for tree nodes</p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-project-diagram"></i> Approach</h3>
                <p>BST construction + in-order traversal</p>
              </div>
            </div>
          </div>

          <!-- Visualization Console -->
          <div class="section">
            <h2>
              <i class="fas fa-laptop-code"></i> Interactive Visualization
            </h2>
            <p>
              Use the interactive console below to visualize how Tree Sort
              works. The visualization shows:
            </p>
            <ul
              style="
                color: var(--text-secondary);
                margin: 15px 0;
                padding-left: 20px;
              "
            >
              <li>
                Binary search tree construction (highlighted nodes during
                insertion)
              </li>
              <li>
                In-order traversal process (highlighted nodes during traversal)
              </li>
              <li>Sorted output being built step by step</li>
            </ul>

            <div class="visualization-console">
              <div class="console-header">
                <h3>
                  <i class="fas fa-play-circle"></i> Tree Sort Visualization
                </h3>
                <div class="console-controls">
                  <button class="console-btn secondary" id="stepBtn">
                    <i class="fas fa-step-forward"></i> Step
                  </button>
                  <button class="console-btn" id="runBtn">
                    <i class="fas fa-play"></i> Run
                  </button>
                  <button class="console-btn secondary" id="resetBtn">
                    <i class="fas fa-redo"></i> Reset
                  </button>
                </div>
              </div>

              <div class="visualization-area" id="vizArea">
                <!-- Visualization will be rendered here -->
              </div>

              <div class="console-input">
                <input
                  type="text"
                  id="arrayInput"
                  value="8, 3, 2, 7, 4, 9, 1, 6, 5"
                  placeholder="Enter numbers (e.g., 5, 3, 8, 1, 2, 7, 4, 6)"
                />
                <button class="console-btn" id="randomBtn">
                  <i class="fas fa-random"></i> Random
                </button>
              </div>
            </div>
          </div>

          <!-- Algorithm Steps -->
          <div class="section">
            <h2><i class="fas fa-list-ol"></i> Algorithm Steps</h2>
            <p>
              Tree Sort processes the array by building a BST and then
              traversing it:
            </p>

            <div class="key-points">
              <div class="point-card">
                <h3><i class="fas fa-tree"></i> 1. BST Construction</h3>
                <p>
                  Insert elements into a binary search tree: for each element,
                  start at root and recursively insert
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-code-branch"></i> 2. Insertion Logic</h3>
                <p>
                  If element < current node, go left; if > current node, go
                  right; if null, insert
                </p>
              </div>
              <div class="point-card">
                <h3><i class="fas fa-sitemap"></i> 3. In-order Traversal</h3>
                <p>
                  Traverse left subtree, visit root, traverse right subtree
                  (recursive)
                </p>
              </div>
              <div class="point-card">
                <h3>
                  <i class="fas fa-sort-amount-down"></i> 4. Collect Elements
                </h3>
                <p>
                  During in-order traversal, collect elements in sorted order
                </p>
              </div>
            </div>
          </div>

          <!-- Pseudocode Section -->
          <div class="section">
            <h2><i class="fas fa-list-ol"></i> Pseudocode</h2>
            <div class="code-block">
              <pre><code>class TreeNode:
    value
    left
    right

function insertNode(root, value):
    if root is null:
        return new TreeNode(value)
    else if value < root.value:
        root.left = insertNode(root.left, value)
    else:
        root.right = insertNode(root.right, value)
    return root

function inOrderTraversal(root, result):
    if root is not null:
        inOrderTraversal(root.left, result)
        result.append(root.value)
        inOrderTraversal(root.right, result)

function treeSort(array):
    root = null
    for each value in array:
        root = insertNode(root, value)
    result = []
    inOrderTraversal(root, result)
    return result</code></pre>
            </div>
          </div>

          <!-- Implementation Section -->
          <div class="section">
            <h2><i class="fas fa-code"></i> Implementation</h2>
            <p>
              Below is a Python implementation of the Tree Sort algorithm. The
              implementation includes a TreeNode class and the treeSort
              function.
            </p>

            <div class="code-block">
              <div class="code-header">
                <span>Python Implementation</span>
                <button class="copy-btn">
                  <i class="fas fa-copy"></i> Copy Code
                </button>
              </div>
              <pre><code><span class="keyword">class</span> <span class="function">TreeNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, value):
        <span class="keyword">self</span>.value = value
        <span class="keyword">self</span>.left = <span class="keyword">None</span>
        <span class="keyword">self</span>.right = <span class="keyword">None</span>

<span class="keyword">def</span> <span class="function">insert_node</span>(root, value):
    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:
        <span class="keyword">return</span> TreeNode(value)
    
    <span class="keyword">if</span> value < root.value:
        root.left = insert_node(root.left, value)
    <span class="keyword">else</span>:
        root.right = insert_node(root.right, value)
        
    <span class="keyword">return</span> root

<span class="keyword">def</span> <span class="function">in_order_traversal</span>(root, result):
    <span class="keyword">if</span> root:
        in_order_traversal(root.left, result)
        result.append(root.value)
        in_order_traversal(root.right, result)

<span class="keyword">def</span> <span class="function">tree_sort</span>(arr):
    <span class="keyword">if</span> <span class="keyword">not</span> arr:
        <span class="keyword">return</span> arr
        
    root = <span class="keyword">None</span>
    <span class="keyword">for</span> value <span class="keyword">in</span> arr:
        root = insert_node(root, value)
        
    result = []
    in_order_traversal(root, result)
    <span class="keyword">return</span> result

<span class="comment"># Example usage</span>
arr = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>]
sorted_arr = tree_sort(arr)
print(<span class="string">"Sorted array:"</span>, sorted_arr)</code></pre>
            </div>
          </div>
        </div>

        <!-- Right Column: Additional Info -->
        <div class="right-column">
          <!-- Properties Section -->
          <div class="section">
            <h2><i class="fas fa-info-circle"></i> Algorithm Properties</h2>
            <div class="properties-grid">
              <div class="property-card">
                <h4>Category</h4>
                <div class="value">Sorting</div>
              </div>
              <div class="property-card">
                <h4>Type</h4>
                <div class="value">Comparison</div>
              </div>
              <div class="property-card">
                <h4>Stable</h4>
                <div class="value">No</div>
              </div>
              <div class="property-card">
                <h4>In-place</h4>
                <div class="value">No</div>
              </div>
              <div class="property-card">
                <h4>Best Case</h4>
                <div class="value">O(n log n)</div>
              </div>
              <div class="property-card">
                <h4>Worst Case</h4>
                <div class="value">O(n²)</div>
              </div>
              <div class="property-card">
                <h4>Average Case</h4>
                <div class="value">O(n log n)</div>
              </div>
              <div class="property-card">
                <h4>Space</h4>
                <div class="value">O(n)</div>
              </div>
            </div>
          </div>

          <!-- Applications Section -->
          <div class="section">
            <h2><i class="fas fa-lightbulb"></i> Applications</h2>
            <p>Tree Sort is particularly useful in specific scenarios:</p>
            <ul
              style="
                padding-left: 20px;
                margin: 15px 0;
                color: var(--text-secondary);
              "
            >
              <li style="margin-bottom: 10px">
                Sorting streaming data as it arrives
              </li>
              <li style="margin-bottom: 10px">
                Situations where data is being continuously added
              </li>
              <li style="margin-bottom: 10px">
                Educational purposes to teach BST concepts
              </li>
              <li style="margin-bottom: 10px">
                When maintaining a sorted data structure is needed
              </li>
              <li>Database indexing and search operations</li>
            </ul>
          </div>

          <!-- Advantages -->
          <div class="section">
            <h2><i class="fas fa-star"></i> Advantages</h2>
            <p>
              <strong>Efficiency:</strong> Average-case O(n log n) performance
              which is optimal for comparison sorts.
            </p>
            <p>
              <strong>Incremental Sorting:</strong> Can efficiently sort data as
              it arrives.
            </p>
            <p>
              <strong>Conceptual Simplicity:</strong> Based on fundamental BST
              concepts, easy to understand.
            </p>
          </div>

          <!-- Limitations -->
          <div class="section">
            <h2><i class="fas fa-exclamation-triangle"></i> Limitations</h2>
            <p>
              Tree Sort has a worst-case time complexity of O(n²) when the input
              is already sorted or reverse sorted, as this creates a completely
              unbalanced tree (essentially a linked list).
            </p>
            <p>
              It requires O(n) additional space for the tree nodes, which may be
              a limitation in memory-constrained environments.
            </p>
          </div>
        </div>
      </div>

      <!-- Footer -->
      <footer>
        <div class="footer-links">
          <a href="https://www.linkedin.com/in/sgkandale/" target="_blank"><i class="fa-brands fa-linkedin"></i> LinkedIN</a>
          <a href="mailto:me@sgkandale.com"><i class="fa-solid fa-at"></i> E-Mail</a>
          <a href="https://buymeacoffee.com/sgkandale" target="_blank"><i class="fa-solid fa-mug-hot"></i> Buy Me a Coffee</a>
        </div>
        <p>AlgoViz Hub - Interactive Algorithm Visualization Platform</p>
        <p>&copy; 2025 AlgoViz Hub. All rights reserved.</p>
      </footer>
    </div>

    <script>
      // Tree Sort Visualization Logic
      class TreeNode {
        constructor(value) {
          this.value = value;
          this.left = null;
          this.right = null;
          this.x = 0;
          this.y = 0;
          this.id = Math.random().toString(36).substr(2, 9);
        }
      }

      let array = [8, 3, 2, 7, 4, 9, 1, 6, 5];
      let originalArray = [...array];
      let root = null;
      let sortedArray = [];
      let currentStep = 0;
      let currentIndex = 0;
      let traversalStack = [];
      let traversalState = "insertion"; // "insertion" or "traversal"
      let currentNode = null;
      let sorted = false;
      let interval = null;
      let speed = 1200;

      // DOM elements
      const vizArea = document.getElementById("vizArea");
      const arrayInput = document.getElementById("arrayInput");
      const randomBtn = document.getElementById("randomBtn");
      const runBtn = document.getElementById("runBtn");
      const stepBtn = document.getElementById("stepBtn");
      const resetBtn = document.getElementById("resetBtn");

      // Initialize visualization
      resetAlgorithm();

      // Event Listeners
      randomBtn.addEventListener("click", generateRandomArray);
      runBtn.addEventListener("click", toggleRun);
      stepBtn.addEventListener("click", stepAlgorithm);
      resetBtn.addEventListener("click", resetAlgorithm);
      arrayInput.addEventListener("change", updateArrayFromInput);

      // Generate a random array
      function generateRandomArray() {
        const size = Math.floor(Math.random() * 7) + 6; // 6-12 elements
        array = [];
        for (let i = 0; i < size; i++) {
          array.push(Math.floor(Math.random() * 20) + 1);
        }
        originalArray = [...array];
        arrayInput.value = array.join(", ");
        resetAlgorithm();
      }

      // Update array from input
      function updateArrayFromInput() {
        const input = arrayInput.value;
        const newArray = input
          .split(",")
          .map((num) => parseInt(num.trim()))
          .filter((num) => !isNaN(num));

        if (newArray.length > 1) {
          array = newArray;
          originalArray = [...array];
          resetAlgorithm();
        } else {
          alert("Please enter at least 2 valid numbers");
          arrayInput.value = array.join(", ");
        }
      }

      // Reset the algorithm
      function resetAlgorithm() {
        clearInterval(interval);
        array = [...originalArray];
        root = null;
        sortedArray = [];
        currentStep = 0;
        currentIndex = 0;
        traversalStack = [];
        traversalState = "insertion";
        currentNode = null;
        sorted = false;
        runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
        renderTree();
      }

      // Toggle run/pause
      function toggleRun() {
        if (sorted) {
          resetAlgorithm();
          return;
        }

        if (interval) {
          clearInterval(interval);
          interval = null;
          runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
        } else {
          interval = setInterval(stepAlgorithm, speed);
          runBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
        }
      }

      // Perform one step of the algorithm
      function stepAlgorithm() {
        if (sorted) return;

        currentStep++;

        if (traversalState === "insertion") {
          if (currentIndex < array.length) {
            const value = array[currentIndex];
            root = insertNode(root, value);
            currentIndex++;
          } else {
            // All elements inserted, switch to traversal
            traversalState = "traversal";
            currentNode = root;
          }
        } else if (traversalState === "traversal") {
          // In-order traversal
          while (currentNode !== null) {
            traversalStack.push(currentNode);
            currentNode = currentNode.left;
          }

          if (traversalStack.length === 0) {
            // Traversal complete
            sorted = true;
            clearInterval(interval);
            runBtn.innerHTML = '<i class="fas fa-redo"></i> Restart';
            renderTree();
            return;
          }

          currentNode = traversalStack.pop();
          sortedArray.push(currentNode.value);
          currentNode = currentNode.right;
        }

        renderTree();
      }

      // Insert a node into the BST
      function insertNode(node, value) {
        if (node === null) {
          return new TreeNode(value);
        }

        if (value < node.value) {
          node.left = insertNode(node.left, value);
        } else {
          node.right = insertNode(node.right, value);
        }

        return node;
      }

      // Render the binary tree
      function renderTree() {
        // Position nodes
        positionNodes(root, 0, 0, 300);

        let html = `
        <div class="tree-container">
          <div class="visualization-info">
            Step: ${currentStep} | ${getStateDescription()}
          </div>
          <div class="progress-bar" style="width: ${
            (sortedArray.length / array.length) * 100
          }%"></div>
      `;

        // Render the tree levels
        const levels = getTreeLevels(root);
        for (let i = 0; i < levels.length; i++) {
          html += `<div class="tree-level">`;
          for (let j = 0; j < levels[i].length; j++) {
            const node = levels[i][j];
            if (node) {
              let nodeClass = "tree-node";
              if (node === root) nodeClass += " root";
              if (node === currentNode) nodeClass += " active";
              if (sortedArray.includes(node.value)) nodeClass += " visited";

              html += `<div class="${nodeClass}" style="transform: translate(${node.x}px, ${node.y}px)">${node.value}</div>`;

              // Draw lines to children
              if (node.left) {
                const left = node.left;
                html += drawLine(node.x, node.y, left.x, left.y);
              }
              if (node.right) {
                const right = node.right;
                html += drawLine(node.x, node.y, right.x, right.y);
              }
            }
          }
          html += `</div>`;
        }

        // Render the sorted output
        html += `<div class="tree-output">`;
        html += `<div style="color: var(--text-secondary); margin-right: 10px;">Sorted:</div>`;
        for (let i = 0; i < sortedArray.length; i++) {
          const activeClass =
            i === sortedArray.length - 1 && traversalState === "traversal"
              ? " active"
              : "";
          html += `<div class="output-item${activeClass}">${sortedArray[i]}</div>`;
        }
        html += `</div>`;

        if (sorted) {
          html += `
          <div style="position: absolute; top: 50%; left: 0; right: 0; text-align: center; 
                      font-size: 24px; color: var(--success); transform: translateY(-50%);
                      background: rgba(0,0,0,0.7); padding: 20px;">
            <i class="fas fa-check-circle"></i> Sorting Completed!
          </div>
        `;
        }

        html += `</div>`;
        vizArea.innerHTML = html;
      }

      // Position nodes recursively
      function positionNodes(node, level, minX, maxX) {
        if (node === null) return;

        const x = (minX + maxX) / 2;
        const y = level * 80;

        node.x = x - 200; // Center the tree
        node.y = y;

        positionNodes(node.left, level + 1, minX, x);
        positionNodes(node.right, level + 1, x, maxX);
      }

      // Get tree nodes by level
      function getTreeLevels(root) {
        const levels = [];
        if (!root) return levels;

        const queue = [{ node: root, level: 0 }];

        while (queue.length > 0) {
          const { node, level } = queue.shift();

          if (levels.length <= level) {
            levels.push([]);
          }

          levels[level].push(node);

          if (node.left) {
            queue.push({ node: node.left, level: level + 1 });
          }
          if (node.right) {
            queue.push({ node: node.right, level: level + 1 });
          }
        }

        return levels;
      }

      // Draw line between nodes
      function drawLine(x1, y1, x2, y2) {
        const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        const angle = (Math.atan2(y2 - y1, x2 - x1) * 180) / Math.PI;

        // Calculate starting point (edge of circle)
        const startX = x1 + 22.5 * Math.cos((angle * Math.PI) / 180);
        const startY = y1 + 22.5 * Math.sin((angle * Math.PI) / 180);

        // Calculate ending point (edge of circle)
        const endX = x2 - 22.5 * Math.cos((angle * Math.PI) / 180);
        const endY = y2 - 22.5 * Math.sin((angle * Math.PI) / 180);

        const adjustedLength = Math.sqrt(
          Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)
        );

        return `
        <div class="tree-line" style="
          width: ${adjustedLength}px;
          transform: rotate(${angle}deg);
          top: ${startY + 22.5}px;
          left: ${startX + 22.5}px;
        "></div>
      `;
      }

      // Get description for current state
      function getStateDescription() {
        if (traversalState === "insertion" && currentIndex < array.length) {
          return `Inserting: ${array[currentIndex]}`;
        } else if (
          traversalState === "traversal" &&
          sortedArray.length < array.length
        ) {
          return `In-order traversal: Visiting node ${
            currentNode ? currentNode.value : ""
          }`;
        } else if (sorted) {
          return "Sorting completed";
        }
        return "Building binary search tree";
      }

      // Simple copy button functionality
      document
        .querySelector(".copy-btn")
        .addEventListener("click", function () {
          const code = document.querySelector(".code-block code").innerText;
          navigator.clipboard.writeText(code);

          // Show feedback
          const originalText = this.innerHTML;
          this.innerHTML = '<i class="fas fa-check"></i> Copied!';

          setTimeout(() => {
            this.innerHTML = originalText;
          }, 2000);
        });
    </script>
  </body>
</html>
